// Stanford C++ library (extracted)
// @author Marty Stepp
// @version Fri Dec 28 19:05:02 PST 2018
//
// This library has been merged into a single .h and .cpp file by an automatic script
// to make it easier to include and use with the CodeStepByStep tool.
// DO NOT EDIT THIS FILE DIRECTLY!
// If you want to make changes or additions to the Stanford C++ library,
// make them to the library's original source as separate .cpp / .h files,
// then re-run the script to extract the library into these single large merged files.

#define STANFORD_CPP_LIB_PRESENT true

using namespace std;

/////////////////////// BEGIN code extracted from StanfordCPPLib/private/init.h ///////////////////////
/*
 * File: init.h
 * ------------
 * This file contains code to check whether the Stanford C++ library has been
 * initialized, and if not, to initialize it.
 * This file must be included by every student-facing header in the Stanford
 * C++ library to make sure that the library is initialized before it is used.
 *
 * There used to be a group of files such as private/main.h, main.cpp, and
 * startup.cpp that contained various initialization code.  These were removed
 * and replaced with this style of initialization for the following reasons:
 *
 * - simplicity/consolidation
 * - allow student to NOT include console.h and use plain text console
 *
 * @version 2018/08/28
 * - refactor to use stanfordcpplib namespace and init.cpp
 * @version 2018/07/03
 * - add code to handle Qt GUI library initialization
 * @version 2017/04/25
 * - wrap library initializer in an #ifndef to avoid multiple declaration
 *
 * TODO: figure out how to support both 0-arg and 2-arg main()
 */

#ifndef _init_h
#define _init_h

#include <cstdlib>
#include <functional>
#include <stdio.h>

namespace stanfordcpplib {

/**
 * Returns true if the std::exit function is enabled.
 * This will be true unless disabled by, say, an autograder.
 */
bool exitEnabled();

/**
 * Initializes the Stanford C++ library.
 * A call to this function is inserted before the student's main() runs.
 * This should be run from the Qt GUI (main) thread.
 */
void initializeLibrary(int argc, char** argv);

/**
 * This is for any initialization that needs to be done in the student's thread
 * rather than on the Qt GUI main thread.
 * Currently this is used primarily to set up exception handlers for the
 * student's thread so we can print usable stack traces.
 */
void initializeLibraryStudentThread();

/**
 * Runs the student's main function in its own thread, creating that thread
 * as an object of type GStudentThread.
 */
void runMainInThread(int (* mainFunc)(void));

/**
 * Runs the student's main function in its own thread, creating that thread
 * as an object of type GStudentThread.
 */
void runMainInThread(std::function<int()> mainFunc);

/**
 * Runs the student's main function in its own thread, creating that thread
 * as an object of type GStudentThread.
 */
void runMainInThreadVoid(void (* mainFuncVoid)(void));

/**
 * Runs the student's main function in its own thread, creating that thread
 * as an object of type GStudentThread.
 */
void runMainInThreadVoid(std::function<void()> mainFuncVoid);

/**
 * Sets whether the std::exit function will be enabled or not.
 * If disabled, an error() will be thrown if student tries to exit().
 */
void setExitEnabled(bool enabled);

/**
 * Shuts down the Stanford C++ library.
 * A call to this function is inserted after the student's main().
 */
void shutdownLibrary();

/**
 * Performs any initialization needed by the library during static-init phase,
 * which occurs before main() is launched.
 * The StanfordCppLibraryInitializer class below helps us do this properly.
 */
void staticInitializeLibrary();

#ifndef StanfordCppLibraryInitializer_created
#define StanfordCppLibraryInitializer_created
class StanfordCppLibraryInitializer {
public:
    /*
     * Code to initialize the library.
     * Implemented as a class constructor so that it will run before the
     * student's main function.
     * Here we put anything that we need to initialize during the static
     * phase before main() runs.
     * Presently there is nothing that requires such initialization,
     * so this is blank.
     */
    StanfordCppLibraryInitializer() {
        staticInitializeLibrary();
    }
};
static StanfordCppLibraryInitializer __stanfordcpplib_init;
#endif // __StanfordCppLibraryInitializer_created

} // namespace stanfordcpplib

// bypass std::exit function
namespace std {
void __stanfordcpplib__exitLibrary(int status);
} // namespace std

#define STD_EXIT __std_exit_function_
#define exit __stanfordcpplib__exitLibrary

#ifdef SPL_HEADLESS_MODE

#endif // SPL_HEADLESS_MODE

#ifdef SPL_OVERLOAD_PROBLEMATIC_POINTER_ARITHMETIC

#endif // SPL_OVERLOAD_PROBLEMATIC_POINTER_ARITHMETIC

#endif // _init_h

/////////////////////// END code extracted from StanfordCPPLib/private/init.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/private/static.h ///////////////////////
/*
 * File: static.h
 * --------------
 * This file provides several macros for declaring static variables and functions
 * in ways that are safe for usage during the C++ static initiialization phase.
 * These macros should be used to declare all not-inside-function static data
 * used by the library, since a lot of library code runs during the
 * static initialization phase.
 *
 * @version 2017/10/05
 * - added STATIC_VARIABLE_NAMESPACE
 */

#ifndef _static_h
#define _static_h

// macros for concatenating two macros
#ifndef CONCAT_IMPL
#define MACRO_CONCAT(a, ...) PRIMITIVE_CONCAT(a, __VA_ARGS__)
#define PRIMITIVE_CONCAT(a, ...) a ## __VA_ARGS__
#define MACRO_IDENT(x) x
#endif // CONCAT_IMPL

// declare static var/func and assign it the given value
#define STATIC_VARIABLE_DECLARE(type, name, value) \
    static type & s_##name() { \
        static type __##name = (value); \
        return __##name; \
    }

// declare but don't assign a value (use type's default value)
#define STATIC_VARIABLE_DECLARE_BLANK(type, name) \
    static type & s_##name() { \
        static type __##name; \
        return __##name; \
    }

// declare static const var/func and assign it the given value
#define STATIC_CONST_VARIABLE_DECLARE(type, name, value) \
    static const type & s_##name() { \
        static const type __##name = (value); \
        return __##name; \
    }

// declare static var/func collection and assign it the given elements
// (these seem to not work for multi-template collections like Map<K, V>  :-/
//  but they work for single-template collections like Vector<E>)
#define STATIC_VARIABLE_DECLARE_COLLECTION(type, name, ...) \
    static type & s_##name() { \
        static type __##name = { __VA_ARGS__ }; \
        return __##name; \
    }

// declare static var/func collection and leave it empty
#define STATIC_VARIABLE_DECLARE_COLLECTION_EMPTY(type, name) \
    static type & s_##name() { \
        static type __##name; \
        return __##name; \
    }

#define STATIC_VARIABLE_DECLARE_MAP_EMPTY(maptype, keytype, valuetype, name) \
    static maptype < keytype , valuetype > & s_##name() { \
        static maptype < keytype , valuetype > __##name; \
        return __##name; \
    }

// declare static const var/func collection and assign it the given elements
#define STATIC_CONST_VARIABLE_DECLARE_COLLECTION(type, name, ...) \
    static const type & s_##name() { \
        static const type __##name { __VA_ARGS__ }; \
        return __##name; \
    }

// look up the value of the given static variable (by calling its static s_ function)
#define STATIC_VARIABLE(name) \
    (s_##name())

// look up the value of the given static variable in another namespace
#define STATIC_VARIABLE_NAMESPACE(namespacename, name) \
    (namespacename::s_##name())

#endif // _static_h

/////////////////////// END code extracted from StanfordCPPLib/private/static.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/system/error.h ///////////////////////
/*
 * File: error.h
 * -------------
 * This file defines the <code>ErrorException</code> class and the
 * <code>error</code> function.
 *
 * @version 2018/10/18
 * - added getKind for ErrorExceptions that wrap other types of errors
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2017/11/29
 * - fix for undefined SIGUSR1 on Windows systems
 * @version 2016/11/29
 * - changed error() to accept const string& instead of string
 * @version 2016/11/23
 * - added operator << to print ErrorExceptions
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _error_h
#define _error_h

#include <csignal>
#include <exception>
#include <iostream>
#include <string>

// bug fix for missing SIGUSR1 on some Windows systems
#ifndef SIGUSR1
#define SIGUSR1 10
#endif // SIGUSR2

/**
 * This exception is thrown by calls to the <code>error</code>
 * function.  Typical code for catching errors looks like this:
 *
 *<pre>
 *    try {
 *       ... code in which an error might occur ...
 *    } catch (ErrorException& ex) {
 *       ... code to handle the error condition ...
 *    }
 *</pre>
 *
 * If an <code>ErrorException</code> is thrown at any point in the
 * range of the <code>try</code> (including in functions called from
 * that code), control will jump immediately to the error handler.
 */
class ErrorException : public std::exception {
public:
    /**
     * Creates a new ErrorException with the given error message.
     */
    ErrorException(std::string msg);

    /**
     * Frees any memory allocated by the exception.
     */
    virtual ~ErrorException() throw ();

    /**
     * Prints the exception to the standard error stream (cerr),
     * including its message and stack trace if any.
     */
    virtual void dump() const;

    /**
     * Prints the exception to the given output stream,
     * including its message and stack trace if any.
     */
    virtual void dump(std::ostream& out) const;

    /**
     * Returns what kind of exception this is.
     * In general this returns "error", but in some cases we catch other kinds
     * of exceptions (like thrown ints or strings) and wrap them up as
     * ErrorExceptions. In such cases, the kind will be "int" or "string" etc.
     */
    virtual std::string getKind() const;

    /**
     * Returns the exception's error message as passed to its constructor.
     */
    virtual std::string getMessage() const;

    /**
     * Returns a stack trace for this exception as a multi-line string.
     * See exceptions.h/cpp for descriptions of the format.
     * Not every exception has a proper stack trace, based on when/why it was
     * thrown, platform incompatibilities, and other issues; use hasStackTrace to
     * check if a given exception's stack trace is populated.
     */
    virtual std::string getStackTrace() const;

    /**
     * Returns whether this exception has a non-empty stack trace.
     * Not every exception has a proper stack trace, based on when/why it was
     * thrown, platform incompatibilities, and other issues; use hasStackTrace to
     * check if a given exception's stack trace is populated.
     */
    virtual bool hasStackTrace() const;

    /**
     * Sets what kind of exception this is.
     * Default is "error".
     */
    void setKind(const std::string& kind);

    /**
     * Returns the exception's error message as a C string.
     */
    virtual const char* what() const throw ();

protected:
    /**
     * Sets this exception's stack trace to the given multi-line string.
     */
    void setStackTrace(const std::string& stackTrace);

private:
    std::string _kind;
    std::string _msg;
    std::string _stackTrace;

    /**
     * Prepends "*** " to each line of the given string.
     * Used to format stack traces that print to the console.
     */
    static std::string insertStarsBeforeEachLine(const std::string& s);
};

/**
 * Prints the error exception to the given output stream.
 */
std::ostream& operator <<(std::ostream& out, const ErrorException& ex);

// TODO: use [[noreturn]] or Q_NO_RETURN to indicate that function does not ever return
// (added in c++11; still incompatible with some compilers?)

/**
 * Signals an error condition in a program by throwing an
 * <code>ErrorException</code> with the specified message.
 */
/* [[noreturn]] */ void error(const std::string& msg);

#endif // _error_h

/////////////////////// END code extracted from StanfordCPPLib/system/error.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/require.h ///////////////////////
/*
 * File: require.h
 * ---------------
 *
 * This file contains assertion functions for argument checking within the
 * code of the Stanford C++ library itself.
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _require_h
#define _require_h

#include <string>

/**
 * @private
 */
namespace require {

void inRange(double value, double min, double max, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void inRange(int value, int min, int max, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void inRange2D(double x, double y, double maxX, double maxY, const std::string& caller = "", const std::string& xValueName = "", const std::string& yValueName = "", const std::string& details = "");
void inRange2D(double x, double y, double minX, double minY, double maxX, double maxY, const std::string& caller = "", const std::string& xValueName = "", const std::string& yValueName = "", const std::string& details = "");
void inRange2D(int x, int y, int maxX, int maxY, const std::string& caller = "", const std::string& xValueName = "", const std::string& yValueName = "", const std::string& details = "");
void inRange2D(int x, int y, int minX, int minY, int maxX, int maxY, const std::string& caller = "", const std::string& xValueName = "", const std::string& yValueName = "", const std::string& details = "");
void nonEmpty(const std::string& str, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void nonNegative(double value, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void nonNegative(int value, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void nonNegative2D(double x, double y, const std::string& caller = "", const std::string& xValueName = "", const std::string& yValueName = "", const std::string& details = "");
void nonNegative2D(int x, int y, const std::string& caller = "", const std::string& xValueName = "", const std::string& yValueName = "", const std::string& details = "");
void nonNull(const void* ptr, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void positive(double value, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void positive(int value, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void require(bool test, const std::string& caller = "", const std::string& details = "");

} // namespace require

#endif // _require_h

/////////////////////// END code extracted from StanfordCPPLib/util/require.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/private/headless.h ///////////////////////
/*
 * File: headless.h
 * ----------------
 * This file contains some code for running in "headless" mode with no GUI.
 *
 * @version 2018/11/22
 * - initial version
 */



#ifndef _headless_h
#define _headless_h

#ifdef SPL_HEADLESS_MODE

// make up a Qt version
#define QT_VERSION 5110

// make Qt version macro produce a version less than this
#define QT_VERSION_CHECK(a, b, c) 5090

#endif // SPL_HEADLESS_MODE

#endif // _headless_h

/////////////////////// END code extracted from StanfordCPPLib/private/headless.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/io/base64.h ///////////////////////
/*
 * File: base64.h
 * --------------
 * This file declares a set of functions for encoding and decoding binary data
 * in the base64 format.  See:
 * http://en.wikipedia.org/wiki/Base64
 *
 * @author Marty Stepp, based upon open-source Apache Base64 en/decoder
 * @version 2014/08/03
 * @since 2014/08/03
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _base64_h
#define _base64_h

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

int Base64encode_len(int len);
int Base64encode(char* coded_dst, const char* plain_src, int len_plain_src);

int Base64decode_len(const char* coded_src);
int Base64decode(char* plain_dst, const char* coded_src);

#ifdef __cplusplus
}

#include <string>

namespace Base64 {
/**
 * Returns a Base64-encoded equivalent of the given string.
 */
std::string encode(const std::string& s);

/**
 * Decodes the given Base64-encoded string and returns the decoded
 * original contents.
 */
std::string decode(const std::string& s);
}
#endif // __cplusplus

#endif // _base64_h

/////////////////////// END code extracted from StanfordCPPLib/io/base64.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/direction.h ///////////////////////
/*
 * File: direction.h
 * -----------------
 * This file exports an enumerated type called <code>Direction</code>
 * whose elements are the four compass points: <code>NORTH</code>,
 * <code>EAST</code>, <code>SOUTH</code>, and <code>WEST</code>.
 *
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _direction_h
#define _direction_h

#include <iostream>
#include <string>

/**
 * This enumerated type is used to represent the four compass directions.
 */
enum Direction { NORTH, EAST, SOUTH, WEST };

/**
 * Returns the direction that is to the left of the argument.
 */
Direction leftFrom(Direction dir);

/**
 * Returns the direction that is to the right of the argument.
 */
Direction rightFrom(Direction dir);

/**
 * Returns the direction that is opposite to the argument.
 */
Direction opposite(Direction dir);

/**
 * Returns the name of the direction as a string.
 */
std::string directionToString(Direction dir);

/**
 * Overloads the <code>&lt;&lt;</code> operator so that it is able
 * to display <code>Direction</code> values.
 */
std::ostream& operator <<(std::ostream& os, const Direction& dir);

/**
 * Overloads the <code>&gt;&gt;</code> operator so that it is able
 * to read <code>Direction</code> values.
 */
std::istream& operator >>(std::istream& os, Direction& dir);

/**
 * Overloads the suffix version of the <code>++</code> operator to
 * work with <code>Direction</code> values.  The sole purpose of this
 * definition is to support the idiom
 *
 *<pre>
 *    for (Direction dir = NORTH; dir &lt;= WEST; dir++) ...
 *</pre>
 */
Direction operator ++(Direction& dir, int);

#endif // _direction_h

/////////////////////// END code extracted from StanfordCPPLib/util/direction.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/hashcode.h ///////////////////////
/*
 * File: hashcode.h
 * ----------------
 * This file declares global hashing functions for various common data types.
 * These functions are used by the HashMap and HashSet collections, as well as
 * by other collections that wish to be used as elements within HashMaps/Sets.
 *
 * @version 2017/10/21
 * - added hash codes for short, unsigned integers
 * @version 2017/09/29
 * - added composite hashCode functions (hashCode2, 3, 4, ...)
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 *   (hashSeed(), hashMultiplier(), and hashMask())
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _hashcode_h
#define _hashcode_h

#include <string>
#include <utility>

/*
 * Function: hashCode
 * Usage: int hash = hashCode(key);
 * --------------------------------
 * Returns a hash code for the specified key, which is always a
 * nonnegative integer.  This function is overloaded to support
 * all of the primitive types and the C++ <code>string</code> type.
 */
int hashCode(bool key);
int hashCode(char key);
int hashCode(double key);
int hashCode(float key);
int hashCode(long double key);
int hashCode(int key);
int hashCode(unsigned int key);
int hashCode(long key);
int hashCode(unsigned long key);
int hashCode(short key);
int hashCode(unsigned short key);
int hashCode(const char* str);
int hashCode(const std::string& str);
int hashCode(void* key);

/*
 * Constants that are used to help implement these functions
 * (see hashcode.h for example usage)
 */
int hashSeed();         // Starting point for first cycle
int hashMultiplier();   // Multiplier for each cycle
int hashMask();         // All 1 bits except the sign

/*
 * Computes a composite hash code from a list of multiple values.
 * The components are scaled up so as to spread out the range of values
 * and reduce collisions.
 * The type of each value passed must have a suitable hashCode() function.
 */
template <typename T1, typename T2, typename... Others>
int hashCode(T1&& first, T2&& second, Others&&... remaining) {
    int result = hashSeed();

    /* Compute the hash code for the last n - 1 arguments. */
    result += hashCode(std::forward<T2>(second), std::forward<Others>(remaining)...);

    /* Update the hash to factor in the hash of the first element. */
    result *= hashMultiplier();
    result += hashCode(std::forward<T1>(first));

    /* Hash the resulting integer to mask off any unneeded bits. */
    return hashCode(result);
}

#endif // _hashcode_h

/////////////////////// END code extracted from StanfordCPPLib/collections/hashcode.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/random.h ///////////////////////
/*
 * File: random.h
 * --------------
 * This file exports functions for generating pseudorandom numbers.
 * 
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2017/10/05
 * - added randomFeedClear
 * @version 2017/09/28
 * - moved random 'feed' functions into autograder namespace
 * @version 2016/08/02
 * - added randomColor, randomColorString
 * @version 2014/10/19
 * - alphabetized functions
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _random_h
#define _random_h

#include <string>

/**
 * Returns <code>true</code> with 50% probability.
 */
bool randomBool();

/**
 * Returns <code>true</code> with the probability indicated by <code>p</code>.
 * The argument <code>p</code> must be a floating-point number between
 * 0 (never) and 1 (always).  For example, calling
 * <code>randomChance(.30)</code> returns <code>true</code> 30 percent
 * of the time.
 */
bool randomChance(double p);

/**
 * Returns a random RGB color as an integer.
 * See also: gwindow.h convertRGBToColor()
 */
int randomColor();

/**
 * Returns a random RGB color as a hex string like "#ff00ff" for magenta.
 * See also: gwindow.h convertColorToRGB()
 */
std::string randomColorString();

/**
 * Returns a random integer in the range <code>low</code> to
 * <code>high</code>, inclusive.
 */
int randomInteger(int low, int high);

/**
 * Returns a random real number in the half-open interval
 * [<code>low</code>&nbsp;..&nbsp;<code>high</code>).  A half-open
 * interval includes the first endpoint but not the second, which
 * means that the result is always greater than or equal to
 * <code>low</code> but strictly less than <code>high</code>.
 */
double randomReal(double low, double high);

/**
 * Sets the internal random number seed to the specified value.  You
 * can use this function to set a specific starting point for the
 * pseudorandom sequence or to ensure that program behavior is
 * repeatable during the debugging phase.
 */
void setRandomSeed(int seed);

/**
 * Extra functions to facilitate creation of autograder programs.
 * @private
 */
namespace autograder {
/**
 * Inserts the given boolean value to be returned by the random number
 * generator, rather than truly random choices.
 */
void randomFeedBool(bool value);

/**
 * Removes any previously 'fed' random integers so that future calls
 * to random functions will return truly random values.
 */
void randomFeedClear();

/**
 * Inserts the given integer to be returned by the random number generator,
 * rather than truly random numbers.
 */
void randomFeedInteger(int value);

/**
 * Inserts the given real number to be returned by the random number generator,
 * rather than truly random numbers.
 */
void randomFeedReal(double value);
}

#endif // _random_h

/////////////////////// END code extracted from StanfordCPPLib/util/random.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/point.h ///////////////////////
/*
 * File: point.h
 * -------------
 * This file exports a class representing an integer-valued <i>x</i>-<i>y</i>
 * pair.
 *
 * @version 2018/11/22
 * - added headless mode support
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _point_h
#define _point_h

#include <string>

#ifndef SPL_HEADLESS_MODE
class GPoint;   // forward declaration
#endif // SPL_HEADLESS_MODE

/**
 * This class represents an <i>x</i>-<i>y</i> coordinate point on a
 * two-dimensional integer grid.  If you need to work with real-valued points,
 * you should use the <a href="gtypes.html"><code>gtypes.h</code></a>
 * interface instead.
 */
class Point {
public:
    /**
     * Creates a <code>Point</code> object at (0, 0).
     */
    Point();

    /**
     * Creates a <code>Point</code> object with the specified x and y coordinates.
     */
    Point(int x, int y);

#ifndef SPL_HEADLESS_MODE
    /**
     * Creates a <code>Point</code> object with the same x and y coordinates
     * as the given other point.
     */
    Point(const GPoint& point);
#endif // SPL_HEADLESS_MODE

    /**
     * Returns the <i>x</i>-coordinate of the point.
     */
    int getX() const;

    /**
     * Returns the <i>y</i>-coordinate of the point.
     */
    int getY() const;

    /**
     * Returns a string representation of the <code>Point</code> in the form
     * <code>"(x, y)"</code>.
     */
    std::string toString() const;

    /**
     * Returns <code>true</code> if <code>p1</code> and <code>p2</code>
     * are the same point.
     */
    bool operator ==(const Point& p2) const;

    /**
     * Returns <code>true</code> if <code>p1</code> and <code>p2</code>
     * are different.
     */
    bool operator !=(const Point& p2) const;

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    // instance variables
    int x;                         // the x-coordinate of the point
    int y;                         // the y-coordinate of the point
};

/**
 * Overloads the <code>&lt;&lt;</code> operator so that it is able
 * to display <code>Point</code> values.
 */
std::ostream& operator <<(std::ostream& os, const Point& pt);

/**
 * Hash code function for Point objects.
 */
int hashCode(const Point& pt);

#endif // _point_h

/////////////////////// END code extracted from StanfordCPPLib/util/point.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/io/simpio.h ///////////////////////
/*
 * File: simpio.h
 * --------------
 * This file exports a set of functions that simplify input/output
 * operations in C++ and provide some error-checking on console input.
 * 
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2016/09/29
 * - added getDouble method
 * @version 2015/07/05
 * - increased visibility of appendSpace function used by various IO
 *   prompting functions (no longer static)
 * @version 2014/10/19
 * - alphabetized functions
 * - converted many funcs to take const string& rather than string for efficiency
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _simpio_h
#define _simpio_h

#include <iostream>
#include <string>

/**
 * Adds a space at the end of the given string by reference if none is present.
 * @private
 */
void appendSpace(std::string& prompt);

/**
 * Reads a complete line from <code>cin</code>, expecting the user to type a
 * single character. If this is the case, that character value is returned.
 * If the user types anything other than a one-character line of input,
 * the user is given a chance to reenter the value.
 *
 * If supplied, the optional <code>prompt</code> string is printed before
 * reading the value.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "You must type a single character. Try again.".
 */
char getChar(const std::string& prompt = "",
             const std::string& reprompt = "");

/**
 * Reads a complete line from <code>cin</code> and scans it as a
 * floating-point number. If the scan succeeds, the floating-point
 * value is returned.  If the input is not a legal number or if
 * extraneous characters (other than whitespace) appear in the string,
 * the user is given a chance to reenter the value.
 *
 * If supplied, the optional <code>prompt</code> string is printed before
 * reading the value.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "Illegal numeric format. Try again.".
 *
 * Equivalent to getReal.
 */
double getDouble(const std::string& prompt = "",
                 const std::string& reprompt = "");

/**
 * Reads a complete line from <code>cin</code> and scans it as a
 * floating-point number. If the scan succeeds, the floating-point
 * value is returned.  If the input is not a legal number or if
 * it is not between min and max, or if extraneous characters
 * (other than whitespace) appear in the string,
 * the user is given a chance to reenter the value.
 *
 * The required <code>prompt</code> string is printed before reading the value.
 *
 * Equivalent to getRealBetween.
 */
double getDoubleBetween(const std::string& prompt, double min, double max);


/**
 * Reads a complete line from <code>cin</code> and scans it as an
 * integer. If the scan succeeds, the integer value is returned. If
 * the argument is not a legal integer or if extraneous characters
 * (other than whitespace) appear in the string, the user is given
 * a chance to reenter the value.
 *
 * If supplied, the optional <code>prompt</code> string is printed before
 * reading the value.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "Illegal integer format. Try again.".
 */
int getInteger(const std::string& prompt = "",
               const std::string& reprompt = "");

/**
 * Reads a complete line from <code>cin</code> and scans it as an
 * integer. If the scan succeeds, the integer value is returned. If
 * the argument is not a legal integer, if it is not between min and max,
 * or if extraneous characters (other than whitespace) appear in the string,
 * the user is given a chance to reenter the value.
 *
 * The required <code>prompt</code> string is printed before reading the value.
 */
int getIntegerBetween(const std::string& prompt, int min, int max);

/**
 * Reads a line of text from <code>cin</code> and returns that line
 * as a string.  The newline character that terminates the input is
 * not stored as part of the return value.  If supplied, the optional
 * <code>prompt</code> string is printed before reading the value.
 */
std::string getLine(const std::string& prompt = "");

/**
 * Alternate version of getLine that accepts a prompt and fills a given output
 * variable with its result.
 */
void getLine(const std::string& prompt,
             std::string& out);

/**
 * Alternate version of getLine that accepts an input stream to read from.
 * Meant as a drop-in replacement for the standard C++ getline (lowercase L)
 * function.
 */
void getLine(std::istream& input,
             std::string& out);

/**
 * Reads a complete line from <code>cin</code> and scans it as a
 * floating-point number. If the scan succeeds, the floating-point
 * value is returned.  If the input is not a legal number or if
 * extraneous characters (other than whitespace) appear in the string,
 * the user is given a chance to reenter the value.
 *
 * If supplied, the optional <code>prompt</code> string is printed before
 * reading the value.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "Illegal numeric format. Try again.".
 *
 * Equivalent to getDouble.
 */
double getReal(const std::string& prompt = "",
               const std::string& reprompt = "");

/**
 * Reads a complete line from <code>cin</code> and scans it as a
 * floating-point number. If the scan succeeds, the floating-point
 * value is returned.  If the input is not a legal number or if
 * it is not between min and max, or if extraneous characters
 * (other than whitespace) appear in the string,
 * the user is given a chance to reenter the value.
 *
 * The required <code>prompt</code> string is printed before reading the value.
 *
 * Equivalent to getDoubleBetween.
 */
double getRealBetween(const std::string& prompt, double min, double max);

/**
 * Reads a complete line from <code>cin</code> and treats it as a
 * yes-or-no answer to a question.  Returns <code>true</code> if the line
 * typed begins with a 'y' or 'Y', and returns <code>false</code> if it begins
 * with a 'n' or 'N'.  Otherwise the user is given a chance to reenter the
 * value.
 *
 * If supplied, the optional <code>prompt</code> string is printed before
 * reading the value.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to,
 * "Please type a word that starts with 'Y' or 'N'.".
 * 
 * The also also optional <code>defaultValue</code> argument indicates what
 * should happen if the user just presses Enter rather than typing Y or N.
 * By default, the user is re-prompted, but if a defaultValue is passed here,
 * pressing Enter will be equivalent to having typed that value.
 * This is useful where the default Y/N answer is Yes or No and you want to
 * let the user avoid typing.
 */
bool getYesOrNo(const std::string& prompt = "",
                const std::string& reprompt = "",
                const std::string& defaultValue = "");

#endif // _simpio_h

/////////////////////// END code extracted from StanfordCPPLib/io/simpio.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/functional.h ///////////////////////
/*
 * File: functional.h
 * ------------------
 * Contains a few functions for functional programming.
 *
 * The map, filter, and reduce operations are quite common in functional
 * programming systems.  They allow for elegant functional solutions to many
 * common programming tasks involving collections of data.
 *
 * There are similar functions in the C++ STL algorithm package.
 * But those functions often operate on STL iterators.
 * By contrast, these functions accept collections as parameters instead.
 * This is preferable for introductory students who are just learning.
 *
 * Implementation detail: Each function has several overloads.
 * Some of these are to allow for functions and predicates that accept their
 * arguments either by value or by const reference.
 * Other overloads allow either returning the result collection or passing it in
 * by reference as an output parameter to be filled in.
 *
 * We do not support "in-place" versions of these functions, partly because
 * there is not a perfect standard "remove" member across all collections that
 * accepts a value to remove as its parameter, and partly because the more common
 * functional style is to expect a new collection result to be returned.
 *
 * @author Marty Stepp
 * @version 2018/03/10
 * - initial version
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _functional_h
#define _functional_h

namespace functional {

/*
 * Performs a filter operation on the given collection,
 * returning a new collection that retains only the elements
 * for which the given predicate function returns true.
 */
template <typename CollectionType, typename ElementType>
CollectionType filter(CollectionType collection,
                      bool (*predicate)(ElementType)) {
    CollectionType result;
    for (const ElementType& element : collection) {
        if (predicate(element)) {
            result.add(element);
        }
    }
    return result;
}

/*
 * Performs a filter operation on the given collection,
 * returning a new collection that retains only the elements
 * for which the given predicate function returns true.
 */
template <typename CollectionType, typename ElementType>
CollectionType filter(CollectionType collection,
                      bool (*predicate)(const ElementType&)) {
    CollectionType result;
    for (const ElementType& element : collection) {
        if (predicate(element)) {
            result.add(element);
        }
    }
    return result;
}

/*
 * Performs a filter operation on the given collection,
 * building a new collection that retains only the elements
 * for which the given predicate function returns true.
 * The new collection is stored in the given 'result' variable.
 * A reference to that same result is returned for convenience.
 */
template <typename CollectionType, typename ElementType>
CollectionType& filter(CollectionType collection,
                       bool (*predicate)(ElementType),
                       CollectionType& result) {
    for (const ElementType& element : collection) {
        if (predicate(element)) {
            result.add(element);
        }
    }
    return result;
}

/*
 * Performs a filter operation on the given collection,
 * building a new collection that retains only the elements
 * for which the given predicate function returns true.
 * The new collection is stored in the given 'result' variable.
 * A reference to that same result is returned for convenience.
 */
template <typename CollectionType, typename ElementType>
CollectionType& filter(CollectionType collection,
                       bool (*predicate)(const ElementType&),
                       CollectionType& result) {
    for (const ElementType& element : collection) {
        if (predicate(element)) {
            result.add(element);
        }
    }
    return result;
}

/*
 * Applies the given function to each element of the given collection,
 * producing and returning a new collection containing the results.
 */
template <typename CollectionType, typename ElementType>
CollectionType map(CollectionType collection,
                   ElementType (*fn)(ElementType)) {
    CollectionType result;
    for (const ElementType& element : collection) {
        result.add(fn(element));
    }
    return result;
}

/*
 * Applies the given function to each element of the given collection,
 * producing and returning a new collection containing the results.
 */
template <typename CollectionType, typename ElementType>
CollectionType map(CollectionType collection,
                   ElementType (*fn)(const ElementType&)) {
    CollectionType result;
    for (const ElementType& element : collection) {
        result.add(fn(element));
    }
    return result;
}

/*
 * Applies the given function to each element of the given collection,
 * producing a new collection containing the results.
 * The new collection is stored in the 'result' variable.
 * A reference to that same result is returned for convenience.
 */
template <typename CollectionType, typename ElementType,
          typename CollectionType2, typename ElementType2>
CollectionType2& map(CollectionType collection,
                     ElementType2 (*fn)(ElementType),
                     CollectionType2& result) {
    for (const ElementType& element : collection) {
        result.add(fn(element));
    }
    return result;
}

/*
 * Applies the given function to each element of the given collection,
 * producing a new collection containing the results.
 * The new collection is stored in the 'result' variable.
 * A reference to that same result is returned for convenience.
 */
template <typename CollectionType, typename ElementType,
          typename CollectionType2, typename ElementType2>
CollectionType2& map(CollectionType collection,
                     ElementType2 (*fn)(const ElementType&),
                     CollectionType2& result) {
    for (const ElementType& element : collection) {
        result.add(fn(element));
    }
    return result;
}

/*
 * Performs a reduction operation, applying a function to each neighboring pair
 * of elements of the collection until they are all combined (reduced) into a
 * single value, which is then returned.
 */
template <typename CollectionType, typename ElementType>
ElementType reduce(CollectionType collection,
                   ElementType (*fn)(ElementType e1, ElementType e2),
                   ElementType startValue) {
    ElementType prev = startValue;
    for (const ElementType& element : collection) {
        prev = fn(prev, element);
    }
    return prev;
}

/*
 * Performs a reduction operation, applying a function to each neighboring pair
 * of elements of the collection until they are all combined (reduced) into a
 * single value, which is then returned.
 */
template <typename CollectionType, typename ElementType>
ElementType reduce(CollectionType collection,
                   ElementType (*fn)(ElementType e1, ElementType e2)) {
    bool first = true;
    ElementType prev;
    for (const ElementType& element : collection) {
        if (first) {
            prev = element;
            first = false;
        } else {
            prev = fn(prev, element);
        }
    }
    return prev;
}

/*
 * Performs a reduction operation, applying a function to each neighboring pair
 * of elements of the collection until they are all combined (reduced) into a
 * single value, which is then returned.
 * Begins the reduction with the given starting value, which is then merged
 * with each value from the collection one at a time.
 */
template <typename CollectionType, typename ElementType>
ElementType reduce(CollectionType collection,
                   ElementType (*fn)(const ElementType& e1, const ElementType& e2),
                   ElementType startValue) {
    ElementType prev = startValue;
    for (const ElementType& element : collection) {
        prev = fn(prev, element);
    }
    return prev;
}

/*
 * Performs a reduction operation, applying a function to each neighboring pair
 * of elements of the collection until they are all combined (reduced) into a
 * single value, which is then returned.
 * Begins the reduction with the given starting value, which is then merged
 * with each value from the collection one at a time.
 */
template <typename CollectionType, typename ElementType>
ElementType reduce(CollectionType collection,
                   ElementType (*fn)(const ElementType& e1, const ElementType& e2)) {
    bool first = true;
    ElementType prev;
    for (const ElementType& element : collection) {
        if (first) {
            prev = element;
            first = false;
        } else {
            prev = fn(prev, element);
        }
    }
    return prev;
}

} // namespace functional

#endif // _functional_h

/////////////////////// END code extracted from StanfordCPPLib/collections/functional.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/gmath.h ///////////////////////
/*
 * File: gmath.h
 * -------------
 * This file exports several functions for working with graphical
 * geometry along with the mathematical constants <code>PI</code>
 * and <code>E</code>.
 *
 * @version 2018/11/22
 * - added headless mode support
 * - alphabetized methods
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2017/12/12
 * - added floatingPointEqual(a, b, tolerance)
 * @version 2016/10/14
 * - added floatingPointEqual method for comparing floats and doubles
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _gmath_h
#define _gmath_h

#include <cmath>
#include <limits>

#ifndef SPL_HEADLESS_MODE
#define INTERNAL_INCLUDE 1

#endif // SPL_HEADLESS_MODE

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * The mathematical constant pi, which is the ratio of the circumference
 * of a circle to its diameter.
 */
extern const double PI;

/**
 * Constant: E
 * -----------
 * The mathematical constant e, which is the base of natural logarithms.
 */
extern const double E;

/**
 * Returns the trigonometric cosine of <code>angle</code>, which is
 * expressed in degrees.
 */
double cosDegrees(double angle);


/**
 * Returns the number of digits in the given integer in the given base.
 * Defaults to base-10, decimal.
 * @example countDigits(3456) returns 4.
 * @example countDigits(0)    returns 1.
 * @example countDigits(-778) returns 3.
 * @throw ErrorException if base is 0 or negative.
 */
int countDigits(int n, int base = 10);

/**
 * Returns true if the two given floating-point numbers are "equal" to each other,
 * within a given tolerance.
 * Floating-point equality is tricky because of round-off errors, which can cause
 * the numbers to be nearly the same but not identical.
 *
 * See also:
 * http://stackoverflow.com/questions/4548004/how-to-correctly-and-standardly-compare-floats
 */
template<typename T>
bool floatingPointEqual(T f1, T f2, T tolerance) {
    return (std::fabs(f1 - f2) <= tolerance);
}

/**
 * Returns true if the two given floating-point numbers are "equal" to each other.
 * Floating-point equality is tricky because of round-off errors, which can cause
 * the numbers to be nearly the same but not identical.
 *
 * See also:
 * http://stackoverflow.com/questions/4548004/how-to-correctly-and-standardly-compare-floats
 */
template<typename T>
bool floatingPointEqual(T f1, T f2) {
    return floatingPointEqual(f1, f2, /* tolerance */ (T) std::numeric_limits<T>::epsilon() * std::fmax(fabs(f1), fabs(f2)));
}

/**
 * Returns true if the given floating-point number is "equal" to the given integer.
 * Floating-point equality is tricky because of round-off errors, which can cause
 * the numbers to be nearly the same but not identical.
 *
 * See also:
 * http://stackoverflow.com/questions/4548004/how-to-correctly-and-standardly-compare-floats
 */
template<typename T>
bool floatingPointEqual(T f1, int f2) {
    return floatingPointEqual(f1, (T) f2);
}

/**
 * Returns true if the given floating-point number is "equal" to the given integer.
 * Floating-point equality is tricky because of round-off errors, which can cause
 * the numbers to be nearly the same but not identical.
 *
 * See also:
 * http://stackoverflow.com/questions/4548004/how-to-correctly-and-standardly-compare-floats
 */
template<typename T>
bool floatingPointEqual(int f1, T f2) {
    return floatingPointEqual((T) f1, f2);
}

/**
 * Returns true if the given floating-point number is "equal" to the given integer.
 * Floating-point equality is tricky because of round-off errors, which can cause
 * the numbers to be nearly the same but not identical.
 *
 * See also:
 * http://stackoverflow.com/questions/4548004/how-to-correctly-and-standardly-compare-floats
 */
template<typename T>
bool floatingPointEqual(T f1, long int f2) {
    return floatingPointEqual(f1, (T) f2);
}

/**
 * Returns true if the given floating-point number is "equal" to the given integer.
 * Floating-point equality is tricky because of round-off errors, which can cause
 * the numbers to be nearly the same but not identical.
 *
 * See also:
 * http://stackoverflow.com/questions/4548004/how-to-correctly-and-standardly-compare-floats
 */
template<typename T>
bool floatingPointEqual(long int f1, T f2) {
    return floatingPointEqual((T) f1, f2);
}

/**
 * Returns the trigonometric sine of <code>angle</code>, which is
 * expressed in degrees.
 */
double sinDegrees(double angle);

/**
 * Returns the trigonometric tangent of <code>angle</code>, which is
 * expressed in degrees.
 */
double tanDegrees(double angle);

/**
 * Converts an angle from radians to degrees.
 */
double toDegrees(double radians);

/**
 * Converts an angle from degrees to radians.
 */
double toRadians(double degrees);

/**
 * Returns the angle in degrees from the origin to the specified point.
 * This function takes account of the fact that the graphics coordinate
 * system is flipped in the <i>y</i> direction from the traditional
 * Cartesian plane.
 */
double vectorAngle(double x, double y);

/**
 * Returns the angle in degrees from the origin to the specified point.
 * This function takes account of the fact that the graphics coordinate
 * system is flipped in the <i>y</i> direction from the traditional
 * Cartesian plane.
 */
#ifndef SPL_HEADLESS_MODE
double vectorAngle(const GPoint& pt);
#endif // SPL_HEADLESS_MODE
double vectorAngle(const Point& pt);

/**
 * Computes the distance between the origin and the specified point.
 */
double vectorDistance(double x, double y);

/**
 * Computes the distance between the origin and the specified point.
 */
#ifndef SPL_HEADLESS_MODE
double vectorDistance(const GPoint& pt);
#endif // SPL_HEADLESS_MODE
double vectorDistance(const Point& pt);

#endif // _gmath_h

/////////////////////// END code extracted from StanfordCPPLib/util/gmath.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/shuffle.h ///////////////////////
/*
 * File: shuffle.h
 * ---------------
 * This file contains implementation of a shuffling function that operates on
 * a 1-D and 2-D array, Vector, or Grid of any type.
 *
 * @author Marty Stepp
 * @since 2014/02/01
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _shuffle_h
#define _shuffle_h

#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Randomly rearranges the elements of the given array up to the given length.
 * Precondition: The array pointer points to a valid non-null array in memory,
 * and that array contains at least 'length' elements.
 */
template <typename T>
void shuffle(T* array, int length) {
    for (int i = 0; i < length; i++) {
        int j = randomInteger(i, length - 1);
        if (i != j) {
            T temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }
}

/*
 * Randomly rearranges the elements of the given 2-D array up to the given
 * number of rows and columns.
 * Precondition: The array pointer points to a valid non-null 2-D array in
 * memory, and that array contains at least the given number of rows/columns.
 */
template <typename T>
void shuffle(T** array2d, int rows, int cols) {
    int length = rows * cols;
    for (int i = 0; i < length; i++) {
        int j = randomInteger(i, length - 1);
        if (i != j) {
            int r1 = i / cols;
            int c1 = i % cols;
            int r2 = j / cols;
            int c2 = j % cols;

            T temp = array2d[r1][c1];
            array2d[r1][c1] = array2d[r2][c2];
            array2d[r2][c2] = temp;
        }
    }
}

/*
 * Randomly rearranges the characters of the given string and returns the
 * rearranged version.
 */
std::string shuffle(std::string s);

#endif // _shuffle_h

/////////////////////// END code extracted from StanfordCPPLib/collections/shuffle.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/collections.h ///////////////////////
/*
 * File: collections.h
 * -------------------
 * Contains general-purpose functions for use with many collections.
 *
 * For example, we have functions for comparing any collections that have
 * a visible iterator (begin(), end()).
 * Used to implement comparison operators like < and >= on collections.
 *
 * @author Marty Stepp
 * @version 2017/12/12
 * - added equalsDouble for collections of double values (can't compare with ==)
 * @version 2017/10/18
 * - fix compiler warnings
 * @version 2017/09/29
 * - added compareTo1-5
 * @version 2016/12/09
 * - added checkVersion for iterators
 * @version 2016/09/24
 * - renamed compare.h to collections.h
 * - added printing functions
 * @version 2014/10/10
 * - initial version as compare.h
 * @since 2014/10/10
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _collections_h
#define _collections_h

#include <iostream>
#include <sstream>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

// begin global namespace string read/writing functions from strlib.h

/**
 * Reads the next string from infile into the reference parameter str.
 * If the first character (other than whitespace) is either a single
 * or a double quote, this function reads characters up to the
 * matching quote, processing standard escape sequences as it goes.
 * If not, readString reads characters up to any of the characters
 * in the string STRING_DELIMITERS in the implementation file.
 *
 * @private
 */
bool readQuotedString(std::istream& is, std::string& str, bool throwOnError = true);

/**
 * Writes the string str to outfile surrounded by double quotes, converting
 * special characters to escape sequences, as necessary.  If the optional
 * parameter forceQuotes is explicitly set to false, quotes are included
 * in the output only if necessary.
 *
 * @private
 */
std::ostream& writeQuotedString(std::ostream& os, const std::string& str,
                                bool forceQuotes = true);

/**
 * Checks whether the string needs quoting in order to be read correctly.
 * @private
 */
bool stringNeedsQuoting(const std::string& str);

/**
 * Writes a generic value to the output stream.  If that value is a string,
 * this function uses writeQuotedString to write the value.
 * @private
 */
template <typename ValueType>
std::ostream& writeGenericValue(std::ostream& os, const ValueType& value, bool) {
    os << std::boolalpha << value;
    return os;
}

template <>
inline std::ostream& writeGenericValue(std::ostream& os, const std::string& value,
                              bool forceQuotes) {
    return writeQuotedString(os, value, forceQuotes);
}

template <typename ValueType>
inline std::string genericValueToString(const ValueType& value,
                                        bool forceQuotes = false) {
    std::ostringstream os;
    writeGenericValue(os, value, forceQuotes);
    return os.str();
}

template <>
inline std::string genericValueToString(const std::string& value,
                                        bool forceQuotes) {
    std::ostringstream os;
    writeQuotedString(os, value, forceQuotes);
    return os.str();
}

/**
 * Reads a generic value from the input stream.  If that value is a string,
 * this function uses readQuotedString to read the value.
 * @private
 */
template <typename ValueType>
bool readGenericValue(std::istream& is, ValueType& value) {
    return (bool) (is >> value);
}

template <>
inline bool readGenericValue(std::istream& is, std::string& value) {
    return readQuotedString(is, value, /* throwOnError */ false);
}

// end of global namespace string read/writing functions from strlib.h
namespace stanfordcpplib {
namespace collections {

#ifdef SPL_THROW_ON_INVALID_ITERATOR
template <typename CollectionType, typename IteratorType>
void checkVersion(const CollectionType& coll, const IteratorType& itr,
                  const std::string& memberName = "") {
    unsigned int collVersion = coll.version();
    unsigned int itrVersion = itr.version();
    if (itrVersion != collVersion) {
        std::string msg = memberName;
        if (!msg.empty()) {
            msg += ": ";
        }
        msg += "Collection modified during iteration. Iterator is now invalid.\n";
        msg += "Do not modify a collection during a for-each loop or iterator traversal.";
        error(msg);
    }
}
#else // SPL_THROW_ON_INVALID_ITERATOR
template <typename CollectionType, typename IteratorType>
void checkVersion(const CollectionType&, const IteratorType&,
                  const std::string& = "") {
    // empty
}
#endif

/*
 * Performs a comparison for ordering between the given two collections
 * by comparing their elements pairwise to each other.
 * Returns -1 if collection 1 is "less than" collection 2;
 * Returns  1 if collection 1 is "greater than" collection 2;
 * Returns  0 if collection 1 is "equal to" collection 2.
 * The element type must have an operator <.
 */
template <typename CollectionType>
int compare(const CollectionType& coll1, const CollectionType& coll2) {
    // optimization: if they are the same object, then they are equal
    if (&coll1 == &coll2) {
        return 0;
    }
    
    auto itr1 = coll1.begin(),
            itr2 = coll2.begin(),
            end1 = coll1.end(),
            end2 = coll2.end();
    for (;
         itr1 != end1 && itr2 != end2;
         ++itr1, ++itr2) {
        // compare each pair of elements from iterators
        
        // TO STUDENT:
        // If the line below is failing to compile in your program, it probably
        // means that you are trying to make a nested collection
        // (e.g. Set<Vector<T>>) for some element type T that does not have a
        // less-than < operator.  That operator is *required* in order to make
        // a Set or Map of Vectors, so that the set/map knows how to sort the
        // elements into their ascending order.
        // You should either add a < operator to your class, or consider a
        // different nested collection solution.  Good luck!
        if (*itr1 < *itr2) {
            return -1;
        } else if (*itr2 < *itr1) {
            return 1;
        }
    }
    
    // if we get here, everything from v1 matched v2, so they are either equal,
    // or one is shorter than the other (fewer elements) and is therefore less
    if (itr1 == end1 && itr2 == end2) {
        return 0;
    } else if (itr1 == end1) {
        return -1;
    } else {
        return 1;
    }
}

/*
 * Performs a comparison for ordering between the given two maps
 * by comparing their key/value pairs pairwise to each other.
 * Returns -1 if collection 1 is "less than" collection 2;
 * Returns  1 if collection 1 is "greater than" collection 2;
 * Returns  0 if collection 1 is "equal to" collection 2.
 * Note that the order of keys and values in the maps matter here;
 * the same map with keys in different orders would produce a different result.
 * The key and value types must both have an operator <.
 */
template <typename MapType>
int compareMaps(const MapType& map1, const MapType& map2) {
    // optimization: if they are the same object, then they are equal
    if (&map1 == &map2) {
        return 0;
    }
    
    auto itr1 = map1.begin(),
            itr2 = map2.begin(),
            end1 = map1.end(),
            end2 = map2.end();
    for (;
         itr1 != end1 && itr2 != end2;
         ++itr1, ++itr2) {
        // compare each pair of elements from iterators
        
        // TO STUDENT:
        // If the line below is failing to compile in your program, it probably
        // means that you are trying to make a nested collection
        // (e.g. Set<Map<K, V>>) for some element type K or V that does not have a
        // less-than < operator.  That operator is *required* in order to make
        // a Set or Map of Maps, so that the set/map knows how to sort the
        // keys and values into their ascending order.
        // You should either add a < operator to your key/value types, or consider a
        // different nested collection solution.  Good luck!
        if (*itr1 < *itr2) {
            return -1;
        } else if (*itr2 < *itr1) {
            return 1;
        }
        
        // key1 == key2, so compare values
        auto value1 = map1[*itr1];
        auto value2 = map2[*itr2];
        if (value1 < value2) {
            return -1;
        } else if (value2 < value1) {
            return 1;
        }
    }
    
    // if we get here, everything from v1 matched v2, so they are either equal,
    // or one is shorter than the other (fewer elements) and is therefore less
    if (itr1 == end1 && itr2 == end2) {
        return 0;
    } else if (itr1 == end1) {
        return -1;
    } else {
        return 1;
    }
}

/*
 * Compares two values and returns an integer indicating their relative order,
 * in the general style of Java's compareTo method:
 * -1 if the first value is less than the second,
 *  0 if the values are equal,
 *  1 if the first value is greater than the second.
 * The type passed must support a < less-than operator.
 */
template <typename T>
int compareTo(T t1, T t2) {
    if (t1 < t2) {
        return -1;
    } else if (t2 < t1) {
        return 1;
    } else {
        return 0;
    }
}

/*
 * Compares two pairs of values and returns an integer indicating their relative order,
 * in the general style of Java's compareTo method.
 * First the values t1 and t2 are compared.
 * If they are equal, ties are broken by comparing t3 and t4.
 * -1 if the first value is less than the second,
 *  0 if the values are equal,
 *  1 if the first value is greater than the second.
 * The types passed must support a < less-than operator.
 */
template <typename T1, typename T2>
int compareTo2(T1 t1, T1 t2, T2 t3, T2 t4) {
    if (t3 < t4) {
        return -1;
    } else if (t4 < t3) {
        return 1;
    } else {
        return compareTo(t1, t2);
    }
}

/*
 * Compares three pairs of values and returns an integer indicating their relative order,
 * in the general style of Java's compareTo method.
 * First the values t1 and t2 are compared.
 * If t1 and t2 are equal, ties are broken by comparing t3 and t4.
 * If t3 and t4 are equal, ties are broken by comparing t5 and t6.
 * -1 if the first value is less than the second,
 *  0 if the values are equal,
 *  1 if the first value is greater than the second.
 * The types passed must support a < less-than operator.
 */
template <typename T1, typename T2, typename T3>
int compareTo3(T1 t1, T1 t2, T2 t3, T2 t4, T3 t5, T3 t6) {
    if (t5 < t6) {
        return -1;
    } else if (t6 < t5) {
        return 1;
    } else {
        return compareTo2(t1, t2, t3, t4);
    }
}

/*
 * Compares four pairs of values and returns an integer indicating their relative order,
 * in the general style of Java's compareTo method.
 * First the values t1 and t2 are compared.
 * If t1 and t2 are equal, ties are broken by comparing t3 and t4.
 * If t3 and t4 are equal, ties are broken by comparing t5 and t6.
 * If t5 and t6 are equal, ties are broken by comparing t7 and t8.
 * -1 if the first value is less than the second,
 *  0 if the values are equal,
 *  1 if the first value is greater than the second.
 * The types passed must support a < less-than operator.
 */
template <typename T1, typename T2, typename T3, typename T4>
int compareTo4(T1 t1, T1 t2, T2 t3, T2 t4, T3 t5, T3 t6, T4 t7, T4 t8) {
    if (t7 < t8) {
        return -1;
    } else if (t8 < t7) {
        return 1;
    } else {
        return compareTo3(t1, t2, t3, t4, t5, t6);
    }
}

/*
 * Compares five pairs of values and returns an integer indicating their relative order,
 * in the general style of Java's compareTo method.
 * First the values t1 and t2 are compared.
 * If t1 and t2 are equal, ties are broken by comparing t3 and t4.
 * If t3 and t4 are equal, ties are broken by comparing t5 and t6.
 * If t5 and t6 are equal, ties are broken by comparing t7 and t8.
 * If t7 and t8 are equal, ties are broken by comparing t9 and t10.
 * -1 if the first value is less than the second,
 *  0 if the values are equal,
 *  1 if the first value is greater than the second.
 * The types passed must support a < less-than operator.
 */
template <typename T1, typename T2, typename T3, typename T4, typename T5>
int compareTo5(T1 t1, T1 t2, T2 t3, T2 t4, T3 t5, T3 t6, T4 t7, T4 t8, T5 t9, T5 t10) {
    if (t9 < t10) {
        return -1;
    } else if (t10 < t9) {
        return 1;
    } else {
        return compareTo4(t1, t2, t3, t4, t5, t6, t7, t8);
    }
}

/*
 * Returns true if the two collections contain the same elements in the same order.
 * The element type must have an operator ==.
 */
template <typename CollectionType>
bool equals(const CollectionType& coll1, const CollectionType& coll2) {
    // optimization: if literally same collection, stop
    if (&coll1 == &coll2) {
        return true;
    }
    // optimization: if not same size, don't bother comparing pairwise
    if (coll1.size() != coll2.size()) {
        return false;
    }

    // check each pair of elements for equality
    auto itr1 = coll1.begin();
    auto end1 = coll1.end();
    auto itr2 = coll2.begin();
    auto end2 = coll1.end();
    while (itr1 != end1 && itr2 != end2) {
        if (!(*itr1 == *itr2)) {
            return false;
        }
        ++itr1;
        ++itr2;
    }
    return true;
}

/*
 * Returns true if the two collections contain the same elements in the same order.
 * The element type must be double, float, or any floating-point type.
 */
template <typename CollectionType>
bool equalsDouble(const CollectionType& coll1, const CollectionType& coll2) {
    // optimization: if literally same collection, stop
    if (&coll1 == &coll2) {
        return true;
    }
    // optimization: if not same size, don't bother comparing pairwise
    if (coll1.size() != coll2.size()) {
        return false;
    }

    // check each pair of elements for equality
    auto itr1 = coll1.begin();
    auto end1 = coll1.end();
    auto itr2 = coll2.begin();
    auto end2 = coll1.end();
    while (itr1 != end1 && itr2 != end2) {
        if (!floatingPointEqual(*itr1, *itr2)) {
            return false;
        }
        ++itr1;
        ++itr2;
    }
    return true;
}

/*
 * Returns true if the given two maps contain the same set of keys and each
 * key maps to the same value in both maps.
 * The order of the keys is not considered.
 * The key and value types must both have an operator ==.
 */
template <typename MapType>
bool equalsMap(const MapType& map1, const MapType& map2) {
    // optimization: if literally same map, stop
    if (&map1 == &map2) {
        return true;
    }
    // optimization: if not same size, don't bother comparing pairwise
    if (map1.size() != map2.size()) {
        return false;
    }

    // check each pair of key/value pairs for equality;
    // compare both ways; each must be subset of the other
    for (auto itr1 = map1.begin(), end1 = map1.end(); itr1 != end1; ++itr1) {
        if (!map2.containsKey(*itr1) || !(map1.get(*itr1) == map2.get(*itr1))) {
            return false;
        }
    }
    for (auto itr2 = map2.begin(), end2 = map2.end(); itr2 != end2; ++itr2) {
        if (!map1.containsKey(*itr2) || !(map1.get(*itr2) == map2.get(*itr2))) {
            return false;
        }
    }
    return true;
}

/*
 * Computes a hashCode for any iterable type.
 * Pass true for 'orderMatters' for collections that maintain some kind of element
 * ordering that is of importance.  This would be true for almost all collections
 * except hash-based ones where the ordering is semi-random and unimportant.
 */
template <typename IteratorType>
int hashCodeIterable(IteratorType begin, IteratorType end, bool orderMatters = true) {
    int code = hashSeed();
    while (begin != end) {
        if (orderMatters) {
            code *= hashMultiplier();
        }
        code += hashCode(*begin);
        ++begin;
    }
    return int(code & hashMask());
}

/*
 * Computes a hashCode for any type of collection.
 * The collection must have begin() and end()
 */
template <typename CollectionType>
int hashCodeCollection(const CollectionType& collection, bool orderMatters = true) {
    return hashCodeIterable(collection.begin(), collection.end(), orderMatters);
}

/*
 * Template hash function for hash maps.
 * Requires the key and value types in the HashMap to have a hashCode function.
 */
template <typename MapType>
int hashCodeMap(const MapType& map, bool orderMatters = true) {
    int code = hashSeed();
    auto begin = map.begin();
    auto end = map.end();
    while (begin != end) {
        if (orderMatters) {
            code *= hashMultiplier();
        }
        code += hashCode(*begin);

        if (orderMatters) {
            code *= hashMultiplier();
        }
        code += hashCode(map[*begin]);
        ++begin;
    }
    return int(code & hashMask());
}

/*
 * Returns a randomly chosen element of the given collection.
 * Throws an error if the set is empty.
 */
template <template <typename> class CollectionType, class ElementType>
const ElementType& randomElement(const CollectionType<ElementType>& collection) {
    if (collection.isEmpty()) {
        error("randomElement: empty collection was passed");
    }
    int index = randomInteger(0, collection.size() - 1);
    auto itr = collection.begin();
    for (int i = 0; i < index; i++) {
        ++itr;
    }
    return *itr;
}

/*
 * Returns a randomly chosen element of the given collection.
 * The collection must have an index [] operator.
 * Throws an error if the set is empty.
 */
template <template <typename> class CollectionType, class ElementType>
const ElementType& randomElementIndexed(const CollectionType<ElementType>& collection) {
    if (collection.isEmpty()) {
        error("randomElement: empty collection was passed");
    }
    int index = randomInteger(0, collection.size() - 1);
    return collection[index];
}

/*
 * Reads in any collection from the given input stream.
 * The collection must have an add() method that takes a single value,
 * and a clear() method that removes all elements from the collection.
 */
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
template <typename CollectionType, typename ElementType>
std::istream& readCollection(std::istream& input, CollectionType& collection, ElementType& element, std::string descriptor = "readIterable") {
#else
template <typename CollectionType, typename ElementType>
std::istream& readCollection(std::istream& input, CollectionType& collection, ElementType& element, std::string /* descriptor */) {
#endif
    char ch = '\0';
    input >> ch;
    if (ch != '{') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error(descriptor + ": Missing {");
#endif
        input.setstate(std::ios_base::failbit);
        return input;
    }
    collection.clear();
    input >> ch;
    if (ch != '}') {
        input.unget();
        while (true) {
            if (!readGenericValue(input, element)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(descriptor + ": parse error");
#endif
                return input;
            }
            collection.add(element);
            input >> ch;
            if (ch == '}') {
                break;
            }
            if (ch != ',') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(std::string(descriptor + ": Unexpected character ") + ch);
#endif
                input.setstate(std::ios_base::failbit);
                return input;
            }
        }
    }
    return input;
}

/*
 * Reads in any Map collection from the given input stream.
 * The collection must have an add() method that takes a single value,
 * and a clear() method that removes all elements from the collection.
 */
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
template <typename MapType, typename KeyType, typename ValueType>
std::istream& readMap(std::istream& input, MapType& map, KeyType& key, ValueType& value, std::string descriptor = "readIterable") {
#else
template <typename MapType, typename KeyType, typename ValueType>
std::istream& readMap(std::istream& input, MapType& map, KeyType& key, ValueType& value, std::string /* descriptor */) {
#endif
    char ch = '\0';
    input >> ch;
    if (ch != '{') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error(descriptor + ": Missing {");
#endif
        input.setstate(std::ios_base::failbit);
        return input;
    }
    map.clear();
    input >> ch;
    if (ch != '}') {
        input.unget();
        while (true) {
            if (!readGenericValue(input, key)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(descriptor + ": parse key error");
#endif
                return input;
            }
            input >> ch;
            if (ch != ':') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(descriptor + ": Missing colon after key");
#endif
                input.setstate(std::ios_base::failbit);
                return input;
            }
            if (!readGenericValue(input, value)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(descriptor + ": parse value error");
#endif
                return input;
            }
            map.put(key, value);
            input >> ch;
            if (ch == '}') {
                break;
            }
            if (ch != ',') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(std::string(descriptor + ": Unexpected character ") + ch);
#endif
                input.setstate(std::ios_base::failbit);
                return input;
            }
        }
    }
    return input;
}

/*
 * Writes out any collection to the given output stream using its two iterators,
 * begin and end.
 */
template <typename IteratorType>
std::ostream& writeIterable(std::ostream& out, IteratorType begin, IteratorType end) {
    out << "{";
    bool first = true;
    while (begin != end) {
        if (!first) {
            out << ", ";
        }
        first = false;
        writeGenericValue(out, *begin, /* forceQuotes */ true);
        ++begin;
    }
    out << "}";
    return out;
}

/*
 * Writes out any collection to the given output stream using its two iterators,
 * begin and end.
 */
template <typename CollectionType>
std::ostream& writeCollection(std::ostream& out, CollectionType collection) {
    return writeIterable(out, collection.begin(), collection.end());
}

/*
 * Writes out any collection to the given output stream using its two iterators,
 * begin and end.
 */
template <typename IteratorType>
std::ostream& writeIterableOfPointers(std::ostream& out, IteratorType begin, IteratorType end) {
    out << "{";
    bool first = true;
    while (begin != end) {
        if (!first) {
            out << ", ";
        }
        first = false;
        writeGenericValue(out, **begin, /* forceQuotes */ true);
        ++begin;
    }
    out << "}";
    return out;
}

/*
 * Writes out any collection to the given output stream using its two iterators,
 * begin and end.
 */
template <typename CollectionType>
std::ostream& writeCollectionOfPointers(std::ostream& out, CollectionType collection) {
    return writeIterableOfPointers(out, collection.begin(), collection.end());
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename MapType>
std::ostream& writeMap(std::ostream& out, const MapType& map) {
    out << "{";
    auto begin = map.begin();
    auto end = map.end();
    bool first = true;
    while (begin != end) {
        if (!first) {
            out << ", ";
        }
        first = false;
        writeGenericValue(out, *begin, /* forceQuotes */ true);
        out << ":";
        writeGenericValue(out, map[*begin], /* forceQuotes */ true);
        ++begin;
    }
    out << "}";
    return out;
}

} // namespace collections
} // namespace stanfordcpplib

#endif // _collections_h

/////////////////////// END code extracted from StanfordCPPLib/collections/collections.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/observable.h ///////////////////////
/*
 * File: observable.h
 * ------------------
 * This file defines an abstract superclass named <code>Observable</code> that
 * allows objects to store lists of observers, which are other objects that are
 * notified when some part of the state of the observable object changes.
 * This is an example of the classic Observer/Observable design pattern.
 *
 * @author Marty Stepp
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2017/10/25
 * - added addObserver/removeObserver overloads that accept reference param
 * @version 2016/11/20
 * - refactored to use template for event type
 * @version 2014/10/08
 * - removed 'using namespace' statement
 * - fixed bug in error string on removeObserver (said 'addObserver')
 * @version 2014/03/09
 * - initial version
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _observable_h
#define _observable_h

#include <set>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

// forward declarations
template <class T>
class Observer;

/**
 * This abstract superclass allows objects to store lists of observers,
 * which are other objects that would like to be notified when some part of the
 * state of the observable object changes.
 *
 * The intended usage is that you should extend Observable in the object you
 * want to be watched, then call notifyObservers in its code at appropriate
 * places.  Then create some other object that extends Observer and defines an
 * update method, and attach it to the Observable so it will be notified.
 */
template <typename T>
class Observable {
public:
    /**
     * Adds the given observer object to this observable object's internal list
     * of observers.  The observer's update method will be called when the
     * notifyObservers method is called afterward.
     * Precondition: obs != nullptr
     */
    void addObserver(Observer<T>* obs);

    /**
     * Adds the given observer object to this observable object's internal list
     * of observers.  The observer's update method will be called when the
     * notifyObservers method is called afterward.
     */
    void addObserver(Observer<T>& obs);

    /**
     * Calls the update method of all observers that have been added previously
     * to this observable object.
     * The given argument can be passed to provide extra information to the
     * observers if necessary.  If no argument is passed, nullptr is used.
     */
    void notifyObservers(T arg = T());

    /**
     * Removes the given observer object from this observable object's internal
     * list of observers.  The observer will no longer be notified.
     */
    void removeObserver(Observer<T>* obs);

    /**
     * Removes the given observer object from this observable object's internal
     * list of observers.  The observer will no longer be notified.
     */
    void removeObserver(Observer<T>& obs);

private:
    // a list of observers to notify when notifyObservers is called
    std::set<Observer<T>*> m_observers;
};

/**
 * An object that wishes to be notified when the state of an observable object
 * changes.
 */
template <typename T>
class Observer {
public:
    /**
     * Called by an Observable to inform this observer that its state changed.
     * The 'obs' parameter will be a pointer to the observable object itself
     * on which the state change occurred.  The 'arg' parameter will be
     * the extra information passed by the Observable when it called
     * notifyObservers, if any.
     */
    virtual void update(Observable<T>* obs, const T& arg = T()) = 0;
};

template <typename T>
void Observable<T>::addObserver(Observer<T>* obs) {
    if (!obs) {
        error("Observable::addObserver: null observer passed");
    }
    m_observers.insert(obs);
}

template <typename T>
void Observable<T>::addObserver(Observer<T>& obs) {
    addObserver(&obs);
}

template <typename T>
void Observable<T>::notifyObservers(T arg) {
    for (Observer<T>* obs : m_observers) {
        obs->update(this, arg);
    }
}

template <typename T>
void Observable<T>::removeObserver(Observer<T>* obs) {
    if (!obs) {
        error("Observable::removeObserver: null observer passed");
    }
    m_observers.erase(obs);
}

template <typename T>
void Observable<T>::removeObserver(Observer<T>& obs) {
    removeObserver(&obs);
}

#endif // _observable_h

/////////////////////// END code extracted from StanfordCPPLib/util/observable.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/recursion.h ///////////////////////
/*
 * File: recursion.h
 * -----------------
 * This file includes a few utility functions related to recursion.
 * You can use them to print a debug message that is indented relative
 * to the level of recursion you are currently nested in.
 *
 * @author Marty Stepp
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2016/10/30
 * - initial version (extracted from exceptions.h)
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _recursion_h
#define _recursion_h

#include <string>

/**
 * Returns number of calls deep we are in the current recursive function.
 * For example, if f() calls f() calls f(), this function returns 3.
 *
 * NOTE: Doesn't usually work when used with 'static' functions, because their names
 * are not exported or revealed to the internal stack trace grabber.
 * So if you want to use this function, make your function non-static.
 */
int getRecursionIndentLevel();

/**
 * Returns a string of indentation that can be used to pretty-print recursive calls
 * at their corresponding level of nesting.
 * Indents by 4 spaces per level but can be overridden by passing 'indenter' param.
 *
 * NOTE: Doesn't usually work when used with static functions, because their names
 * are not exported or revealed to the internal stack trace grabber.
 * So if you want to use this function, make your function non-static.
 */
std::string recursionIndent(const std::string& indenter = "    ");

#endif // _recursion_h

/////////////////////// END code extracted from StanfordCPPLib/util/recursion.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/system/exceptions.h ///////////////////////
/*
 * File: exceptions.h
 * ------------------
 * This file contains a top-level exception handler to print exceptions thrown
 * by student code on the console.
 * It also contains some wizardry to try to retrieve a stack trace when the
 * exception is thrown, though it is hard to consistently do this on all platforms.
 * 
 * @author Marty Stepp
 * @version 2018/09/25
 * - add 'force' parameter to setTopLevelExceptionHandlerEnabled
 *   (helps it to work better with threads)
 * - added doc comments for new documentation generation
 * @version 2016/11/07
 * - added cleanupFunctionNameForStackTrace
 * @version 2016/10/30
 * - moved recursion functions to recursion.h/cpp
 * @version 2014/11/12
 * - made printStackTrace function publicly available
 * - added top-level signal handler (for null-pointer derefs etc.)
 * @since 2014/11/05
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _exceptions_h
#define _exceptions_h

#include <iostream>

namespace exceptions {
/**
 * Strips some extraneous text from a function's name/header to make it look
 * better when printed in a stack trace.
 * e.g. basic_string -> string, removes std::, removes some weird compiler gibberish.
 */
std::string cleanupFunctionNameForStackTrace(std::string function);

/**
 * Called by C++ lib's main wrapper so that the stack trace knows the program's name.
 * (Taken from argv[0].)
 */
std::string& getProgramNameForStackTrace();

/**
 * Returns whether the top-level exception handler is enabled.
 * Initially false.
 */
bool getTopLevelExceptionHandlerEnabled();

/**
 * Prints a stack trace to the system standard error console (cerr).
 * (Stack traces are highly OS- and compiler-dependent, so this function
 *  may not work perfectly on all platforms.  It has been tested to work
 *  on Linux with GCC/G++, Mac OS X with clang++, and Windows with MinGW.)
 */
void printStackTrace();

/**
 * Prints a stack trace to the given output stream.
 * Defaults to the system standard error console (cerr).
 * (Stack traces are highly OS- and compiler-dependent, so this function
 *  may not work perfectly on all platforms.  It has been tested to work
 *  on Linux with GCC/G++, Mac OS X with clang++, and Windows with MinGW.)
 */
void printStackTrace(std::ostream& out);

/**
 * Called by C++ lib's main wrapper so that the stack trace knows the program's name.
 * (Taken from argv[0].)
 */
void setProgramNameForStackTrace(char* programName);

/**
 * Sets whether the top-level exception handler is enabled.
 * If the optional 'force' parameter is passed, will set the handler again
 * even if it was set before.
 */
void setTopLevelExceptionHandlerEnabled(bool enabled, bool force = false);

/**
 * Whether the given function should be filtered out when displaying a stack trace.
 * Not meant to be called by clients.
 */
bool shouldFilterOutFromStackTrace(const std::string& function);
}

#endif // _exceptions_h

/////////////////////// END code extracted from StanfordCPPLib/system/exceptions.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/vector.h ///////////////////////
/*
 * File: vector.h
 * --------------
 * This file exports the <code>Vector</code> class, which provides an
 * efficient, safe, convenient replacement for the array type in C++.
 *
 * @version 2018/09/06
 * - refreshed doc comments for new documentation generation
 * @version 2018/01/07
 * - added front, back, removeFront, removeBack, pop_front, pop_back, push_front
 * @version 2017/11/15
 * - added contains, indexOf, lastIndexOf, removeValue, reverse, shuffle, sort
 * @version 2017/10/18
 * - fix compiler warnings
 * @version 2016/12/09
 * - added iterator version checking support
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/12
 * - bug fix for constructor based on initializer list
 * @version 2016/08/10
 * - added support for std initializer_list usage, such as {1, 2, 3}
 *   in constructor, addAll, +, +=
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/10/13
 * - nulled out pointer fields in destructor after deletion to avoid double-free
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added template hashCode function
 * @version 2014/10/19
 * - added subList method
 * @version 2014/10/10
 * - removed usage of __foreach macro
 * 2014/07/09
 * - changed checkVectorIndex range checking function into a private member
 *   function to avoid unused-function errors on some newer compilers
 * 2014/04/27
 * - fixed bug in addAll method that was not returning reference properly.
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _vector_h
#define _vector_h

#include <algorithm>
#include <initializer_list>
#include <iostream>
#include <iterator>
#include <sstream>
#include <string>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * This class stores an ordered list of values similar to an array.
 * It supports traditional array selection using square brackets, but
 * also supports inserting and deleting elements.  It is similar in
 * function to the STL <code>vector</code> type, but is simpler both
 * to use and to implement.
 */
template <typename ValueType>
class Vector {
public:
    /**
     * Initializes a new empty vector.
     * @bigoh O(1)
     */
    Vector();

    /**
     * Initializes a new vector, creating an array with <code>n</code>
     * elements, each of which is initialized to <code>value</code>.
     * If <code>value</code> is missing, the elements are initialized
     * to the default value for the type.
     * @bigoh O(N)
     */
    explicit Vector(int n, ValueType value = ValueType());

    /**
     * Uses an initializer list to set up the vector.
     * @bigoh O(N)
     */
    Vector(std::initializer_list<ValueType> list);

    /**
     * Frees any heap storage allocated by this vector.
     * @bigoh O(1)
     */
    virtual ~Vector();

    /**
     * Adds a new value to the end of this vector.
     * @bigoh O(1)
     */
    void add(const ValueType& value);

    /**
     * Adds all elements of the given other vector to this vector.
     * Returns a reference to this vector.
     * Identical in behavior to the += operator.
     * @bigoh O(N)
     */
    Vector<ValueType>& addAll(const Vector<ValueType>& v);

    /**
     * Adds all elements of the given initializer list to this vector.
     * Returns a reference to this vector.
     * Identical in behavior to the += operator.
     * @bigoh O(N)
     */
    Vector<ValueType>& addAll(std::initializer_list<ValueType> list);

    /**
     * Returns the element at index (size - 1) in this vector (without removing it).
     * @throw ErrorException if vector is empty
     * @bigoh O(1)
     */
    ValueType& back();

    /**
     * Returns the element at index (size - 1) in this vector (without removing it).
     * @throw ErrorException if vector is empty
     * @bigoh O(1)
     */
    const ValueType& back() const;

    /**
     * Removes all elements from this vector.
     * @bigoh O(1)
     */
    void clear();

    /**
     * Returns true if the vector contains the given value.
     * The ValueType must have an == operator to use this method.
     * @bigoh O(N)
     */
    bool contains(const ValueType& value) const;

    /**
     * Guarantees that the vector's internal array is at least the given length.
     * If necessary, resizes the array to be the given length or larger.
     * @bigoh O(N)
     */
    void ensureCapacity(int cap);

    /**
     * Compares two vectors for equality.
     * Returns <code>true</code> if this vector contains exactly the same
     * values as the given other vector.
     * Identical in behavior to the == operator.
     * @bigoh O(N)
     */
    bool equals(const Vector<ValueType>& v) const;

    /**
     * Returns the element at index 0 in this vector (without removing it).
     * @throw ErrorExceptoin if vector is empty
     * @bigoh O(1)
     */
    ValueType& front();

    /**
     * Returns the element at index 0 in this vector (without removing it).
     * @throw ErrorExceptoin if vector is empty
     * @bigoh O(1)
     */
    const ValueType& front() const;

    /**
     * Returns the element at the specified index in this vector.
     * Similar in behavior to the [] operator.
     * @throw ErrorException if the index is not in the array range
     * @bigoh O(1)
     */
    const ValueType& get(int index) const;

    /**
     * Returns the index of the first occurrence of the given value.
     * If the value is not found in the vector, returns -1.
     * The ValueType must have an == operator to use this method.
     * @bigoh O(N)
     */
    int indexOf(const ValueType& value) const;

    /**
     * Inserts the element into this vector before the specified index.
     * All subsequent elements are shifted one position to the right.
     * @throw ErrorException if the index is not in the array range from 0
     * up to and including the length of the vector.
     * @bigoh O(N)
     */
    void insert(int index, const ValueType& value);

    /**
     * Returns <code>true</code> if this vector contains no elements.
     * @bigoh O(1)
     */
    bool isEmpty() const;

    /**
     * Returns the index of the last occurrence of the given value.
     * If the value is not found in the vector, returns -1.
     * The ValueType must have an == operator to use this method.
     * @bigoh O(N)
     */
    int lastIndexOf(const ValueType& value) const;

    /**
     * Calls the specified function on each element of the vector in
     * ascending index order.
     * @bigoh O(N)
     */
    void mapAll(void (*fn)(ValueType)) const;

    /**
     * Calls the specified function on each element of the vector in
     * ascending index order.
     * @bigoh O(N)
     */
    void mapAll(void (*fn)(const ValueType&)) const;

    /**
     * Calls the specified function on each element of the vector in
     * ascending index order.
     * @bigoh O(N)
     */
    template <typename FunctorType>
    void mapAll(FunctorType fn) const;

    /**
     * Removes and returns the first value of this vector.
     * Equivalent to removeFront.
     * @throw ErrorException if the vector is empty
     * @bigoh O(N)
     */
    ValueType pop_front();

    /**
     * Removes and returns the last value of this vector.
     * Equivalent to removeBack.
     * @throw ErrorException if the vector is empty
     * @bigoh O(1)
     */
    ValueType pop_back();

    /**
     * Adds a new value to the end of this vector.
     * This method is a synonym of the add method that is provided to
     * ensure compatibility with the STL <code>vector</code> class.
     * @bigoh O(1)
     */
    void push_back(const ValueType& value);

    /**
     * Adds a new value to the start of this vector.
     * This method is equivalent to calling insert(0, value) and is provided to
     * improve compatibility with the STL <code>vector</code> class.
     * @bigoh O(N)
     */
    void push_front(const ValueType& value);

    /**
     * Removes the element at the specified index from this vector.
     * All subsequent elements are shifted one position to the left.
     * @throw ErrorException if the index is not in the array range
     * @bigoh O(N)
     */
    void remove(int index);

    /**
     * Removes and returns the element at index 0 in this vector.
     * @throw ErrorException if the vector is empty
     * @bigoh O(N)
     */
    ValueType removeFront();

    /**
     * Removes and returns the element at index (size - 1) in this vector.
     * @throw ErrorException if the vector is empty
     * @bigoh O(1)
     */
    ValueType removeBack();

    /**
     * Removes the first occurrence of the element value from this vector.
     * All subsequent elements are shifted one position to the left.
     * If the vector does not contain the given value, has no effect.
     * The ValueType must have an == operator to use this method.
     * @bigoh O(N)
     */
    void removeValue(const ValueType& value);

    /**
     * Reverses the order of the elements in this vector.
     * For example, if vector stores {1, 3, 4, 9}, changes it to store {9, 4, 3, 1}.
     * @bigoh O(N)
     */
    void reverse();

    /**
     * Replaces the element at the specified index in this vector with
     * a new value.  The previous value at that index is overwritten.
     * Similar in behavior to the [] operator.
     * @throw ErrorException if the index is not in the array range
     * @bigoh O(1)
     */
    void set(int index, const ValueType& value);
    
    /**
     * Returns the number of elements in this vector.
     * @bigoh O(1)
     */
    int size() const;

    /**
     * Rearranges the order of the elements in this vector into a random order.
     * @bigoh O(N)
     */
    void shuffle();

    /**
     * Rearranges the order of the elements in this vector into sorted order.
     * For example, if vector stores {9, 1, 4, 3}, changes it to store {1, 3, 4, 9}.
     * The ValueType must have an operator < to call this method.
     * @bigoh O(N log N)
     */
    void sort();

    /**
     * Returns a new vector containing the given subset range of elements
     * from this vector. The new vector is a deep copy, not linked to this one.
     * @throw ErrorException if the range (start .. start + length) is not
     *        within the bounds of this vector, or if length is negative
     * @bigoh O(N)
     */
    Vector<ValueType> subList(int start, int length) const;

    /**
     * Converts the vector to a printable string representation
     * such as "{10, 20, 30, 40}".
     * @bigoh O(N)
     */
    std::string toString() const;

    /**
     * Overloads <code>[]</code> to select elements from this vector.
     * This extension enables the use of traditional array notation to
     * get or set individual elements.
     * @throw ErrorException if the index is not in the array range
     * @bigoh O(1)
     */
    ValueType& operator [](int index);

    /**
     * Overloads <code>[]</code> to select elements from this vector.
     * This extension enables the use of traditional array notation to
     * get or set individual elements.
     * @throw ErrorException if the index is not in the array range
     * @bigoh O(1)
     */
    const ValueType& operator [](int index) const;

    /**
     * Concatenates two vectors and returns the result.
     * @bigoh O(N)
     */
    Vector operator +(const Vector& v2) const;

    /**
     * Concatenates this vector with an initializer list such as {1, 2, 3},
     * returning the result.
     * @bigoh O(N)
     */
    Vector operator +(std::initializer_list<ValueType> list) const;

    /**
     * Adds all of the elements from <code>v2</code> to the end of this vector.
     * @bigoh O(N)
     */
    Vector& operator +=(const Vector& v2);

    /**
     * Adds all of the elements from the given initializer list to the end of
     * the vector.
     * @bigoh O(N)
     */
    Vector& operator +=(std::initializer_list<ValueType> list);

    /**
     * Adds the single specified value) to the end of the vector.
     * @bigoh O(1)
     */
    Vector& operator +=(const ValueType& value);


    /**
     * Compares two vectors for equality.
     * The ValueType must have an == operator.
     * @bigoh O(N)
     */
    bool operator ==(const Vector& v2) const;

    /**
     * Compares two vectors for inequality.
     * The ValueType must have a != operator.
     * @bigoh O(N)
     */
    bool operator !=(const Vector& v2) const;

    /**
     * Relational operators to compare two vectors.
     * Each element is compared pairwise to the corresponding element at the
     * same index in the other vector; for example, we first check the values
     * at index 0, then 1, and so on.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(N)
     */
    bool operator <(const Vector& v2) const;

    /**
     * Relational operators to compare two vectors.
     * Each element is compared pairwise to the corresponding element at the
     * same index in the other vector; for example, we first check the values
     * at index 0, then 1, and so on.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(N)
     */
    bool operator <=(const Vector& v2) const;

    /**
     * Relational operators to compare two vectors.
     * Each element is compared pairwise to the corresponding element at the
     * same index in the other vector; for example, we first check the values
     * at index 0, then 1, and so on.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(N)
     */
    bool operator >(const Vector& v2) const;

    /**
     * Relational operators to compare two vectors.
     * Each element is compared pairwise to the corresponding element at the
     * same index in the other vector; for example, we first check the values
     * at index 0, then 1, and so on.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(N)
     */
    bool operator >=(const Vector& v2) const;

    /*
     * Additional Vector operations
     * ----------------------------
     * In addition to the methods listed in this interface, the Vector
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement or STL iterators
     *
     * The iteration forms process the Vector in index order.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    /*
     * Implementation notes: Vector data structure
     * -------------------------------------------
     * The elements of the Vector are stored in a dynamic array of
     * the specified element type.  If the space in the array is ever
     * exhausted, the implementation doubles the array capacity.
     */

    /* Instance variables */
    ValueType* elements;        // a dynamic array of the elements
    int capacity;               // the allocated size of the array
    int count;                  // the number of elements in use
    unsigned int m_version = 0; // structure version for detecting invalid iterators

    /* Private methods */

    /*
     * Throws an ErrorException if the given index is not within the range of
     * [min..max] inclusive.
     * This is a consolidated error handler for all various Vector members that
     * accept index parameters.
     * The prefix parameter represents a text string to place at the start of
     * the error message, generally to help indicate which member threw the error.
     */
    void checkIndex(int index, int min, int max, std::string prefix) const;

    void expandCapacity();
    void deepCopy(const Vector& src);

    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods
     * in the public interface would make that interface more
     * difficult to understand for the average client.
     */

public:
    /**
     * Makes a deep copy, making it possible to pass or return vectors by value
     * and assign from one vector to another.
     * @bigoh O(N)
     * @private
     */
    Vector(const Vector& src);

    /**
     * Makes a deep copy, making it possible to pass or return vectors by value
     * and assign from one vector to another.
     * @bigoh O(N)
     * @private
     */
    Vector& operator =(const Vector& src);

    /**
     * Adds an element to the vector passed as the left-hand operatand.
     * This form makes it easier to initialize vectors in old versions of C++.
     * @bigoh O(1)
     */
    Vector& operator ,(const ValueType& value);

    /**
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     * @private
     */
    class iterator :
            public std::iterator<std::random_access_iterator_tag, ValueType> {
    private:
        const Vector* vp;
        int index;
        unsigned int itr_version;

    public:
        iterator()
                : vp(nullptr),
                  index(0),
                  itr_version(0) {
            // empty
        }

        iterator(const iterator& it)
                : vp(it.vp),
                  index(it.index),
                  itr_version(it.itr_version) {
            // empty
        }

        iterator(const Vector* theVec, int theIndex)
                : vp(theVec),
                  index(theIndex) {
            itr_version = vp->version();
        }

        iterator& operator ++() {
            stanfordcpplib::collections::checkVersion(*vp, *this);
            index++;
            return *this;
        }

        iterator operator ++(int) {
            stanfordcpplib::collections::checkVersion(*vp, *this);
            iterator copy(*this);
            operator++();
            return copy;
        }

        iterator& operator --() {
            stanfordcpplib::collections::checkVersion(*vp, *this);
            index--;
            return *this;
        }

        iterator operator --(int) {
            stanfordcpplib::collections::checkVersion(*vp, *this);
            iterator copy(*this);
            operator--();
            return copy;
        }

        bool operator ==(const iterator& rhs) {
            return vp == rhs.vp && index == rhs.index;
        }

        bool operator !=(const iterator& rhs) {
            return !(*this == rhs);
        }

        bool operator <(const iterator& rhs) {
            if (vp != rhs.vp) {
                error("Vector Iterator::operator <: Iterators are in different vectors");
            }
            return index < rhs.index;
        }

        bool operator <=(const iterator& rhs) {
            if (vp != rhs.vp) {
                error("Vector Iterator::operator <=: Iterators are in different vectors");
            }
            return index <= rhs.index;
        }

        bool operator >(const iterator& rhs) {
            if (vp != rhs.vp) {
                error("Vector Iterator::operator >: Iterators are in different vectors");
            }
            return index > rhs.index;
        }

        bool operator >=(const iterator& rhs) {
            if (vp != rhs.vp) {
                error("Vector Iterator::operator >=: Iterators are in different vectors");
            }
            return index >= rhs.index;
        }

        iterator operator +(const int& rhs) {
            stanfordcpplib::collections::checkVersion(*vp, *this);
            return iterator(vp, index + rhs);
        }

        iterator operator +=(const int& rhs) {
            stanfordcpplib::collections::checkVersion(*vp, *this);
            index += rhs;
            return *this;
        }

        iterator operator -(const int& rhs) {
            stanfordcpplib::collections::checkVersion(*vp, *this);
            return iterator(vp, index - rhs);
        }

        iterator operator -=(const int& rhs) {
            stanfordcpplib::collections::checkVersion(*vp, *this);
            index -= rhs;
            return *this;
        }

        int operator -(const iterator& rhs) {
            stanfordcpplib::collections::checkVersion(*vp, *this);
            extern void error(const std::string& msg);
            if (vp != rhs.vp) {
                error("Vector Iterator::operator -: Iterators are in different vectors");
            }
            return index - rhs.index;
        }

        ValueType& operator *() {
            stanfordcpplib::collections::checkVersion(*vp, *this);
            return vp->elements[index];
        }

        ValueType* operator ->() {
            stanfordcpplib::collections::checkVersion(*vp, *this);
            return &vp->elements[index];
        }

        ValueType& operator [](int k) {
            stanfordcpplib::collections::checkVersion(*vp, *this);
            return vp->elements[index + k];
        }

        unsigned int version() const {
            return itr_version;
        }
    };

    /**
     * Returns an iterator pointed at the beginning of this vector.
     * @bigoh O(1)
     */
    iterator begin() const {
        return iterator(this, 0);
    }

    /**
     * Returns an iterator pointed just past the end of this vector.
     * @bigoh O(1)
     */
    iterator end() const {
        return iterator(this, count);
    }

    /**
     * Returns the internal version of this collection.
     * This is used to check for invalid iterators and issue error messages.
     * @bigoh O(1)
     */
    unsigned int version() const;
};

/* Implementation section */

/*
 * Implementation notes: Vector constructor and destructor
 * -------------------------------------------------------
 * The constructor allocates storage for the dynamic array
 * and initializes the other fields of the object.  The
 * destructor frees the memory used for the array.
 */
template <typename ValueType>
Vector<ValueType>::Vector()
        : elements(nullptr),
          capacity(0),
          count(0) {
    // empty
}

template <typename ValueType>
Vector<ValueType>::Vector(int n, ValueType value)
        : elements(nullptr),
          capacity(n),
          count(n) {
    if (n < 0) {
        error("Vector::constructor: n cannot be negative");
    } else if (n > 0) {
        elements = new ValueType[n];
        for (int i = 0; i < n; i++) {
            elements[i] = value;
        }
    }
}

template <typename ValueType>
Vector<ValueType>::Vector(std::initializer_list<ValueType> list)
        : count(0) {
    capacity = list.size();
    elements = new ValueType[capacity];
    addAll(list);
}

/*
 * Implementation notes: copy constructor and assignment operator
 * --------------------------------------------------------------
 * The constructor and assignment operators follow a standard paradigm,
 * as described in the associated textbook.
 */
template <typename ValueType>
Vector<ValueType>::Vector(const Vector& src) {
    deepCopy(src);
}

template <typename ValueType>
Vector<ValueType>::~Vector() {
    if (elements) {
        delete[] elements;
        elements = nullptr;
    }
}

/*
 * Implementation notes: Vector methods
 * ------------------------------------
 * The basic Vector methods are straightforward and should require
 * no detailed documentation.
 */
template <typename ValueType>
void Vector<ValueType>::add(const ValueType& value) {
    insert(count, value);
}

template <typename ValueType>
Vector<ValueType>& Vector<ValueType>::addAll(const Vector<ValueType>& v) {
    for (const ValueType& value : v) {
        add(value);
    }
    return *this;   // BUGFIX 2014/04/27
}

template <typename ValueType>
Vector<ValueType>& Vector<ValueType>::addAll(std::initializer_list<ValueType> list) {
    for (const ValueType& value : list) {
        add(value);
    }
    return *this;
}

template <typename ValueType>
ValueType& Vector<ValueType>::back() {
    if (isEmpty()) {
        error("Vector::back: vector is empty");
    }
    return elements[count - 1];
}

template <typename ValueType>
const ValueType& Vector<ValueType>::back() const {
    if (isEmpty()) {
        error("Vector::back: vector is empty");
    }
    return elements[count - 1];
}

template <typename ValueType>
void Vector<ValueType>::clear() {
    if (elements) {
        delete[] elements;
    }
    count = 0;
    capacity = 0;
    elements = nullptr;
    m_version++;
}

template <typename ValueType>
bool Vector<ValueType>::contains(const ValueType& value) const {
    return indexOf(value) >= 0;
}

// implementation note: This method is public so clients can guarantee a given
// capacity.  Internal resizing is automatically done by expandCapacity.
// See also: expandCapacity
template <typename ValueType>
void Vector<ValueType>::ensureCapacity(int cap) {
    if (cap >= 1 && capacity < cap) {
        capacity = std::max(cap, capacity * 2);
        ValueType* array = new ValueType[capacity];
        if (elements) {
            for (int i = 0; i < count; i++) {
                array[i] = elements[i];
            }
            delete[] elements;
        }
        elements = array;
    }
}

template <typename ValueType>
bool Vector<ValueType>::equals(const Vector<ValueType>& v) const {
    return stanfordcpplib::collections::equals(*this, v);
}

/*
 * Implementation notes: expandCapacity
 * ------------------------------------
 * This function doubles the array capacity, copies the old elements
 * into the new array, and then frees the old one.
 * See also: ensureCapacity
 */
template <typename ValueType>
void Vector<ValueType>::expandCapacity() {
    capacity = std::max(1, capacity * 2);
    ValueType* array = new ValueType[capacity];
    if (elements) {
        for (int i = 0; i < count; i++) {
            array[i] = elements[i];
        }
        delete[] elements;
    }
    elements = array;
}

template <typename ValueType>
ValueType& Vector<ValueType>::front() {
    if (isEmpty()) {
        error("Vector::front: vector is empty");
    }
    return elements[0];
}

template <typename ValueType>
const ValueType& Vector<ValueType>::front() const {
    if (isEmpty()) {
        error("Vector::front: vector is empty");
    }
    return elements[0];
}

template <typename ValueType>
const ValueType& Vector<ValueType>::get(int index) const {
    checkIndex(index, 0, count-1, "get");
    return elements[index];
}

template <typename ValueType>
int Vector<ValueType>::indexOf(const ValueType& value) const {
    for (int i = 0; i < count; i++) {
        if (elements[i] == value) {
            return i;
        }
    }
    return -1;
}

/*
 * Implementation notes: insert, remove, add
 * -----------------------------------------
 * These methods must shift the existing elements in the array to
 * make room for a new element or to close up the space left by a
 * deleted one.
 */
template <typename ValueType>
void Vector<ValueType>::insert(int index, const ValueType& value) {
    checkIndex(index, 0, count, "insert");
    if (count == capacity) {
        expandCapacity();
    }
    for (int i = count; i > index; i--) {
        elements[i] = elements[i - 1];
    }
    elements[index] = value;
    count++;
    m_version++;
}

template <typename ValueType>
bool Vector<ValueType>::isEmpty() const {
    return count == 0;
}

template <typename ValueType>
int Vector<ValueType>::lastIndexOf(const ValueType& value) const {
    for (int i = count - 1; i >= 0; i--) {
        if (elements[i] == value) {
            return i;
        }
    }
    return -1;
}

/*
 * Implementation notes: mapAll
 * ----------------------------
 * The various versions of the mapAll function apply the function or
 * function object to each element in ascending index order.
 */
template <typename ValueType>
void Vector<ValueType>::mapAll(void (*fn)(ValueType)) const {
    for (int i = 0; i < count; i++) {
        fn(elements[i]);
    }
}

template <typename ValueType>
void Vector<ValueType>::mapAll(void (*fn)(const ValueType&)) const {
    for (int i = 0; i < count; i++) {
        fn(elements[i]);
    }
}

template <typename ValueType>
template <typename FunctorType>
void Vector<ValueType>::mapAll(FunctorType fn) const {
    for (int i = 0; i < count; i++) {
        fn(elements[i]);
    }
}

template <typename ValueType>
ValueType Vector<ValueType>::pop_back() {
    if (isEmpty()) {
        error("Vector::pop_back: vector is empty");
    }
    ValueType last = elements[count - 1];
    remove(count - 1);
    return last;
}

template <typename ValueType>
ValueType Vector<ValueType>::pop_front() {
    if (isEmpty()) {
        error("Vector::pop_front: vector is empty");
    }
    ValueType first = elements[0];
    remove(0);
    return first;
}

template <typename ValueType>
void Vector<ValueType>::push_back(const ValueType& value) {
    insert(count, value);
}

template <typename ValueType>
void Vector<ValueType>::push_front(const ValueType& value) {
    insert(0, value);
}

template <typename ValueType>
void Vector<ValueType>::remove(int index) {
    checkIndex(index, 0, count-1, "remove");
    for (int i = index; i < count - 1; i++) {
        elements[i] = elements[i + 1];
    }
    count--;
    m_version++;
}

template <typename ValueType>
ValueType Vector<ValueType>::removeBack() {
    return pop_back();
}

template <typename ValueType>
ValueType Vector<ValueType>::removeFront() {
    return pop_front();
}

template <typename ValueType>
void Vector<ValueType>::removeValue(const ValueType& value) {
    int index = indexOf(value);
    if (index >= 0) {
        remove(index);
    }
}

template <typename ValueType>
void Vector<ValueType>::reverse() {
    for (int i = 0; i < count / 2; i++) {
        std::swap(elements[i], elements[count - 1 - i]);
    }
}

template <typename ValueType>
void Vector<ValueType>::set(int index, const ValueType& value) {
    checkIndex(index, 0, count-1, "set");
    elements[index] = value;
}

template <typename ValueType>
int Vector<ValueType>::size() const {
    return count;
}

template <typename ValueType>
void Vector<ValueType>::shuffle() {
    for (int i = 0; i < count; i++) {
        int j = randomInteger(i, count - 1);
        if (i != j) {
            std::swap(elements[i], elements[j]);
        }
    }
}

template <typename ValueType>
void Vector<ValueType>::sort() {
    std::sort(begin(), end());
}

template <typename ValueType>
Vector<ValueType> Vector<ValueType>::subList(int start, int length) const {
    checkIndex(start, 0, count, "subList");
    checkIndex(start + length, 0, count, "subList");
    if (length < 0) {
        error("Vector::subList: length cannot be negative");
    }
    Vector<ValueType> result;
    for (int i = start; i < start + length; i++) {
        result.add(get(i));
    }
    return result;
}

template <typename ValueType>
std::string Vector<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
unsigned int Vector<ValueType>::version() const {
    return m_version;
}

/*
 * Implementation notes: Vector selection
 * --------------------------------------
 * The following code implements traditional array selection using
 * square brackets for the index.
 */
template <typename ValueType>
ValueType& Vector<ValueType>::operator [](int index) {
    checkIndex(index, 0, count-1, "operator []");
    return elements[index];
}
template <typename ValueType>
const ValueType& Vector<ValueType>::operator [](int index) const {
    checkIndex(index, 0, count-1, "operator []");
    return elements[index];
}

template <typename ValueType>
Vector<ValueType> Vector<ValueType>::operator +(const Vector& v2) const {
    Vector<ValueType> result = *this;
    return result.addAll(v2);
}

template <typename ValueType>
Vector<ValueType> Vector<ValueType>::operator +(std::initializer_list<ValueType> list) const {
    Vector<ValueType> result = *this;
    return result.addAll(list);
}

template <typename ValueType>
Vector<ValueType>& Vector<ValueType>::operator +=(const Vector& v2) {
    return addAll(v2);
}

template <typename ValueType>
Vector<ValueType>& Vector<ValueType>::operator +=(std::initializer_list<ValueType> list) {
    return addAll(list);
}

template <typename ValueType>
Vector<ValueType>& Vector<ValueType>::operator +=(const ValueType& value) {
    add(value);
    return *this;
}

template <typename ValueType>
bool Vector<ValueType>::operator ==(const Vector& v2) const {
    return equals(v2);
}

template <typename ValueType>
bool Vector<ValueType>::operator !=(const Vector& v2) const {
    return !equals(v2);
}

template <typename ValueType>
bool Vector<ValueType>::operator <(const Vector& v2) const {
    return stanfordcpplib::collections::compare(*this, v2) < 0;
}

template <typename ValueType>
bool Vector<ValueType>::operator <=(const Vector& v2) const {
    return stanfordcpplib::collections::compare(*this, v2) <= 0;
}

template <typename ValueType>
bool Vector<ValueType>::operator >(const Vector& v2) const {
    return stanfordcpplib::collections::compare(*this, v2) > 0;
}

template <typename ValueType>
bool Vector<ValueType>::operator >=(const Vector& v2) const {
    return stanfordcpplib::collections::compare(*this, v2) >= 0;
}

template <typename ValueType>
Vector<ValueType> & Vector<ValueType>::operator =(const Vector& src) {
    if (this != &src) {
        if (elements) {
            delete[] elements;
        }
        deepCopy(src);
    }
    return *this;
}

template <typename ValueType>
void Vector<ValueType>::checkIndex(int index, int min, int max, std::string prefix) const {
    if (index < min || index > max) {
        std::ostringstream out;
        out << "Vector::" << prefix << ": index of " << index
            << " is outside of valid range ";
        if (isEmpty()) {
            out << " (empty vector)";
        } else {
            out << "[";
            if (min < max) {
                out << min << ".." << max;
            } else if (min == max) {
                out << min;
            } // else min > max, no range, empty vector
            out << "]";
        }
        error(out.str());
    }
}

// implementation notes:
// doesn't free this->elements because deepCopy is only called in cases where
// elements is either null (at construction) or has just been freed (operator =)
template <typename ValueType>
void Vector<ValueType>::deepCopy(const Vector& src) {
    count = src.count;
    capacity = src.count;
    elements = (capacity == 0) ? nullptr : new ValueType[capacity];
    for (int i = 0; i < count; i++) {
        elements[i] = src.elements[i];
    }
    m_version++;
}

/*
 * Implementation notes: The , operator
 * ------------------------------------
 * The comma operator works adding the right operand to the vector and
 * then returning the vector by reference so that it is set for the next
 * value in the chain.
 */
template <typename ValueType>
Vector<ValueType>& Vector<ValueType>::operator ,(const ValueType& value) {
    add(value);
    return *this;
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const Vector<ValueType>& vec) {
    return stanfordcpplib::collections::writeCollection(os, vec);
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, Vector<ValueType>& vec) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, vec, element, /* descriptor */ "Vector::operator >>");
}

/*
 * Template hash function for vectors.
 * Requires the element type in the Vector to have a hashCode function.
 */
template <typename ValueType>
int hashCode(const Vector<ValueType>& vec) {
    return stanfordcpplib::collections::hashCodeCollection(vec);
}

/*
 * Function: randomElement
 * Usage: element = randomElement(v);
 * ----------------------------------
 * Returns a randomly chosen element of the given vector.
 * Throws an error if the vector is empty.
 */
template <typename T>
const T& randomElement(const Vector<T>& vec) {
    return stanfordcpplib::collections::randomElementIndexed(vec);
}

/*
 * Randomly rearranges the elements of the given vector.
 */
template <typename T>
void shuffle(Vector<T>& v) {
    v.shuffle();
}

#endif // _vector_h

/////////////////////// END code extracted from StanfordCPPLib/collections/vector.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/strlib.h ///////////////////////
/*
 * File: strlib.h
 * --------------
 * This file exports several useful string functions that are not
 * included in the C++ string library.
 * 
 * @version 2018/11/14
 * - added std::to_string for bool, char, pointer, and generic template type T
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2018/09/02
 * - added padLeft, padRight
 * @version 2016/11/09
 * - added boolalpha to writeGenericValue (improves bool printing in
 *   collection toString output)
 * @version 2016/10/30
 * - added overloads that take type char instead of string:
 *   stringContains, stringIndexOf, stringJoin, stringLastIndexOf, stringReplace,
 *   stringSplit, toLowerCase, toUpperCase
 * @version 2016/10/26
 * - bug fix for stringLastIndexOf default index arg
 * @version 2016/10/13
 * - modified writeGenericValue, writeQuotedString to return ostream
 * @version 2016/08/03
 * - modified readGenericValue not to throw error() on parse failures
 *   (needed to support idiomatic silent-failing >> operators)
 * @version 2015/10/26
 * - added charToInteger/integerToChar functions
 * @version 2015/08/02
 * - added htmlEncode/Decode functions (not 100% perfect but works for common cases)
 * @version 2014/10/19
 * - alphabetized functions
 * - added several 'inPlace' variants of existing functions that return strings
 * @version 2014/10/08
 * - removed dependency on 'using namespace' statement
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _strlib_h
#define _strlib_h

#include <iostream>
#include <sstream>
#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * Returns the string "true" if b is true, or "false" if b is false.
 */
std::string boolToString(bool b);

/**
 * Returns the string "true" if b is nonzero, or "false" if b is 0.
 */
std::string boolToString(int b);

/**
 * Returns an integer equivalent of the given numeric character.
 * For example, charToInteger('3') returns the int 3.
 * If the character is not '0' through '9', throws an error.
 */
int charToInteger(char c);

/**
 * Returns a single-character string containing the given character.
 * For example, charToString('Q') returns the string "Q".
 */
std::string charToString(char c);

/**
 * Converts a floating-point number into the corresponding string form.
 * For example, calling <code>doubleToString(23.45)</code> returns
 * the string <code>"23.45"</code>.
 * Equivalent to realToString.
 */
std::string doubleToString(double d);

/**
 * Returns <code>true</code> if the string <code>str</code> ends with
 * the specified suffix.
 */
bool endsWith(const std::string& str, const std::string& suffix);

/**
 * Returns <code>true</code> if the string <code>str</code> ends with
 * the specified character.
 */
bool endsWith(const std::string& str, char suffix);

/**
 * Returns <code>true</code> if <code>s1</code> and <code>s2</code> are
 * equal discounting differences in case.
 */
bool equalsIgnoreCase(const std::string& s1, const std::string& s2);

/**
 * Converts the given string from an HTML-encoded version to its decoded
 * equivalent; the opposite of htmlEncode. Any escaped HTML character entities
 * will be replaced by their unescaped equivalents.
 * For example, <code>htmlEncode("&lt;p class=&quot;abc&quot;&gt;I love you &amp; me&lt;/p&gt;")
 * returns "<p class=\"abc\">I love you & me</p>".
 */
std::string htmlDecode(const std::string& s);

/**
 * Converts the given string into an HTML-encoded equivalent version, with
 * any relevant HTML character entities replaced by escaped equivalents.
 * For example, <code>htmlEncode("<p class=\"abc\">I love you & me</p>") returns
 * "&lt;p class=&quot;abc&quot;&gt;I love you &amp; me&lt;/p&gt;".
 */
std::string htmlEncode(const std::string& s);

/**
 * Converts an integer into the corresponding numeric character.
 * For example, calling <code>integerToChar(3)</code> returns
 * the char <code>'3'</code>.
 * @throw ErrorException if the given integer is not a single-digit number from 0-9 inclusive
 */
char integerToChar(int n);

/**
 * Converts an integer into the corresponding string of digits.
 * For example, calling <code>integerToString(123)</code> returns
 * the string <code>"123"</code>.
 */
std::string integerToString(int n, int radix = 10);

/**
 * Converts an integer into the corresponding string of digits.
 * For example, calling <code>longToString(123)</code> returns
 * the string <code>"123"</code>.
 */
std::string longToString(long n, int radix = 10);

/**
 * Inserts spaces at the start of the given string until it is at least
 * the given length.
 * You can optionally pass a fill character (other than space) as a third parameter.
 *
 * Note that if you are printing strings and want your output to line up
 * at a given number of characters, you may be better served using the built-in
 * C++ ostream manipulators such as setw(int), left, and right, as defined in
 * the iomanip library.
 */
std::string padLeft(const std::string& s, int length, char fill = ' ');

/**
 * Inserts spaces at the end of the given string until it is at least
 * the given length.
 * You can optionally pass a fill character (other than space) as a third parameter.
 *
 * Note that if you are printing strings and want your output to line up
 * at a given number of characters, you may be better served using the built-in
 * C++ ostream manipulators such as setw(int), left, and right, as defined in
 * the iomanip library.
 */
std::string padRight(const std::string& s, int length);

/**
 * Returns a hexadecimal string for the given pointer, such as "0x3f0427b".
 * Returns "nullptr" if p is a null pointer.
 */
std::string pointerToString(void* p);

/**
 * Converts a floating-point number into the corresponding string form.
 * For example, calling <code>realToString(23.45)</code> returns
 * the string <code>"23.45"</code>.
 */
std::string realToString(double d);

/**
 * Returns <code>true</code> if the string <code>str</code> starts with
 * the specified prefix.
 */
bool startsWith(const std::string& str, char prefix);

/**
 * Returns <code>true</code> if the string <code>str</code> starts with
 * the specified character.
 */
bool startsWith(const std::string& str, const std::string& prefix);

/**
 * Returns true if the given character occurs somewhere in s.
 */
bool stringContains(const std::string& s, char ch);

/**
 * Returns true if the given substring occurs somewhere in s.
 */
bool stringContains(const std::string& s, const std::string& substring);

/**
 * Returns the index of the start of the first occurrence of the given character
 * in s, if it occurs in s.  If it does not occur, returns -1.
 * This function is very similar to string.find, but find returns string::npos
 * when the string is not found.
 */
int stringIndexOf(const std::string& s, char ch, int startIndex = 0);

/**
 * Returns the index of the start of the first occurrence of the given substring
 * in s, if it occurs in s.  If it does not occur, returns -1.
 * This function is very similar to string.find, but find returns string::npos
 * when the string is not found.
 */
int stringIndexOf(const std::string& s, const std::string& substring, int startIndex = 0);

/**
 * Returns true if the given string is either "true" or "false".
 */
bool stringIsBool(const std::string& str);

/**
 * Returns true if the given string could be converted to an real number
 * successfully by the stringToReal function, which will be true if
 * the string has the format of a real number such as "3.14" or "-46".
 * Equivalent to stringIsReal.
 */
bool stringIsDouble(const std::string& str);   // alias

/**
 * Returns true if the given string could be converted to an integer
 * successfully by the stringToInteger function, which will be true if
 * the string has the format of an integer such as "1234" or "-8".
 * Optionally accepts a radix (base) parameter if base-10 is not desired.
 */
bool stringIsInteger(const std::string& str, int radix = 10);

/**
 * Returns true if the given string could be converted to a long
 * successfully by the stringToLong function, which will be true if
 * the string has the format of an integer such as "1234" or "-8".
 * Optionally accepts a radix (base) parameter if base-10 is not desired.
 */
bool stringIsLong(const std::string& str, int radix = 10);

/**
 * Returns true if the given string could be converted to an real number
 * successfully by the stringToReal function, which will be true if
 * the string has the format of a real number such as "3.14" or "-46".
 */
bool stringIsReal(const std::string& str);

/**
 * Combines the elements of the given vector into a single string,
 * with the given delimiter separating neighboring elements, and returns it.
 * For example, joining the elements of the vector
 * {"Hi", "there", "", "Jim"} with the delimiter '?' returns "Hi?there??Jim".
 */
std::string stringJoin(const Vector<std::string>& v, char delimiter = '\n');

/**
 * Combines the elements of the given STL vector into a single string,
 * with the given delimiter separating neighboring elements, and returns it.
 * For example, joining the elements of the vector
 * {"Hi", "there", "", "Jim"} with the delimiter "??" returns "Hi??there????Jim".
 */
std::string stringJoin(const Vector<std::string>& v, const std::string& delimiter = "\n");

/**
 * Returns the index of the start of the last occurrence of the given character
 * in s, if it occurs in s.  If it does not occur, returns -1.
 * This function is very similar to string.rfind, but rfind returns string::npos
 * when the string is not found.
 */
int stringLastIndexOf(const std::string& s, char ch, int startIndex = (int) std::string::npos);

/**
 * Returns the index of the start of the last occurrence of the given substring
 * in s, if it occurs in s.  If it does not occur, returns -1.
 * This function is very similar to string.rfind, but rfind returns string::npos
 * when the string is not found.
 */
int stringLastIndexOf(const std::string& s, const std::string& substring, int startIndex = (int) std::string::npos);

/**
 * Returns a new string formed by replacing any occurrences of the given 'old'
 * character with the given replacement character in 'str'.
 * Note that this is NOT a regular expression replacement; it looks for the
 * 'old' string literally.  If you want regular expressions, see regexpr.h.
 * The 'inPlace' variant modifies an existing string rather than returning a new one,
 * and returns the number of occurrences of 'old' were replaced.
 */
std::string stringReplace(const std::string& str, char old, char replacement, int limit = -1);

/**
 * Returns a new string formed by replacing any occurrences of the given 'old'
 * text with the given replacement text in 'str'.
 * Note that this is NOT a regular expression replacement; it looks for the
 * 'old' string literally.  If you want regular expressions, see regexpr.h.
 * The 'inPlace' variant modifies an existing string rather than returning a new one,
 * and returns the number of occurrences of 'old' were replaced.
 */
std::string stringReplace(const std::string& str, const std::string& old, const std::string& replacement, int limit = -1);

/**
 * A variant of stringReplace, except that it accepts the string as a reference
 * and modifies it in-place rather than returning a new string.
 */
int stringReplaceInPlace(std::string& str, char old, char replacement, int limit = -1);

/**
 * A variant of stringReplace, except that it accepts the string as a reference
 * and modifies it in-place rather than returning a new string.
 */
int stringReplaceInPlace(std::string& str, const std::string& old, const std::string& replacement, int limit = -1);

/**
 * Returns a vector whose elements are strings formed by splitting the
 * given string 'str' by the given separator character.
 * For example, splitting "Hi there  Jim!" on " " returns
 * {"Hi", "there", "", "Jim!"}.
 */
Vector<std::string> stringSplit(const std::string& str, char delimiter, int limit = -1);

/**
 * Returns a vector whose elements are strings formed by splitting the
 * given string 'str' by the given separator text.
 * For example, splitting "Hi there  Jim!" on " " returns
 * {"Hi", "there", "", "Jim!"}.
 */
Vector<std::string> stringSplit(const std::string& str, const std::string& delimiter, int limit = -1);

/**
 * If str is "true", returns the bool value true.
 * If str is "false", returns the bool value false.
 * @throw ErrorException if str is any other value than "true" or "false"
 */
bool stringToBool(const std::string& str);

/**
 * Converts a single-character string into its corresponding char value.
 * For example, stringToChar("hello") returns the char 'h'.
 * @throw ErrorException if the given string does not contain exactly 1 character
 */
char stringToChar(const std::string& str);

/**
 * Converts a string representing a real number into its corresponding
 * value.
 * Equivalent to stringToReal.
 * @throw ErrorException if the string is not a legal floating-point number
 *        or contains extraneous characters other than whitespace
 */
double stringToDouble(const std::string& str);   // alias

/**
 * Converts a string of digits into an integer.
 * The function accepts an optional radix (base); for example,
 * stringToInteger("234", 16) assumes that the string is in base-16 and
 * returns 2*16*16 + 3*16 + 4 = 564.
 * @throw ErrorException if the string is not a legal integer or contains
 *        extraneous characters other than whitespace
 */
int stringToInteger(const std::string& str, int radix = 10);

/**
 * Converts a string of digits into a long.
 * The function accepts an optional radix (base); for example,
 * stringToLong("234", 16) assumes that the string is in base-16 and
 * returns 2*16*16 + 3*16 + 4 = 564.
 * @throw ErrorException if the string is not a legal long or contains
 *        extraneous characters other than whitespace
 */
long stringToLong(const std::string& str, int radix = 10);

/**
 * Converts a string representing a real number into its corresponding
 * value.
 * Equivalent to stringToDouble.
 * @throw ErrorException if the string is not a legal floating-point number or
 * contains extraneous characters other than whitespace
 */
double stringToReal(const std::string& str);

/**
 * Returns a new character in which the given uppercase character has been
 * converted into its lowercase equivalent.
 */
char toLowerCase(char ch);

/**
 * Returns a new string in which all uppercase characters have been converted
 * into their lowercase equivalents.
 */
std::string toLowerCase(const std::string& str);

/**
 * Modifies the given string in-place such that all uppercase characters have
 * been converted into their lowercase equivalents.
 */
void toLowerCaseInPlace(std::string& str);

/**
 * Returns a new character in which the given lowercase character has been
 * converted into its uppercase equivalent.
 */
char toUpperCase(char ch);

/**
 * Returns a new string in which all lowercase characters have been converted
 * into their uppercase equivalents.
 */
std::string toUpperCase(const std::string& str);

/**
 * Modifies the given string in-place such that all lowercase characters have
 * been converted into their uppercase equivalents.
 */
void toUpperCaseInPlace(std::string& str);

/**
 * Returns a new string after removing any whitespace characters
 * from the beginning and end of the argument.
 */
std::string trim(const std::string& str);

/**
 * Modifies the given string in-place where any whitespace characters
 * from the beginning and end of the argument are removed.
 */
void trimInPlace(std::string& str);

/**
 * Returns a new string after removing any whitespace characters
 * from the end of the argument.
 */
std::string trimEnd(const std::string& str);

/**
 * Modifies the given string in-place to remove any whitespace characters
 * from its end.
 */
void trimEndInPlace(std::string& str);

/**
 * Returns a new string after removing any whitespace characters
 * from the beginning of the argument.
 */
std::string trimStart(const std::string& str);

/**
 * Modifies the given string in-place to remove removing any whitespace characters
 * from the beginning of it.
 */
void trimStartInPlace(std::string& str);

/**
 * Returns a URL-decoded version of the given string, where any %xx character
 * codes are converted back to the equivalent characters.
 */
std::string urlDecode(const std::string& str);

/**
 * Modifies the given string in-place into a URL-decoded version of itself,
 * where any %xx character codes are converted back to the equivalent characters.
 */
void urlDecodeInPlace(std::string& str);

/**
 * Returns a URL-encoded version of the given string, where most non-
 * alphabetic characters are replaced by %xx character codes.
 */
std::string urlEncode(const std::string& str);

/**
 * Modifies the given string in-place into a URL-encoded version of itself,
 * where most non- alphabetic characters are replaced by %xx character codes.
 */
void urlEncodeInPlace(std::string& str);

// add to_string overloads for some common types missing from C++ standard
namespace std {
/**
 * String-to-bool conversion function.
 * If str is "true", returns the bool value true.
 * If str is "false", returns the bool value false.
 * @throw ErrorException if str is any other value than "true" or "false"
 */
bool stob(const std::string& str);

/**
 * String-to-char conversion function.
 * Converts a single-character string into its corresponding char value.
 * For example, stringToChar("hello") returns the char 'h'.
 * @throw ErrorException if the given string does not contain exactly 1 character
 */
char stoc(const std::string& str);

/**
 * Returns the string "true" if b is true, or "false" if b is false.
 */
std::string to_string(bool b);

/**
 * Returns a single-character string containing the given character.
 * For example, charToString('Q') returns the string "Q".
 */
std::string to_string(char c);

/**
 * Returns a hexadecimal string for the given pointer, such as "0x3f0427b".
 * Returns "nullptr" if p is a null pointer.
 */
std::string to_string(void* p);

/**
 * Generic to_string function for any type that has an operator <<.
 */
template <typename T>
std::string to_string(const T& value) {
    std::ostringstream out;
    out << value;   // if you get an error here, your type might not have a << operator
    return out.str();
}
} // namespace std

#endif // _strlib_h

/////////////////////// END code extracted from StanfordCPPLib/util/strlib.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/stringutils.h ///////////////////////
/*
 * File: stringutils.h
 * -------------------
 * This file contains declarations of utility functions related to strings.
 * Arguably some of this functionality could be moved into strlib.{h,cpp},
 * but it is mostly written to support autograders so it is placed here.
 * 
 * @author Marty Stepp
 * @version 2017/10/20
 * - changed string to const string& in all functions
 * @version 2016/11/09
 * - added trimToSize function
 * @since 2014/03/01
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _stringutils_h
#define _stringutils_h

#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * @private
 */
namespace stringutils {
int charsDifferent(const std::string& s1, const std::string& s2);
std::string collapseSpaces(const std::string& s);
Vector<std::string> explodeLines(const std::string& s);
int height(const std::string& s);
std::string implode(const Vector<std::string>& v, const std::string& delimiter = "\n");
std::string indent(const std::string& s, int spaces);

/*
 * Removes blank lines and collapses multiple spaces into one.
 * Used to facilitate approximate output matching.
 */
std::string makeSloppy(const std::string& s);
std::string removeBlankLines(const std::string& s);
std::string toLowerCase(const std::string& s);
std::string trimR(const std::string& s);
std::string trimToHeight(const std::string& s, int height, const std::string& suffix = "...");
std::string trimToSize(const std::string& s, int width, int height, const std::string& suffix = " ...");
std::string trimToWidth(const std::string& s, int width, const std::string& suffix = " ...");
std::string stripWhitespace(const std::string& s);
std::string truncate(const std::string& s, int length, const std::string& suffix = " ...");
std::string toPrintable(int ch);
int width(const std::string& s);
} // namespace stringutils

#endif // _stringutils_h

/////////////////////// END code extracted from StanfordCPPLib/util/stringutils.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/intrange.h ///////////////////////
/*
 * File: intrange.h
 * ----------------
 * This file exports the <code>IntRange</code> class, which represents an iterable
 * contiguous range of integers that can be processed using a for-each loop.
 * The range is not stored all in memory, so it does not require O(N) space.
 *
 * See intrange.cpp for the implementation of each member.
 *
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2018/08/25
 * - renamed from range.h to intrange.h
 * @version 2018/03/12
 * - initial version
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _intrange_h
#define _intrange_h

#include <iostream>
#include <iterator>
#include <limits>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * An IntRange is an iterable contiguous range of integers.
 * It can be processed using a for-each loop.
 * The integers are not actually all stored in this object, so it does not
 * require O(N) memory usage.
 */
class IntRange {
private:
    /**
     * Internal iterator for looping over a range.
     */
    class IntRangeIterator : public std::iterator<std::random_access_iterator_tag, int> {
    private:
        const IntRange* r;
        int val;

    public:
        IntRangeIterator(const IntRange* r, bool end) {
            this->r = r;
            this->val = (end ? r->max() + 1 : r->min());
        }

        IntRangeIterator(const IntRangeIterator& itr)
            : r(itr.r),
              val(itr.val) {
            // empty
        }

        IntRangeIterator& operator ++() {
            val++;
            if (!r->contains(val)) {
                val = r->max() + 1;
            }
            return *this;
        }

        IntRangeIterator operator ++(int) {
            IntRangeIterator copy(*this);
            operator++();
            return copy;
        }

        IntRangeIterator& operator --() {
            val--;
            return *this;
        }

        IntRangeIterator operator --(int) {
            IntRangeIterator copy(*this);
            operator--();
            return copy;
        }

        bool operator ==(const IntRangeIterator& rhs) {
            return r == rhs.r && val == rhs.val;
        }

        bool operator !=(const IntRangeIterator& rhs) {
            return !(*this == rhs);
        }

        bool operator <(const IntRangeIterator& rhs) {
            if (r != rhs.r) {
                error("Range Iterator::operator <: Iterators are in different ranges");
            }
            return val < rhs.val;
        }

        bool operator <=(const IntRangeIterator& rhs) {
            if (r != rhs.r) {
                error("Range Iterator::operator <=: Iterators are in different ranges");
            }
            return val <= rhs.val;
        }

        bool operator >(const IntRangeIterator& rhs) {
            if (r != rhs.r) {
                error("Range Iterator::operator >: Iterators are in different ranges");
            }
            return val > rhs.val;
        }

        bool operator >=(const IntRangeIterator& rhs) {
            if (r != rhs.r) {
                error("Range Iterator::operator >=: Iterators are in different ranges");
            }
            return val >= rhs.val;
        }

        IntRangeIterator operator +(const int& rhs) {
            return IntRangeIterator(r, val + rhs);
        }

        IntRangeIterator operator +=(const int& rhs) {
            val += rhs;
            return *this;
        }

        IntRangeIterator operator -(const int& rhs) {
            return IntRangeIterator(r, val - rhs);
        }

        IntRangeIterator operator -=(const int& rhs) {
            val -= rhs;
            return *this;
        }

        int operator -(const IntRangeIterator& rhs) {
            if (r != rhs.r) {
                error("Range Iterator::operator -: Iterators are in different ranges");
            }
            return val - rhs.val;
        }

        int operator *() {
            return val;
        }

        int* operator ->() {
            return &val;
        }

        int operator [](int k) {
            return val + k;
        }
    };

    int _min;
    int _max;

    friend std::istream& operator >>(std::istream& input, IntRange& r);

public:
    /**
     * Constructs a range from 0 (inclusive) of the given length.
     * Its endpoints are [0 .. length-1].
     */
    IntRange(int length = 0);

    /**
     * Constructs a range from minValue to maxValue (inclusive).
     */
    IntRange(int minValue, int maxValue);

    /**
     * Returns an iterator over the elements of this range.
     */
    IntRangeIterator begin() const;

    /**
     * Returns true if the given integer is within the bounds of this range.
     */
    bool contains(int n) const;

    /**
     * Returns true if the given range is entirely contained within this range.
     */
    bool contains(const IntRange& r) const;

    /**
     * Returns true if this range contains no integers, meaning that its max
     * is less than its min.
     * Equivalent to isEmpty.
     */
    bool empty() const;

    IntRangeIterator end() const;

//    bool intersects(const Range& r) const;

    /**
     * Returns true if this range contains no integers, meaning that its max
     * is less than its min.
     * Equivalent to empty.
     */
    bool isEmpty() const;

    /**
     * Returns the number of integers in the range.
     * Equivalent to size.
     */
    int length() const;

    /**
     * Returns the maximum value in the range, inclusive.
     */
    int max() const;

    /**
     * Returns the minimum value in the range.
     */
    int min() const;

    /**
     * Returns the number of integers in the range.
     * Equivalent to length.
     */
    int size() const;

    /**
     * Returns a string representation of this range,
     * such as "[1 .. 10]".
     */
    std::string toString() const;
};

/**
 * Returns an integer hash code for this range.
 */
int hashCode(const IntRange& r);

/**
 * Convenience functions for constructing a range.
 * See Range constructor.
 */
IntRange range(int length = 0);
IntRange range(int min, int max);

/**
 * Relational operators for comparing ranges.
 * Ranges are ordered by their min values with ties broken by max values.
 */
bool operator <(const IntRange& r1, const IntRange& r2);
bool operator <=(const IntRange& r1, const IntRange& r2);
bool operator ==(const IntRange& r1, const IntRange& r2);
bool operator !=(const IntRange& r1, const IntRange& r2);
bool operator >(const IntRange& r1, const IntRange& r2);
bool operator >=(const IntRange& r1, const IntRange& r2);

/**
 * Writes the given range to the given output stream in its toString format.
 */
std::ostream& operator <<(std::ostream& out, const IntRange& r);

/**
 * Reads the given range to the given input stream in its toString format.
 */
std::istream& operator >>(std::istream& input, IntRange& r);


/////////////////////////////////////////////////////////////////////
// IntRange2D
/////////////////////////////////////////////////////////////////////

/**
 * An IntRange2D is an iterable contiguous 2-dimensional range of integers.
 * It can be processed using a for-each loop to emit the range as a series
 * of Point objects in y-major (default) or x-major order.
 * The points are not actually all stored in this object, so it does not
 * require O(WxH) memory usage.
 */
class IntRange2D {
private:
    /**
     * Internal iterator for looping over a 2D range.
     */
    class IntRange2DIterator : public std::iterator<std::input_iterator_tag, Point> {
    private:
        const IntRange2D* r;
        int x;
        int y;

    public:
        IntRange2DIterator(const IntRange2D* r, bool end) {
            this->r = r;
            if (end) {
                this->x = r->maxX() + 1;
                this->y = r->maxY() + 1;
            } else {
                this->x = r->minX();
                this->y = r->minY();
            }
        }

        IntRange2DIterator(const IntRange2DIterator& itr)
            : r(itr.r),
              x(itr.x),
              y(itr.y) {
            // empty
        }

        IntRange2DIterator& operator ++() {
            if (r->isYMajor()) {
                x++;
                if (x > r->maxX()) {
                    x = r->minX();
                    y++;
                }
            } else {
                y++;
                if (y > r->maxY()) {
                    y = r->minY();
                    x++;
                }
            }
            if (!r->contains(x, y)) {
                x = r->maxX() + 1;
                y = r->maxY() + 1;
            }
            return *this;
        }

        IntRange2DIterator operator ++(int) {
            IntRange2DIterator copy(*this);
            operator++();
            return copy;
        }

        IntRange2DIterator& operator --() {
            if (r->isYMajor()) {
                x--;
                if (x < r->minX()) {
                    x = r->maxX();
                    y--;
                }
            } else {
                y--;
                if (y < r->minY()) {
                    y = r->maxY();
                    x--;
                }
            }
            return *this;
        }

        IntRange2DIterator operator --(int) {
            IntRange2DIterator copy(*this);
            operator--();
            return copy;
        }

        bool operator ==(const IntRange2DIterator& rhs) const {
            return r == rhs.r && x == rhs.x && y == rhs.y;
        }

        bool operator !=(const IntRange2DIterator& rhs) const {
            return !(*this == rhs);
        }

        bool operator <(const IntRange2DIterator& rhs) const {
            if (r != rhs.r) {
                error("Range2D Iterator::operator <: Iterators are in different ranges");
            }
            return x < rhs.x || (x == rhs.x && y < rhs.y);
        }

        bool operator <=(const IntRange2DIterator& rhs) const {
            if (r != rhs.r) {
                error("Range2D Iterator::operator <=: Iterators are in different ranges");
            }
            return (*this < rhs) || (*this == rhs);
        }

        bool operator >(const IntRange2DIterator& rhs) const {
            if (r != rhs.r) {
                error("Range2D Iterator::operator >: Iterators are in different ranges");
            }
            return (rhs < *this);
        }

        bool operator >=(const IntRange2DIterator& rhs) const {
            if (r != rhs.r) {
                error("Range2D Iterator::operator >=: Iterators are in different ranges");
            }
            return (*this > rhs) || (*this == rhs);
        }

        Point operator *() const {
            return Point(x, y);
        }

        Point* operator ->() const {
            return new Point(x, y);
        }
    };

    int _minX;
    int _minY;
    int _maxX;
    int _maxY;
    bool _yMajor;

    friend std::istream& operator >>(std::istream& input, IntRange2D& r);

public:
    /**
     * Constructs a 2D range of the given width and height, default 0.
     * Its bounds will be [0,0 .. w-1,h-1] inclusive.
     * The yMajor parameter indicates whether the range will emit its members
     * in y-major (default) or x-major order.
     */
    IntRange2D(int width = 0, int height = 0, bool yMajor = true);

    /**
     * Constructs a 2D range between the given min/max locations, inclusive.
     * The yMajor parameter indicates whether the range will emit its members
     * in y-major (default) or x-major order.
     */
    IntRange2D(int minX, int minY, int maxX, int maxY, bool yMajor = true);

    /**
     * Returns an iterator over the elements of this 2D range.
     */
    IntRange2DIterator begin() const;

    /**
     * Returns true if the given x/y location is contained in this 2D range.
     */
    bool contains(int x, int y) const;

    /**
     * Returns true if the given 2D range is entirely contained in this 2D range.
     */
    bool contains(const IntRange2D& r) const;

    /**
     * Returns true if this range does not contain any integers in one dimension
     * or the other or both (if max X/Y is less than min X/Y).
     * Equivalent to isEmpty.
     */
    bool empty() const;

    /**
     * Returns an iterator at the end of the elements of this 2D range.
     */
    IntRange2DIterator end() const;

    /**
     * Returns the range of y-values in this 2D range.
     * For example, in the range [0,0 .. 4,7], the height is 8.
     */
    int height() const;

//    bool intersects(const Range2D& r) const;

    /**
     * Returns true if this range does not contain any integers in one dimension
     * or the other or both (if max X/Y is less than min X/Y).
     * Equivalent to empty.
     */
    bool isEmpty() const;

    /**
     * Returns true if this range should emit its integers in y-major order
     * as passed to the constructor (default true).
     */
    bool isYMajor() const;

    /**
     * Returns the maximum x-value in this 2D range.
     */
    int maxX() const;

    /**
     * Returns the maximum y-value in this 2D range.
     */
    int maxY() const;

    /**
     * Returns the minimum x-value in this 2D range.
     */
    int minX() const;

    /**
     * Returns the minimum y-value in this 2D range.
     */
    int minY() const;

    /**
     * Returns the total number of integers in this 2D range.
     * For example, in the range [0,0 .. 4,7], the size is 5x8 = 40.
     */
    int size() const;

    /**
     * Returns the range of x-values in this 2D range.
     * For example, in the range [0,0 .. 4,7], the height is 5.
     */
    int width() const;

    /**
     * Returns a string representation of this 2D range,
     * such as "[0,0 .. 4,7]".
     */
    std::string toString() const;
};

/**
 * Returns an integer hash code of this 2D range.
 */
int hashCode(const IntRange2D& r);

/**
 * Convenience function for constructing a 2D range.
 * See Range2D constructors.
 */
IntRange2D range2d(int width = 0, int height = 0, bool yMajor = false);

/**
 * Convenience function for constructing a 2D range.
 * See Range2D constructors.
 */
IntRange2D range2d(int minX, int minY, int maxX, int maxY, bool yMajor = false);

/**
 * Relational operators for comparing 2D ranges.
 * Ranges are ordered by their minX values, then minY, then maxX, then maxY.
 */
bool operator <(const IntRange2D& r1, const IntRange2D& r2);
bool operator <=(const IntRange2D& r1, const IntRange2D& r2);
bool operator ==(const IntRange2D& r1, const IntRange2D& r2);
bool operator !=(const IntRange2D& r1, const IntRange2D& r2);
bool operator >(const IntRange2D& r1, const IntRange2D& r2);
bool operator >=(const IntRange2D& r1, const IntRange2D& r2);

/**
 * Writes the given 2D range to the given output stream in its toString format.
 */
std::ostream& operator <<(std::ostream& out, const IntRange2D& r);

/**
 * Reads the given 2D range to the given input stream in its toString format.
 */
std::istream& operator >>(std::istream& input, IntRange2D& r);

#endif // _intrange_h

/////////////////////// END code extracted from StanfordCPPLib/util/intrange.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/io/filelib.h ///////////////////////
/*
 * File: filelib.h
 * ---------------
 * This file exports a standardized set of tools for working with
 * files.  The library offers at least some portability across the
 * file systems used in the three supported platforms: Mac OSX,
 * Windows, and Linux.  Directory and search paths are allowed to
 * contain separators in any of the supported styles, which usually
 * makes it possible to use the same code on different platforms.
 * 
 * @version 2018/10/23
 * - added getAbsolutePath
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2016/11/12
 * - added fileSize, readEntireStream
 * @version 2016/08/12
 * - added second overload of openFileDialog that accepts path parameter
 * @version 2015/04/12
 * - added promptUserForFile overload without stream parameter
 * @version 2014/10/19
 * - alphabetized function declarations
 * - converted many funcs to take const string& rather than string for efficiency
 * - added listDirectory overload that returns a Vector
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _filelib_h
#define _filelib_h

#include <iostream>
#include <fstream>
#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * Creates a new directory for the specified path.  The
 * <code>createDirectory</code> function does not report an error if
 * the directory already exists.  Unlike <code>createDirectoryPath</code>,
 * <code>createDirectory</code> does not create missing directories
 * along the path.
 * @throw ErrorException if some component of <code>path</code> does not exist
 */
void createDirectory(const std::string& path);

/**
 * Creates a new directory for the specified path.   If intermediate
 * components of <code>path</code> do not exist, this function creates
 * them as needed.
 */
void createDirectoryPath(const std::string& path);

/**
 * Adds an extension to a file name if none already exists.  If the
 * <code>extension</code> argument begins with a leading <code>*</code>,
 * any existing extension in <code>filename</code> is replaced by
 * <code>ext</code>.
 */
std::string defaultExtension(const std::string& filename, const std::string& ext);

/**
 * Deletes the specified file.
 * @throw ErrorException if the file does not exist or cannot be deleted
 */
void deleteFile(const std::string& filename);

/**
 * Expands a filename into a canonical name for the platform.
 */
std::string expandPathname(const std::string& filename);

/**
 * Returns <code>true</code> if the specified file exists.
 */
bool fileExists(const std::string& filename);

/**
 * Returns the size of the given file in bytes.
 * Returns -1 if the file does not exist or cannot be read.
 */
int fileSize(const std::string& filename);

/**
 * Returns the canonical name of a file found using a search path.
 * The <code>findOnPath</code> function is similar to
 * <code>openOnPath</code>, except that it doesn't actually
 * return an open stream.  If no matching file is found,
 * <code>findOnPath</code> returns the empty string.
 */
std::string findOnPath(const std::string& path, const std::string& filename);

/**
 * Returns an absolute filename for the given file or directory.
 * This converts from, for example, "temp/foo.txt" to "/Users/jsmith12/Documents/temp/foo.txt".
 */
std::string getAbsolutePath(const std::string& path);

/**
 * Returns an absolute filename for the current directory.
 */
std::string getCurrentDirectory();

/**
 * Returns the standard directory path separator used on this platform.
 */
std::string getDirectoryPathSeparator();

/**
 * Returns the extension of <code>filename</code>.  The extension
 * consists of the separating dot and all subsequent characters.
 * If no dot exists in the final component, <code>getExtension</code>
 * returns the empty string.  These semantics ensure that concatenating
 * the root and the extension always returns the original filename.
 */
std::string getExtension(const std::string& filename);

/**
 * Returns all but the last component of a path name.  The components
 * of the path name can be separated by any of the directory path
 * separators (forward or reverse slashes).  The special cases are
 * illustrated by the following examples:
 *
 *<pre>
 *    getHead("a/b")  = "a"     getTail("a/b")   = "b"
 *    getHead("a")    = ""      getTail("a")     = "a"
 *    getHead("/a")   = "/"     getTail("/a")    = "a"
 *    getHead("/")    = "/"     getTail("/")     = ""
 *</pre>
 */
std::string getHead(const std::string& filename);

/**
 * Returns the root of <code>filename</code>.  The root consists
 * of everything in <code>filename</code> up to the last dot and
 * the subsequent extension.  If no dot appears in the final component
 * of the filename, <code>getRoot</code> returns the entire name.
 */
std::string getRoot(const std::string& filename);

/**
 * Returns the standard search path separator used on this platform.
 */
std::string getSearchPathSeparator();

/**
 * Returns the last component of a path name.  The components of the
 * path name can be separated by any of the directory path separators
 * (forward or reverse slashes).  For details on the interpretation of
 * special cases, see the comments for the <code>getHead</code> function.
 */
std::string getTail(const std::string& filename);

/**
 * Returns the operating system's "temp" folder.
 * Can be useful if your program needs to store temporary files.
 */
std::string getTempDirectory();

/**
 * Returns <code>true</code> if the specified file is a directory.
 */
bool isDirectory(const std::string& filename);

/**
 * Returns <code>true</code> if the specified file is a regular file,
 * not a symbolic link or directory.
 */
bool isFile(const std::string& filename);

/**
 * Returns <code>true</code> if the specified file is a symbolic link.
 */
bool isSymbolicLink(const std::string& filename);

/**
 * Adds an alphabetized list of the files in the specified directory
 * to the string vector <code>list</code>.  This list excludes the
 * names <code>.</code> and <code>..</code> entries.
 */
void listDirectory(const std::string& path, Vector<std::string>& list);

/**
 * Adds an alphabetized list of the files in the specified directory
 * to the STL string vector <code>list</code>.  This list excludes the
 * names <code>.</code> and <code>..</code> entries.
 */
void listDirectory(const std::string& path, Vector<std::string>& list);

/**
 * Adds an alphabetized list of the files in the specified directory
 * to a vector that is returned.  This list excludes the
 * names <code>.</code> and <code>..</code> entries.
 */
Vector<std::string> listDirectory(const std::string& path);

/**
 * Determines whether the filename matches the specified pattern.  The
 * pattern string is interpreted in much the same way that a Unix shell
 * expands filenames and supports the following wildcard options:
 *
 *<pre>
 *    ?      Matches any single character
 *    *      Matches any sequence of characters
 *    [...]  Matches any of the specified characters
 *    [^...] Matches any character <i>except</i> the specified ones
 *</pre>
 *
 * The last two options allow a range of characters to be specified in the
 * form <code>a-z</code>.
 */
bool matchFilenamePattern(const std::string& filename, const std::string& pattern);

/**
 * Opens the file input stream <code>stream</code> using the specified
 * filename.  This function is similar to the <code>open</code>
 * method of the stream classes, but uses a C++ <code>string</code>
 * object instead of the older C-style string.  If the operation
 * succeeds, <code>openFile</code> returns <code>true</code>;
 * if it fails, <code>openFile</code> sets the failure flag in the
 * stream and returns <code>false</code>.
 */
bool openFile(std::ifstream& stream, const std::string& filename);

/**
 * Opens the file output stream <code>stream</code> using the specified
 * filename.  This function is similar to the <code>open</code>
 * method of the stream classes, but uses a C++ <code>string</code>
 * object instead of the older C-style string.  If the operation
 * succeeds, <code>openFile</code> returns <code>true</code>;
 * if it fails, <code>openFile</code> sets the failure flag in the
 * stream and returns <code>false</code>.
 */
bool openFile(std::ofstream& stream, const std::string& filename);

/**
 * Opens a dialog that allows the user to choose a file to read.
 * The dialog begins in the current directory.
 */
std::string openFileDialog(std::ifstream& stream);

/**
 * Opens a dialog that allows the user to choose a file to read.
 * The <code>title</code> parameter is displayed in the dialog title.
 * The dialog begins in the current directory.
 */
std::string openFileDialog(std::ifstream& stream,
                           const std::string& title);

/**
 * Opens a dialog that allows the user to choose a file to read.
 * The <code>title</code> parameter is displayed in the dialog title.
 * The <code>path</code> parameter is used to set the working directory.
 */
std::string openFileDialog(std::ifstream& stream,
                           const std::string& title,
                           const std::string& path);

/**
 * Opens a dialog that allows the user to choose a file to write.
 * The dialog begins in the current directory.
 */
std::string openFileDialog(std::ofstream& stream);

/**
 * Opens a dialog that allows the user to choose a file to write.
 * The <code>title</code> parameter is displayed in the dialog title.
 * The dialog begins in the current directory.
 */
std::string openFileDialog(std::ofstream& stream,
                           const std::string& title);

/**
 * Opens a dialog that allows the user to choose a file to write.
 * The <code>title</code> parameter is displayed in the dialog title.
 * The <code>path</code> parameter is used to set the working directory.
 */
std::string openFileDialog(std::ofstream& stream,
                           const std::string& title,
                           const std::string& path);

/**
 * Opens a dialog that allows the user to choose a file name to read or write.
 * The <code>title</code> parameter is displayed in the dialog title.
 * The <code>path</code> parameter is used to set the working directory.
 * If the <code>path</code> is omitted, the dialog begins in the current directory.
 */
std::string openFileDialog(const std::string& title = "Open File ...",
                           const std::string& path = "");

/**
 * Opens a file to read using a search path.  If <code>openOnPath</code>
 * is successful, it returns the first path name on the search path
 * for which <code>stream.open</code> succeeds.  The <code>path</code>
 * argument consists of a list of directories that are prepended to the
 * filename, unless <code>filename</code> begins with an absolute
 * directory marker, such as <code>/</code> or <code>~</code>.
 * The directories in the search path may be separated either
 * by colons (Unix or Mac OS) or semicolons (Windows).  If the file
 * cannot be opened, the failure bit is set in the <code>stream</code>
 * parameter, and the <code>openOnPath</code> function returns the
 * empty string.
 */
std::string openOnPath(std::ifstream& stream,
                       const std::string& path,
                       const std::string& filename);

/**
 * Opens a file to write using a search path.  If <code>openOnPath</code>
 * is successful, it returns the first path name on the search path
 * for which <code>stream.open</code> succeeds.  The <code>path</code>
 * argument consists of a list of directories that are prepended to the
 * filename, unless <code>filename</code> begins with an absolute
 * directory marker, such as <code>/</code> or <code>~</code>.
 * The directories in the search path may be separated either
 * by colons (Unix or Mac OS) or semicolons (Windows).  If the file
 * cannot be opened, the failure bit is set in the <code>stream</code>
 * parameter, and the <code>openOnPath</code> function returns the
 * empty string.
 */
std::string openOnPath(std::ofstream& stream,
                       const std::string& path,
                       const std::string& filename);

/**
 * Asks the user for the name of a file to read.
 * The file is opened using the reference parameter <code>stream</code>.
 * The function returns the name of the file.
 * If the requested file cannot be opened, the user is given additional chances
 * to type a valid file name.
 *
 * The optional <code>prompt</code> argument provides an input prompt
 * for the user.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "Unable to open that file.  Try again.".
 */
std::string promptUserForFile(std::ifstream& stream,
                              const std::string& prompt = "",
                              const std::string& reprompt = "");

/**
 * Asks the user for the name of a file to read.
 * The file is opened using the reference parameter <code>stream</code>.
 * The function returns the name of the file.
 * If the requested file cannot be opened, the user is given additional chances
 * to type a valid file name.
 *
 * The optional <code>prompt</code> argument provides an input prompt
 * for the user.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "Unable to open that file.  Try again.".
 */
std::string promptUserForFile(std::ofstream& stream,
                              const std::string& prompt = "",
                              const std::string& reprompt = "");

/**
 * Asks the user for the name of a file to read.
 * The function returns the name of the file.
 * If the requested file cannot be opened, the user is given additional chances
 * to type a valid file name.
 *
 * The optional <code>prompt</code> argument provides an input prompt
 * for the user.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "Unable to open that file.  Try again.".
 */
std::string promptUserForFile(const std::string& prompt = "",
                              const std::string& reprompt = "");

/**
 * Reads the entire contents of the specified input stream into the
 * string vector <code>lines</code>.  The client is responsible for
 * opening and closing the stream.  The vector can be either an STL
 * <code>vector</code> or a <code>Vector</code> as defined in the
 * Stanford C++ libraries.
 */
void readEntireFile(std::istream& is, Vector<std::string>& lines);

/**
 * Reads the entire contents of the specified input stream into the
 * string STL vector <code>lines</code>.  The client is responsible for
 * opening and closing the stream.  The vector can be either an STL
 * <code>vector</code> or a <code>Vector</code> as defined in the
 * Stanford C++ libraries.
 */
void readEntireFile(std::istream& is, Vector<std::string>& lines);

/**
 * An overload of readEntireFile that just returns the whole file as a very
 * long single string, rather than a vector of lines.
 * @throw ErrorException if the file is not found or cannot be read.
 */
std::string readEntireFile(const std::string& filename);

/**
 * An overload of readEntireFile that just reads the whole file as a very
 * long single string, rather than a vector of lines.
 *
 * This version fills an output reference with the text read.
 * Returns true if the read was successful or false if the file was not found
 * or unable to be opened for reading.
 */
bool readEntireFile(const std::string& filename, std::string& out);

/**
 * Reads the contents of the given stream until its end and returns them as
 * a string.
 */
std::string readEntireStream(std::istream& input);

/**
 * Reads the contents of the given stream until its end and stores them
 * in the given string 'out' by reference.
 */
void readEntireStream(std::istream& input, std::string& out);

/**
 * Renames a file.
 * @throw ErrorException if the old file does not exist, cannot be read,
 *        the new file name already exists,
 *        or the old file cannot otherwise be renamed to the new file name
 */
void renameFile(const std::string& oldname, const std::string& newname);

/**
 * Moves the given input stream back to its beginning, so that it can
 * be read again from start to finish.
 */
void rewindStream(std::istream& input);

/**
 * Changes the current directory to the specified path.
 */
void setCurrentDirectory(const std::string& path);

/**
 * Opens the given file and writes the given text into it.
 * Normally this function replaces any previous contents of the file, but
 * if the optional 'append' parameter is passed, the given text is added
 * at the end of the file, retaining any previous contents.
 * Returns true if the write was successful and false if the file was unable
 * to be opened for writing.
 */
bool writeEntireFile(const std::string& filename,
                     const std::string& text,
                     bool append = false);

/**
 * Platform-dependent functions that differ by operating system.
 * @private
 */
namespace platform {
    std::string file_openFileDialog(const std::string& title, const std::string& mode, const std::string& path);
    void filelib_createDirectory(const std::string& path);
    void filelib_deleteFile(const std::string& path);
    std::string filelib_expandPathname(const std::string& filename);
    bool filelib_fileExists(const std::string& filename);
    std::string filelib_getAbsolutePath(const std::string& path);
    std::string filelib_getCurrentDirectory();
    std::string filelib_getDirectoryPathSeparator();
    std::string filelib_getSearchPathSeparator();
    std::string filelib_getTempDirectory();
    bool filelib_isDirectory(const std::string& filename);
    bool filelib_isFile(const std::string& filename);
    bool filelib_isSymbolicLink(const std::string& filename);
    void filelib_listDirectory(const std::string& path, Vector<std::string>& list);
    void filelib_setCurrentDirectory(const std::string& path);
}

#endif // _filelib_h

/////////////////////// END code extracted from StanfordCPPLib/io/filelib.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/queue.h ///////////////////////
/*
 * File: queue.h
 * -------------
 * This file exports the <code>Queue</code> class, a collection
 * in which values are ordinarily processed in a first-in/first-out
 * (FIFO) order.
 * 
 * @version 2018/01/23
 * - fixed bad reference bug on queue.enqueue(queue.peek())
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * - added iterators begin(), end()
 * @version 2016/09/22
 * - optimized equals, ==, != to avoid deep-copy
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as {1, 2, 3}
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added comparison operators ==, !=, <, etc.
 * - added add() method as synonym for enqueue()
 * - added remove() method as synonym for dequeue()
 * - added template hashCode function
 * - optimized some functions (operator <<, toStlQueue) to avoid making unneeded deep copy
 * @version 2014/10/10
 * - removed dependency on 'using namespace' statement
 * - removed usage of __foreach macro
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _queue_h
#define _queue_h

#include <deque>
#include <initializer_list>
#include <iterator>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: Queue<ValueType>
 * -----------------------
 * This class models a linear structure called a <b><i>queue</i></b>
 * in which values are added at one end and removed from the other.
 * This discipline gives rise to a first-in/first-out behavior (FIFO)
 * that is the defining feature of queues.
 */
template <typename ValueType>
class Queue {
public:
    /*
     * Constructor: Queue
     * Usage: Queue<ValueType> queue;
     * ------------------------------
     * Initializes a new empty queue.
     */
    Queue();

    /*
     * Constructor: Queue
     * Usage: Queue<ValueType> queue {1, 2, 3};
     * ----------------------------------------
     * Initializes a new queue that stores the given elements from front-back.
     */
    Queue(std::initializer_list<ValueType> list);

    /*
     * Destructor: ~Queue
     * ------------------
     * Frees any heap storage associated with this queue.
     */
    virtual ~Queue();
    
    /*
     * Method: add
     * Usage: queue.add(value);
     * ------------------------
     * Adds <code>value</code> to the end of the queue.
     * A synonym for the enqueue method.
     */
    void add(const ValueType& value);

    /*
     * Method: back
     * Usage: ValueType last = queue.back();
     * -------------------------------------
     * Returns the last value in the queue by reference.
     */
    const ValueType& back() const;

    /*
     * Method: clear
     * Usage: queue.clear();
     * ---------------------
     * Removes all elements from the queue.
     */
    void clear();
    
    /*
     * Method: dequeue
     * Usage: ValueType first = queue.dequeue();
     * -----------------------------------------
     * Removes and returns the first item in the queue.
     */
    ValueType dequeue();

    /*
     * Method: enqueue
     * Usage: queue.enqueue(value);
     * ----------------------------
     * Adds <code>value</code> to the end of the queue.
     */
    void enqueue(const ValueType& value);
    
    /*
     * Method: equals
     * Usage: if (queue.equals(queue2)) ...
     * ------------------------------------
     * Compares two queues for equality.
     * Returns <code>true</code> if this queue contains exactly the same
     * values as the given other queue.
     * Identical in behavior to the == operator.
     */
    bool equals(const Queue<ValueType>& queue2) const;
    
    /*
     * Method: front
     * Usage: ValueType first = queue.front();
     * ---------------------------------------
     * Returns the first value in the queue by reference.
     */
    const ValueType& front() const;

    /*
     * Method: isEmpty
     * Usage: if (queue.isEmpty()) ...
     * -------------------------------
     * Returns <code>true</code> if the queue contains no elements.
     */
    bool isEmpty() const;
    
    /*
     * Method: peek
     * Usage: ValueType first = queue.peek();
     * --------------------------------------
     * Returns the first value in the queue, without removing it.  For
     * compatibility with the STL classes, this method is also exported
     * under the name <code>front</code>, in which case it returns the
     * value by reference.
     */
    const ValueType& peek() const;

    /*
     * Method: remove
     * Usage: ValueType first = queue.remove();
     * ----------------------------------------
     * Removes and returns the first item in the queue.
     * A synonym for the dequeue method.
     */
    ValueType remove();

    /*
     * Method: size
     * Usage: int n = queue.size();
     * ----------------------------
     * Returns the number of values in the queue.
     */
    int size() const;

    /*
     * Method: toString
     * Usage: string str = queue.toString();
     * -------------------------------------
     * Converts the queue to a printable string representation.
     */
    std::string toString() const;

    /*
     * Operator: ==
     * Usage: queue1 == queue2
     * -------------------
     * Returns <code>true</code> if <code>queue1</code> and <code>queue2</code>
     * contain the same elements.
     */
    bool operator ==(const Queue& queue2) const;

    /*
     * Operator: !=
     * Usage: queue1 != queue2
     * -------------------
     * Returns <code>true</code> if <code>queue1</code> and <code>queue2</code>
     * do not contain the same elements.
     */
    bool operator !=(const Queue& queue2) const;

    /*
     * Operators: <, >, <=, >=
     * Usage: queue1 < queue2 ...
     * --------------------------
     * Relational operators to compare two queues.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const Queue& queue2) const;
    bool operator <=(const Queue& queue2) const;
    bool operator >(const Queue& queue2) const;
    bool operator >=(const Queue& queue2) const;

    template <typename T>
    friend int hashCode(const Queue<T>& s);
    
    template <typename T>
    friend std::ostream& operator <<(std::ostream& os, const Queue<T>& queue);
    
    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes: Queue data structure
     * ------------------------------------------
     * The Queue class is implemented using a ring buffer.
     */

private:
    /* Instance variables */
    Vector<ValueType> ringBuffer;
    int count;
    int capacity;
    int head;
    int tail;

    /* Private functions */
    void expandRingBufferCapacity();
    int queueCompare(const Queue& queue2) const;

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public std::iterator<std::input_iterator_tag, ValueType> {
    public:
        iterator(const Queue* gp, int index)
                : gp(gp),
                  index(index) {
            itr_version = gp->version();
        }

        iterator(const iterator& it)
                : gp(it.gp),
                  index(it.index),
                  itr_version(it.itr_version) {
            // empty
        }

        iterator& operator ++() {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            index = (index + 1) % gp->capacity;
            return *this;
        }

        iterator operator ++(int) {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const iterator& rhs) {
            return gp == rhs.gp && index == rhs.index;
        }

        bool operator !=(const iterator& rhs) {
            return !(*this == rhs);
        }

        const ValueType& operator *() {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            return gp->ringBuffer[index];
        }

        ValueType* operator ->() {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            return &gp->ringBuffer[index];
        }

        unsigned int version() const {
            return itr_version;
        }

    private:
        const Queue* gp;
        int index;
        unsigned int itr_version;
    };

public:
    iterator begin() const {
        return iterator(this, /* index */ head);
    }

    iterator end() const {
        return iterator(this, /* index */ tail);
    }

    /*
     * Returns the internal version of this collection.
     * This is used to check for invalid iterators and issue error messages.
     */
    unsigned int version() const;
};

/*
 * Implementation notes: Queue data structure
 * ------------------------------------------
 * The array-based queue stores the elements in successive index
 * positions in a vector, just as a stack does.  What makes the
 * queue structure more complex is the need to avoid shifting
 * elements as the queue expands and contracts.  In the array
 * model, this goal is achieved by keeping track of both the
 * head and tail indices.  The tail index increases by one each
 * time an element is enqueued, and the head index increases by
 * one each time an element is dequeued.  Each index therefore
 * marches toward the end of the allocated vector and will
 * eventually reach the end.  Rather than allocate new memory,
 * this implementation lets each index wrap around back to the
 * beginning as if the ends of the array of elements were joined
 * to form a circle.  This representation is called a ring buffer.
 */
static const int INITIAL_CAPACITY = 10;

/*
 * Implementation notes: Queue constructor
 * ---------------------------------------
 * The constructor must allocate the array storage for the queue
 * elements and initialize the fields of the object.
 */
template <typename ValueType>
Queue<ValueType>::Queue() {
    clear();
}

template <typename ValueType>
Queue<ValueType>::Queue(std::initializer_list<ValueType> list) {
    clear();
    for (const ValueType& value : list) {
        add(value);
    }
}

/*
 * Implementation notes: ~Queue destructor
 * ---------------------------------------
 * All of the dynamic memory is allocated in the Vector class,
 * so no work is required at this level.
 */
template <typename ValueType>
Queue<ValueType>::~Queue() {
    // empty
}

template <typename ValueType>
void Queue<ValueType>::add(const ValueType& value) {
    enqueue(value);
}

template <typename ValueType>
const ValueType& Queue<ValueType>::back() const {
    if (count == 0) {
        error("Queue::back: Attempting to read back of an empty queue");
    }
    return ringBuffer[(tail + capacity - 1) % capacity];
}

template <typename ValueType>
void Queue<ValueType>::clear() {
    capacity = INITIAL_CAPACITY;
    ringBuffer = Vector<ValueType>(capacity);
    head = 0;
    tail = 0;
    count = 0;
}

/*
 * Implementation notes: dequeue, peek
 * -----------------------------------
 * These methods must check for an empty queue and report an error
 * if there is no first element.
 */
template <typename ValueType>
ValueType Queue<ValueType>::dequeue() {
    if (count == 0) {
        error("Queue::dequeue: Attempting to dequeue an empty queue");
    }
    ValueType result = ringBuffer[head];
    head = (head + 1) % capacity;
    count--;
    return result;
}

template <typename ValueType>
void Queue<ValueType>::enqueue(const ValueType& value) {
    if (count >= capacity - 1) {
        // Buffer almost full; need to resize buffer to a larger capacity.
        // BUGFIX: when calling queue.enqueue(queue.peek()), the resize here
        // was causing the reference to become invalid.
        // In this case we need to make a copy of the value so that we don't
        // lose its value on resize.
        const ValueType valueCopy = value;
        expandRingBufferCapacity();
        enqueue(valueCopy);
    } else {
        // standard add to end of ring buffer
        ringBuffer[tail] = value;
        tail = (tail + 1) % capacity;
        count++;
    }
}

template <typename ValueType>
bool Queue<ValueType>::equals(const Queue<ValueType>& queue2) const {
    return stanfordcpplib::collections::equals(*this, queue2);
}

template <typename ValueType>
const ValueType& Queue<ValueType>::front() const {
    if (count == 0) {
        error("Queue::front: Attempting to read front of an empty queue");
    }
    return ringBuffer[head];
}

template <typename ValueType>
bool Queue<ValueType>::isEmpty() const {
    return count == 0;
}

template <typename ValueType>
const ValueType& Queue<ValueType>::peek() const {
    if (count == 0) {
        error("Queue::peek: Attempting to peek at an empty queue");
    }
    return ringBuffer.get(head);
}

template <typename ValueType>
ValueType Queue<ValueType>::remove() {
    // this isEmpty check is also done in dequeue(), but we repeat it
    // here so that the possible error message will be more descriptive.
    if (isEmpty()) {
        error("Queue::remove: Attempting to remove from an empty queue");
    }
    return dequeue();
}

template <typename ValueType>
int Queue<ValueType>::size() const {
    return count;
}

template <typename ValueType>
std::string Queue<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
unsigned int Queue<ValueType>::version() const {
    return ringBuffer.version();
}

/*
 * Implementation notes: expandRingBufferCapacity
 * ----------------------------------------------
 * This private method doubles the capacity of the ringBuffer vector.
 * Note that this implementation also shifts all the elements back to
 * the beginning of the vector.
 */
template <typename ValueType>
void Queue<ValueType>::expandRingBufferCapacity() {
    Vector<ValueType> copy = ringBuffer;
    ringBuffer = Vector<ValueType>(2 * capacity);
    for (int i = 0; i < count; i++) {
        ringBuffer[i] = copy[(head + i) % capacity];
    }
    head = 0;
    tail = count;
    capacity *= 2;
}

template <typename ValueType>
int Queue<ValueType>::queueCompare(const Queue& queue2) const {
    if (this == &queue2) {
        return 0;
    }
    
    for (int i1 = 0, i2 = 0;
         i1 < count && i2 < queue2.count;
         i1++, i2++) {
        if (ringBuffer[(head + i1) % capacity] < queue2.ringBuffer[(queue2.head + i2) % queue2.capacity]) {
            return -1;
        } else if (queue2.ringBuffer[(queue2.head + i2) % queue2.capacity] < ringBuffer[(head + i1) % capacity]) {
            return 1;
        }
    }
    
    if (count < queue2.count) {
        return -1;
    } else if (count > queue2.count) {
        return 1;
    } else {
        return 0;
    }
}

template <typename ValueType>
bool Queue<ValueType>::operator ==(const Queue& queue2) const {
    return equals(queue2);
}

template <typename ValueType>
bool Queue<ValueType>::operator !=(const Queue& queue2) const {
    return !equals(queue2);
}

template <typename ValueType>
bool Queue<ValueType>::operator <(const Queue& queue2) const {
    return queueCompare(queue2) < 0;
}

template <typename ValueType>
bool Queue<ValueType>::operator <=(const Queue& queue2) const {
    return queueCompare(queue2) <= 0;
}

template <typename ValueType>
bool Queue<ValueType>::operator >(const Queue& queue2) const {
    return queueCompare(queue2) > 0;
}

template <typename ValueType>
bool Queue<ValueType>::operator >=(const Queue& queue2) const {
    return queueCompare(queue2) >= 0;
}

template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const Queue<ValueType>& queue) {
    os << "{";
    if (!queue.isEmpty()) {
        writeGenericValue(os, queue.ringBuffer[queue.head], /* forceQuotes */ true);
        for (int i = 1; i < queue.count; i++) {
            os << ", ";
            writeGenericValue(os, queue.ringBuffer[(queue.head + i) % queue.capacity], /* forceQuotes */ true);
        }
    }
    os << "}";
    return os;
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, Queue<ValueType>& queue) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, queue, element, /* descriptor */ "Queue::operator >>");
}

/*
 * Template hash function for queues.
 * Requires the element type in the queue to have a hashCode function.
 */
template <typename T>
int hashCode(const Queue<T>& q) {
    int code = hashSeed();
    for (int i = 0; i < q.count; i++) {
        code = hashMultiplier() * code + hashCode(q.ringBuffer[(q.head + i) % q.capacity]);
    }
    return int(code & hashMask());
}

#endif // _queue_h

/////////////////////// END code extracted from StanfordCPPLib/collections/queue.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/stack.h ///////////////////////
/*
 * File: stack.h
 * -------------
 * This file exports the <code>Stack</code> class, which implements
 * a collection that processes values in a last-in/first-out (LIFO) order.
 * 
 * @version 2016/12/09
 * - added iterator version checking support (implicitly via Vector)
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * - made const iterators public
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as {1, 2, 3}
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2014/11/13
 * - added add() method as synonym for push()
 * - added remove() method as synonym for pop()
 * - added comparison operators <, >=, etc.
 * - added template hashCode function
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _stack_h
#define _stack_h

#include <initializer_list>
#include <iterator>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: Stack<ValueType>
 * -----------------------
 * This class models a linear structure called a <b><i>stack</i></b>
 * in which values are added and removed only from one end.
 * This discipline gives rise to a last-in/first-out behavior (LIFO)
 * that is the defining feature of stacks.  The fundamental stack
 * operations are <code>push</code> (add to top) and <code>pop</code>
 * (remove from top).
 */
template <typename ValueType>
class Stack {
public:
    /*
     * Constructor: Stack
     * Usage: Stack<ValueType> stack;
     * ------------------------------
     * Initializes a new empty stack.
     */
    Stack();

    /*
     * Constructor: Stack
     * Usage: Stack<ValueType> stack {1, 2, 3};
     * ----------------------------------------
     * Initializes a new stack that stores the given elements from bottom-top.
     */
    Stack(std::initializer_list<ValueType> list);

    /*
     * Destructor: ~Stack
     * ------------------
     * Frees any heap storage associated with this stack.
     */
    virtual ~Stack();
    
    /*
     * Method: add
     * Usage: stack.add(value);
     * -------------------------
     * Pushes the specified value onto the top of this stack.
     * A synonym for the push method.
     */
    void add(const ValueType& value);
    
    /*
     * Method: clear
     * Usage: stack.clear();
     * ---------------------
     * Removes all elements from this stack.
     */
    void clear();
    
    /*
     * Method: equals
     * Usage: if (stack.equals(stack2)) ...
     * ------------------------------------
     * Returns <code>true</code> if this stack contains exactly the same values
     * as the given other stack.
     * Identical in behavior to the == operator.
     */
    bool equals(const Stack<ValueType>& stack2) const;
    
    /*
     * Method: isEmpty
     * Usage: if (stack.isEmpty()) ...
     * -------------------------------
     * Returns <code>true</code> if this stack contains no elements.
     */
    bool isEmpty() const;
    
    /*
     * Method: peek
     * Usage: ValueType top = stack.peek();
     * ------------------------------------
     * Returns the value of top element from this stack, without removing
     * it.  This method signals an error if called on an empty stack.
     */
    ValueType peek() const;
    
    /*
     * Method: pop
     * Usage: ValueType top = stack.pop();
     * -----------------------------------
     * Removes the top element from this stack and returns it.  This
     * method signals an error if called on an empty stack.
     */
    ValueType pop();
    
    /*
     * Method: push
     * Usage: stack.push(value);
     * -------------------------
     * Pushes the specified value onto the top of this stack.
     */
    void push(const ValueType& value);

    /*
     * Method: remove
     * Usage: ValueType top = stack.remove();
     * -----------------------------------
     * Removes the top element from this stack and returns it.
     * A synonym for the pop method.
     */
    ValueType remove();

    /*
     * Method: size
     * Usage: int n = stack.size();
     * ----------------------------
     * Returns the number of values in this stack.
     */
    int size() const;
    
    /*
     * Method: top
     * Usage: ValueType top = stack.top();
     * ------------------------------------
     * Returns the value of top element from this stack, without removing
     * it.  This method signals an error if called on an empty stack.  For
     * compatibility with the STL classes, this method is exported
     * under the name <code>top</code>, in which case it returns the value
     * by reference.
     */
    ValueType& top();

    /*
     * Method: toString
     * Usage: string str = stack.toString();
     * -------------------------------------
     * Converts the stack to a printable string representation.
     */
    std::string toString() const;

    /*
     * Operator: ==
     * Usage: stack1 == stack2
     * -----------------------
     * Returns <code>true</code> if <code>stack1</code> and <code>stack2</code>
     * contain the same elements.
     */
    bool operator ==(const Stack& stack2) const;

    /*
     * Operator: !=
     * Usage: stack1 != stack2
     * -----------------------
     * Returns <code>true</code> if <code>stack1</code> and <code>stack2</code>
     * do not contain the same elements.
     */
    bool operator !=(const Stack& stack2) const;

    /*
     * Operators: <, >, <=, >=
     * Usage: if (stack1 < stack2) ...
     * -------------------------------
     * Relational operators to compare two stacks.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const Stack& stack2) const;
    bool operator <=(const Stack& stack2) const;
    bool operator >(const Stack& stack2) const;
    bool operator >=(const Stack& stack2) const;

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes: Stack data structure
     * ------------------------------------------
     * The easiest way to implement a stack is to store the elements in a
     * Vector.  Doing so means that the problems of dynamic memory allocation
     * and copy assignment are already solved by the implementation of the
     * underlying Vector class.
     */

    template <typename T>
    friend int hashCode(const Stack<T>& s);
    
    template <typename T>
    friend std::ostream& operator <<(std::ostream& os, const Stack<T>& stack);
    
private:
    Vector<ValueType> elements;

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public Vector<ValueType>::iterator {
    public:
        iterator() : Vector<ValueType>::iterator() {}
        iterator(const iterator& it) : Vector<ValueType>::iterator(it) {}
        iterator(const typename Vector<ValueType>::iterator& it) : Vector<ValueType>::iterator(it) {}
    };
    
    class const_iterator : public Vector<ValueType>::const_iterator {
    public:
        const_iterator() : Vector<ValueType>::const_iterator() {}
        const_iterator(const const_iterator& it) : Vector<ValueType>::const_iterator(it) {}
        const_iterator(const typename Vector<ValueType>::const_iterator& it) : Vector<ValueType>::const_iterator(it) {}
    };
    
public:
    /*
     * Returns an iterator positioned at the first element of the list.
     */
    iterator begin() {
        return iterator(elements.begin());
    }

    /*
     * Returns an iterator positioned at the last element of the list.
     */
    iterator end() {
        auto itr = elements.end();
        return iterator(itr);
    }
    
    /*
     * Returns an iterator positioned at the first element of the list.
     */
    const_iterator begin() const {
        auto itr = elements.begin();
        return const_iterator(itr);
    }

    /*
     * Returns an iterator positioned at the last element of the list.
     */
    const_iterator end() const {
        auto itr = elements.end();
        return const_iterator(itr);
    }
};

/*
 * Stack class implementation
 * --------------------------
 * The Stack is internally managed using a Vector.  This layered design
 * makes the implementation extremely simple, to the point that most
 * methods can be implemented in as single line.
 */

template <typename ValueType>
Stack<ValueType>::Stack() {
    /* Empty */
}

template <typename ValueType>
Stack<ValueType>::Stack(std::initializer_list<ValueType> list) {
    for (const ValueType& element : list) {
        push(element);
    }
}

template <typename ValueType>
Stack<ValueType>::~Stack() {
    /* Empty */
}

template <typename ValueType>
void Stack<ValueType>::add(const ValueType& value) {
    push(value);
}

template <typename ValueType>
void Stack<ValueType>::clear() {
    elements.clear();
}

template <typename ValueType>
bool Stack<ValueType>::equals(const Stack<ValueType>& stack2) const {
    return stanfordcpplib::collections::equals(*this, stack2);
}

template <typename ValueType>
bool Stack<ValueType>::isEmpty() const {
    return size() == 0;
}

template <typename ValueType>
ValueType Stack<ValueType>::peek() const {
    if (isEmpty()) {
        error("Stack::peek: Attempting to peek at an empty stack");
    }
    return elements.get(elements.size() - 1);
}

template <typename ValueType>
ValueType Stack<ValueType>::pop() {
    if (isEmpty()) {
        error("Stack::pop: Attempting to pop an empty stack");
    }
    ValueType top = elements[elements.size() - 1];
    elements.remove(elements.size() - 1);
    return top;
}

template <typename ValueType>
void Stack<ValueType>::push(const ValueType& value) {
    elements.add(value);
}

template <typename ValueType>
ValueType Stack<ValueType>::remove() {
    return pop();
}

template <typename ValueType>
int Stack<ValueType>::size() const {
    return elements.size();
}

template <typename ValueType>
ValueType & Stack<ValueType>::top() {
    if (isEmpty()) {
        error("Stack::top: Attempting to read top of an empty stack");
    }
    return elements[elements.size() - 1];
}

template <typename ValueType>
std::string Stack<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
bool Stack<ValueType>::operator ==(const Stack& stack2) const {
    return elements == stack2.elements;
}

template <typename ValueType>
bool Stack<ValueType>::operator !=(const Stack & stack2) const {
    return elements != stack2.elements;
}

template <typename ValueType>
bool Stack<ValueType>::operator <(const Stack & stack2) const {
    return elements < stack2.elements;
}

template <typename ValueType>
bool Stack<ValueType>::operator <=(const Stack & stack2) const {
    return elements <= stack2.elements;
}

template <typename ValueType>
bool Stack<ValueType>::operator >(const Stack & stack2) const {
    return elements > stack2.elements;
}

template <typename ValueType>
bool Stack<ValueType>::operator >=(const Stack & stack2) const {
    return elements >= stack2.elements;
}

template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const Stack<ValueType>& stack) {
    return os << stack.elements;
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, Stack<ValueType>& stack) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, stack, element, /* descriptor */ "Stack::operator >>");
}

/*
 * Template hash function for stacks.
 * Requires the element type in the Stack to have a hashCode function.
 */
template <typename T>
int hashCode(const Stack<T>& s) {
    return hashCode(s.elements);
}

#endif // _stack_h

/////////////////////// END code extracted from StanfordCPPLib/collections/stack.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/deque.h ///////////////////////
/*
 * File: deque.h
 * -------------
 * This file exports the <code>Deque</code> class, a collection
 * in which values can be added and removed from the front or back.
 * It combines much of the functionality of a stack and a queue.
 * 
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/09/22
 * - added constructor support for std initializer_list usage, such as {1, 2, 3}
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/10/29
 * - added comparison operators ==, !=, <, etc.
 * @since 2014/10/29
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _deque_h
#define _deque_h

#include <deque>
#include <initializer_list>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: Deque<ValueType>
 * -----------------------
 * This class models a linear structure called a <b><i>deque</i></b>
 * in which values can be added and removed at either end.
 * This discipline allows first-in/first-out (FIFO) and/or
 * last-in/first-out (LIFO) behavior. That is the defining
 * feature of deques.
 */
template <typename ValueType>
class Deque {
public:
    /*
     * Constructor: Deque
     * Usage: Deque<ValueType> deque;
     * ------------------------------
     * Initializes a new empty deque.
     */
    Deque();

    /*
     * Constructor: Deque
     * Usage: Deque<ValueType> queue {1, 2, 3};
     * ----------------------------------------
     * Initializes a new deque that stores the given elements from front-back.
     */
    Deque(std::initializer_list<ValueType> list);

    /*
     * Destructor: ~Deque
     * ------------------
     * Frees any heap storage associated with this deque.
     */
    virtual ~Deque();
    
    /*
     * Method: add
     * Usage: deque.add(value);
     * ------------------------
     * Adds <code>value</code> to the end of the deque.
     * A synonym for the enqueueBack method.
     */
    void add(const ValueType& value);
    void addBack(const ValueType& value);
    void addFront(const ValueType& value);

    /*
     * Method: back
     * Usage: ValueType last = deque.back();
     * -------------------------------------
     * Returns the last value in the deque by reference.
     */
    const ValueType& back() const;

    /*
     * Method: clear
     * Usage: deque.clear();
     * ---------------------
     * Removes all elements from the deque.
     */
    void clear();
    
    /*
     * Method: dequeue
     * Usage: ValueType first = deque.dequeue();
     * -----------------------------------------
     * Removes and returns the first item in the deque.
     * A synonym for the dequeueFront method.
     */
    ValueType dequeue();
    ValueType dequeueBack();
    ValueType dequeueFront();

    /*
     * Method: enqueue
     * Usage: deque.enqueue(value);
     * ----------------------------
     * Adds <code>value</code> to the end of the deque.
     * A synonym for the enqueueBack method.
     */
    void enqueue(const ValueType& value);
    void enqueueBack(const ValueType& value);
    void enqueueFront(const ValueType& value);
    
    /*
     * Method: equals
     * Usage: if (deque.equals(deque2)) ...
     * ------------------------------------
     * Compares two deques for equality.
     * Returns <code>true</code> if this deque contains exactly the same
     * values as the given other deque.
     * Identical in behavior to the == operator.
     */
    bool equals(const Deque<ValueType>& deque2) const;
    
    /*
     * Method: front
     * Usage: ValueType first = deque.front();
     * ---------------------------------------
     * Returns the first value in the deque by reference.
     */
    const ValueType& front() const;

    /*
     * Method: isEmpty
     * Usage: if (deque.isEmpty()) ...
     * -------------------------------
     * Returns <code>true</code> if the deque contains no elements.
     */
    bool isEmpty() const;
    
    /*
     * Method: peek
     * Usage: ValueType first = deque.peek();
     * --------------------------------------
     * Returns the first value in the deque, without removing it.  For
     * compatibility with the STL classes, this method is also exported
     * under the name <code>front</code>, in which case it returns the
     * value by reference.
     * A synonym for the peekFront method.
     */
    const ValueType& peek() const;
    const ValueType& peekBack() const;
    const ValueType& peekFront() const;

    /*
     * Method: remove
     * Usage: ValueType first = deque.remove();
     * ----------------------------------------
     * Removes and returns the first item in the deque.
     * A synonym for the dequeue method.
     */
    ValueType remove();
    ValueType removeBack();
    ValueType removeFront();

    /*
     * Method: size
     * Usage: int n = deque.size();
     * ----------------------------
     * Returns the number of values in the deque.
     */
    int size() const;
    
    /*
     * Returns an STL deque object with the same elements as this Deque.
     */
    std::deque<ValueType> toStlDeque() const;
    
    /*
     * Method: toString
     * Usage: string str = deque.toString();
     * -------------------------------------
     * Converts the deque to a printable string representation.
     */
    std::string toString() const;

    /*
     * Operators: ==, !=, <, >, <=, >=
     * Usage: if (deque1 == deque2) ...
     * Usage: if (deque1 < deque2) ...
     * ...
     * --------------------------------
     * Relational operators to compare two deques.
     * The ==, != operators require that the ValueType has a == operator
     * so that the elements can be tested for equality.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator ==(const Deque& deque2) const;
    bool operator !=(const Deque& deque2) const;
    bool operator <(const Deque& deque2) const;
    bool operator <=(const Deque& deque2) const;
    bool operator >(const Deque& deque2) const;
    bool operator >=(const Deque& deque2) const;

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    template <typename Collection>
    friend int stanfordcpplib::collections::compare(const Collection& pq1, const Collection& pq2);
    
    template <typename T>
    friend int hashCode(const Deque<T>& s);
    
    template <typename T>
    friend std::ostream& operator <<(std::ostream& os, const Deque<T>& deque);

private:
    /* Instance variables */
    std::deque<ValueType> elements;
    unsigned int m_version = 0; // structure version for detecting invalid iterators

public:
    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class deque_iterator : public std::deque<ValueType>::iterator {
    public:
        deque_iterator()
                : std::deque<ValueType>::iterator(),
                  dp(nullptr),
                  itr_version(0) {
            // empty
        }

        deque_iterator(const deque_iterator& it)
                : std::deque<ValueType>::iterator(it),
                  dp(it.dp),
                  itr_version(it.itr_version) {
            // empty
        }

        deque_iterator(Deque<ValueType>* dp, const typename std::deque<ValueType>::iterator& it)
                : std::deque<ValueType>::iterator(it),
                  dp(dp),
                  itr_version(dp->version()) {
            // empty
        }

        ValueType& operator *() {
            if (dp) {
                stanfordcpplib::collections::checkVersion(*dp, *this);
            }
            return std::deque<ValueType>::iterator::operator *();   // call super
        }

        ValueType* operator ->() {
            if (dp) {
                stanfordcpplib::collections::checkVersion(*dp, *this);
            }
            return std::deque<ValueType>::iterator::operator ->();   // call super
        }

        unsigned int version() const {
            return itr_version;
        }

    private:
        const Deque* dp;
        unsigned int itr_version;
    };

    class const_deque_iterator : public std::deque<ValueType>::const_iterator {
    public:
        const_deque_iterator()
                : std::deque<ValueType>::const_iterator(),
                  dp(nullptr),
                  itr_version(0) {
            // empty
        }

        const_deque_iterator(const const_deque_iterator& it)
                : std::deque<ValueType>::const_iterator(it),
                  dp(it.dp),
                  itr_version(it.itr_version) {
            // empty
        }

        const_deque_iterator(const Deque<ValueType>* const dp, const typename std::deque<ValueType>::const_iterator& it)
                : std::deque<ValueType>::const_iterator(it),
                  dp(dp),
                  itr_version(dp->version()) {
            // empty
        }

        const ValueType& operator *() {
            if (dp) {
                stanfordcpplib::collections::checkVersion(*dp, *this);
            }
            return std::deque<ValueType>::const_iterator::operator *();   // call super
        }

        const ValueType* operator ->() {
            if (dp) {
                stanfordcpplib::collections::checkVersion(*dp, *this);
            }
            return std::deque<ValueType>::const_iterator::operator ->();   // call super
        }

        unsigned int version() const {
            return itr_version;
        }

    private:
        const Deque* dp;
        unsigned int itr_version;
    };

    /*
     * Returns an iterator positioned at the first element of the deque.
     */
    deque_iterator begin() {
        return deque_iterator(this, elements.begin());
    }

    /*
     * Returns an iterator positioned at the first element of the deque.
     */
    const_deque_iterator begin() const {
        auto itr = elements.begin();
        return const_deque_iterator(this, itr);
    }
    
    /*
     * Returns an iterator positioned at the last element of the deque.
     */
    deque_iterator end() {
        auto itr = elements.end();
        return deque_iterator(this, itr);
    }
    
    /*
     * Returns an iterator positioned at the last element of the deque.
     */
    const_deque_iterator end() const {
        auto itr = elements.end();
        return const_deque_iterator(this, itr);
    }

    /*
     * Returns the internal version of this collection.
     * This is used to check for invalid iterators and issue error messages.
     */
    unsigned int version() const;
    
    /* Assignment behavior. */
    Deque& operator =(const Deque& other) {
      if (this != &other) {
          elements = other.elements;
          m_version++;
      }
      return *this;
    }    
};

/*
 * Implementation notes: Deque constructor
 * ---------------------------------------
 * None.
 */
template <typename ValueType>
Deque<ValueType>::Deque() {
    // empty
}

template <typename ValueType>
Deque<ValueType>::Deque(std::initializer_list<ValueType> list) {
    clear();
    for (const ValueType& value : list) {
        add(value);
    }
}

/*
 * Implementation notes: ~Deque destructor
 * ---------------------------------------
 * None.
 */
template <typename ValueType>
Deque<ValueType>::~Deque() {
    // empty
}

template <typename ValueType>
void Deque<ValueType>::add(const ValueType& value) {
    enqueue(value);
}

template <typename ValueType>
void Deque<ValueType>::addBack(const ValueType& value) {
    enqueueBack(value);
}

template <typename ValueType>
void Deque<ValueType>::addFront(const ValueType& value) {
    enqueueFront(value);
}

template <typename ValueType>
const ValueType& Deque<ValueType>::back() const {
    if (isEmpty()) {
        error("Deque::back: Attempting to read back of an empty deque");
    }
    return elements.back();
}

template <typename ValueType>
void Deque<ValueType>::clear() {
    elements.clear();
    m_version++;
}

/*
 * Implementation notes: dequeue, peek
 * -----------------------------------
 * These methods must check for an empty deque and report an error
 * if there is no first element.
 */
template <typename ValueType>
ValueType Deque<ValueType>::dequeue() {
    return dequeueFront();
}

template <typename ValueType>
ValueType Deque<ValueType>::dequeueBack() {
    if (isEmpty()) {
        error("Deque::dequeueBack: Attempting to dequeue from an empty deque");
    }
    ValueType result = elements.back();
    elements.pop_back();
    m_version++;
    return result;
}

template <typename ValueType>
ValueType Deque<ValueType>::dequeueFront() {
    if (isEmpty()) {
        error("Deque::dequeueFront: Attempting to dequeue from an empty deque");
    }
    ValueType result = elements.front();
    elements.pop_front();
    m_version++;
    return result;
}

template <typename ValueType>
void Deque<ValueType>::enqueue(const ValueType& value) {
    enqueueBack(value);
}

template <typename ValueType>
void Deque<ValueType>::enqueueBack(const ValueType& value) {
    elements.push_back(value);
    m_version++;
}

template <typename ValueType>
void Deque<ValueType>::enqueueFront(const ValueType& value) {
    elements.push_front(value);
    m_version++;
}

template <typename ValueType>
bool Deque<ValueType>::equals(const Deque<ValueType>& deque2) const {
    return elements == deque2.elements;
}

template <typename ValueType>
const ValueType& Deque<ValueType>::front() const {
    if (isEmpty()) {
        error("Deque::front: Attempting to read front of an empty deque");
    }
    return elements.front();
}

template <typename ValueType>
bool Deque<ValueType>::isEmpty() const {
    return elements.empty();
}

template <typename ValueType>
const ValueType& Deque<ValueType>::peek() const {
    return peekFront();
}

template <typename ValueType>
const ValueType& Deque<ValueType>::peekBack() const {
    if (isEmpty()) {
        error("Deque::peekBack: Attempting to peek at an empty deque");
    }
    return back();
}

template <typename ValueType>
const ValueType& Deque<ValueType>::peekFront() const {
    if (isEmpty()) {
        error("Deque::peekFront: Attempting to peek at an empty deque");
    }
    return front();
}

template <typename ValueType>
ValueType Deque<ValueType>::remove() {
    return dequeue();
}

template <typename ValueType>
ValueType Deque<ValueType>::removeBack() {
    if (isEmpty()) {
        error("Deque::removeBack: Attempting to remove from an empty deque");
    }
    return dequeueBack();
}

template <typename ValueType>
ValueType Deque<ValueType>::removeFront() {
    if (isEmpty()) {
        error("Deque::removeFront: Attempting to remove from an empty deque");
    }
    return dequeueFront();
}

template <typename ValueType>
int Deque<ValueType>::size() const {
    return elements.size();
}

template <typename ValueType>
std::deque<ValueType> Deque<ValueType>::toStlDeque() const {
    return elements;
}

template <typename ValueType>
std::string Deque<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
unsigned int Deque<ValueType>::version() const {
    return m_version;
}

template <typename ValueType>
bool Deque<ValueType>::operator ==(const Deque& deque2) const {
    return equals(deque2);
}

template <typename ValueType>
bool Deque<ValueType>::operator !=(const Deque& deque2) const {
    return !equals(deque2);
}

template <typename ValueType>
bool Deque<ValueType>::operator <(const Deque& deque2) const {
    return stanfordcpplib::collections::compare(*this, deque2) < 0;
}

template <typename ValueType>
bool Deque<ValueType>::operator <=(const Deque& deque2) const {
    return stanfordcpplib::collections::compare(*this, deque2) <= 0;
}

template <typename ValueType>
bool Deque<ValueType>::operator >(const Deque& deque2) const {
    return stanfordcpplib::collections::compare(*this, deque2) > 0;
}

template <typename ValueType>
bool Deque<ValueType>::operator >=(const Deque& deque2) const {
    return stanfordcpplib::collections::compare(*this, deque2) >= 0;
}

template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const Deque<ValueType>& deque) {
    return stanfordcpplib::collections::writeCollection(os, deque);
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, Deque<ValueType>& deque) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, deque, element, /* descriptor */ "Deque::operator >>");
}

/*
 * Template hash function for deques.
 * Requires the element type in the deque to have a hashCode function.
 */
template <typename T>
int hashCode(const Deque<T>& deq) {
    return stanfordcpplib::collections::hashCodeCollection(deq);
}

#endif // _deque_h

/////////////////////// END code extracted from StanfordCPPLib/collections/deque.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/io/tokenscanner.h ///////////////////////
/*
 * File: tokenscanner.h
 * --------------------
 * This file exports a <code>TokenScanner</code> class that divides
 * a string into individual logical units called <b><i>tokens</i></b>.
 *
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2018/09/23
 * - moved TokenType enum to inside TokenScanner class to avoid namespace conflicts
 *   (may break some client code)
 * - remove private/tokenpatch.h
 * @version 2016/11/26
 * - added getInput method
 * - replaced occurrences of string with const string& for efficiency
 * - alphabetized method ordering
 * - added operator << for printing a scanner
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _tokenscanner_h
#define _tokenscanner_h

#include <iostream>
#include <string>

/**
 * This class divides a string into individual tokens.  The typical
 * use of the <code>TokenScanner</code> class is illustrated by the
 * following pattern, which reads the tokens in the string variable
 * <code>input</code>:
 *
 *<pre>
 *    TokenScanner scanner(input);
 *    while (scanner.hasMoreTokens()) {
 *       string token = scanner.nextToken();
 *       ... process the token ...
 *    }
 *</pre>
 *
 * The <code>TokenScanner</code> class exports several additional methods
 * that give clients more control over its behavior.  Those methods are
 * described individually in the documentation.
 */
class TokenScanner {
public:
    /**
     * This enumerated type defines the values of the
     * <code>getTokenType</code> method.
     */
    enum TokenType {SEPARATOR, WORD, NUMBER, STRING, OPERATOR};

    /**
     * Initializes a scanner object with an empty token stream.
     */
    TokenScanner();

    /**
     * Initializes a scanner object.  The initial token stream comes from
     * the specified input stream.
     */
    TokenScanner(std::istream& infile);

    /**
     * Initializes a scanner object.  The initial token stream comes from
     * the specified string.
     */
    TokenScanner(const std::string& str);

    /**
     * Deallocates the storage associated with this scanner.
     */
    virtual ~TokenScanner();

    /**
     * Defines a new multicharacter operator.  Whenever you call
     * <code>nextToken</code> when the input stream contains operator
     * characters, the scanner returns the longest possible operator
     * string that can be read at that point.
     */
    void addOperator(const std::string& op);

    /**
     * Adds the characters in <code>str</code> to the set of characters
     * legal in a <code>WORD</code> token.  For example, calling
     * <code>addWordCharacters("_")</code> adds the underscore to the
     * set of characters that are accepted as part of a word.
     */
    void addWordCharacters(const std::string& str);

    /**
     * Reads the next character from the scanner input stream.
     */
    int getChar();

    /**
     * Returns the string that is used as the input buffer for this scanner,
     * if any. If this scanner was created using an istream instead of a
     * string, returns an empty string.
     */
    std::string getInput() const;

    /**
     * Returns the current position of the scanner in the input stream.
     * If <code>saveToken</code> has been called, this position corresponds
     * to the beginning of the saved token.  If <code>saveToken</code> is
     * called more than once, <code>getPosition</code> returns -1.
     */
    int getPosition() const;

    /**
     * Returns the string value of a token.  This value is formed by removing
     * any surrounding quotation marks and replacing escape sequences by the
     * appropriate characters.
     */
    std::string getStringValue(const std::string& token) const;

    /**
     * Returns the type of this token.  This type will match one of the
     * following enumerated type constants: <code>EOF</code>,
     * <code>SEPARATOR</code>, <code>WORD</code>, <code>NUMBER</code>,
     * <code>STRING</code>, or <code>OPERATOR</code>.
     */
    TokenType getTokenType(const std::string& token) const;

    /**
     * Returns <code>true</code> if there are additional tokens for this
     * scanner to read.
     */
    bool hasMoreTokens();

    /**
     * Tells the scanner to ignore comments.  The scanner package recognizes
     * both the slash-star and slash-slash comment format from the C-based
     * family of languages.  Calling:
     *
     *<pre>
     *    scanner.ignoreComments();
     *</pre>
     *
     * sets the parser to ignore comments.
     */
    void ignoreComments();

    /**
     * Tells the scanner to ignore whitespace characters.  By default,
     * the <code>nextToken</code> method treats whitespace characters
     * (typically spaces and tabs) just like any other punctuation mark
     * and returns them as single-character tokens.
     * Calling:
     *
     *<pre>
     *    scanner.ignoreWhitespace();
     *</pre>
     *
     * changes this behavior so that the scanner ignore whitespace characters.
     */
    void ignoreWhitespace();

    /**
     * Returns <code>true</code> if the character is valid in a word.
     */
    bool isWordCharacter(char ch) const;

    /**
     * Returns the next token from this scanner.  If <code>nextToken</code>
     * is called when no tokens are available, it returns the empty string.
     */
    std::string nextToken();

    /**
     * Pushes the specified token back into this scanner's input stream.
     * On the next call to <code>nextToken</code>, the scanner will return
     * the saved token without reading any additional characters from the
     * token stream.
     */
    void saveToken(const std::string& token);

    /**
     * Controls how the scanner treats tokens that begin with a digit.  By
     * default, the <code>nextToken</code> method treats numbers and letters
     * identically and therefore does not provide any special processing for
     * numbers.  Calling:
     *
     *<pre>
     *    scanner.scanNumbers();
     *</pre>
     *
     * changes this behavior so that <code>nextToken</code> returns the
     * longest substring that can be interpreted as a real number.
     */
    void scanNumbers();

    /**
     * Controls how the scanner treats tokens enclosed in quotation marks.  By
     * default, quotation marks (either single or double) are treated just like
     * any other punctuation character.  Calling:
     *
     *<pre>
     *    scanner.scanStrings();
     *</pre>
     *
     * changes this assumption so that <code>nextToken</code> returns a single
     * token consisting of all characters through the matching quotation mark.
     * The quotation marks are returned as part of the scanned token so that
     * clients can differentiate strings from other token types.
     */
    void scanStrings();

    /**
     * Sets the token stream for this scanner to the specified input stream.
     * Any previous token stream is discarded.
     */
    void setInput(std::istream& infile);

    /**
     * Sets the token stream for this scanner to the specified string.
     * Any previous token stream is discarded.
     */
    void setInput(const std::string& str);

    /**
     * Pushes the character <code>ch</code> back into the scanner stream.
     * The character must match the one that was read.
     */
    void ungetChar(int ch);

    /**
     * Reads the next token and makes sure it matches the string
     * <code>expected</code>.  If it does not, <code>verifyToken</code>
     * throws an error.
     * @throw ErrorException if the next token does not match the given string
     */
    void verifyToken(const std::string& expected);

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    /*
     * Private type: StringCell
     * ------------------------
     * This type is used to construct linked lists of cells, which are used
     * to represent both the stack of saved tokens and the set of defined
     * operators.  These types cannot use the Stack and Lexicon classes
     * directly because tokenscanner.h is an extremely low-level interface,
     * and doing so would create circular dependencies in the .h files.
     */
    struct StringCell {
        std::string str;
        StringCell *link;
    };

    enum NumberScannerState {
        INITIAL_STATE,
        BEFORE_DECIMAL_POINT,
        AFTER_DECIMAL_POINT,
        STARTING_EXPONENT,
        FOUND_EXPONENT_SIGN,
        SCANNING_EXPONENT,
        FINAL_STATE
    };

    std::string buffer;              /* The original argument string */
    std::istream* isp;               /* The input stream for tokens  */
    bool stringInputFlag;            /* Flag indicating string input */
    bool ignoreWhitespaceFlag;       /* Scanner ignores whitespace   */
    bool ignoreCommentsFlag;         /* Scanner ignores comments     */
    bool scanNumbersFlag;            /* Scanner parses numbers       */
    bool scanStringsFlag;            /* Scanner parses strings       */
    std::string wordChars;           /* Additional word characters   */
    StringCell* savedTokens;         /* Stack of saved tokens        */
    StringCell* operators;           /* List of multichar operators  */

    /* Private method prototypes */
    void initScanner();
    bool isOperator(const std::string& op);
    bool isOperatorPrefix(const std::string& op);
    std::string scanNumber();
    std::string scanString();
    std::string scanWord();
    void skipSpaces();

    friend std::ostream& operator <<(std::ostream& out, const TokenScanner& scanner);
};

/**
 * Prints the token scanner to the given output stream.
 */
std::ostream& operator <<(std::ostream& out, const TokenScanner& scanner);

#endif // _tokenscanner_h

/////////////////////// END code extracted from StanfordCPPLib/io/tokenscanner.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/map.h ///////////////////////
/*
 * File: map.h
 * -----------
 * This file exports the template class <code>Map</code>, which
 * maintains a collection of <i>key</i>-<i>value</i> pairs.
 * 
 * @version 2018/03/19
 * - added constructors that accept a comparison function
 * @version 2018/03/10
 * - added methods front, back
 * @version 2017/10/18
 * - fix compiler warnings
 * @version 2016/12/09
 * - added iterator version checking support
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/09/22
 * - bug fix for operators <, <=, >, >= (was comparing only keys!)
 * @version 2016/08/10
 * - added support for std initializer_list usage, such as
 *   {{"a", 1}, {"b", 2}, {"c", 3}} in constructor, addAll, putAll,
 *   removeAll, retainAll, and operators +, +=, -, -=, *, *=
 * - added addAll method
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/10/13
 * - nulled out pointer fields in destructor after deletion to avoid double-free
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * - fixed bug where string quotes would not show when map was printed
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added add() method as synonym for put()
 * - added template hashCode function
 * @version 2014/10/10
 * - removed usage of __foreach macro
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _map_h
#define _map_h

#include <cstdlib>
#include <initializer_list>
#include <utility>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: Map<KeyType,ValueType>
 * -----------------------------
 * This class maintains an association between <b><i>keys</i></b> and
 * <b><i>values</i></b>.  The types used for keys and values are
 * specified using templates, which makes it possible to use
 * this structure with any data type.
 */
template <typename KeyType, typename ValueType>
class Map {
public:
    /*
     * Constructor: Map
     * Usage: Map<KeyType,ValueType> map;
     * ----------------------------------
     * Initializes a new empty map that associates keys and values of the
     * specified types.
     */
    Map();

    /*
     * Constructor: Map
     * Usage: Map<KeyType,ValueType> map(lessFunc);
     * --------------------------------------------
     * Initializes a new empty map that associates keys and values of the
     * specified types, using the given "less-than" comparison function
     * to order any keys that will be later added to it.
     * The function can accept the two keys to compare either by value
     * or by const reference.
     */
    Map(bool lessFunc(KeyType, KeyType));
    Map(bool lessFunc(const KeyType&, const KeyType&));

    /*
     * Constructor: Map
     * Usage: Map<ValueType> map {{"a", 1}, {"b", 2}, {"c", 3}};
     * ---------------------------------------------------------
     * Initializes a new map that stores the given pairs.
     * Note that the pairs are stored in key-sorted order internally and not
     * necessarily the order in which they are written in the initializer list.
     */
    Map(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Constructor: Map
     * Usage: Map<ValueType> map({{"a", 1}, {"b", 2}, {"c", 3}}, lessFunc);
     * --------------------------------------------------------------------
     * Initializes a new empty map that associates keys and values of the
     * specified types, using the given "less-than" comparison function
     * to order any keys that will be later added to it.
     * The function can accept the two keys to compare either by value
     * or by const reference.
     */
    Map(std::initializer_list<std::pair<KeyType, ValueType> > list, bool lessFunc(KeyType, KeyType));
    Map(std::initializer_list<std::pair<KeyType, ValueType> > list, bool lessFunc(const KeyType&, const KeyType&));

    /*
     * Destructor: ~Map
     * ----------------
     * Frees any heap storage associated with this map.
     */
    virtual ~Map();
    
    /*
     * Method: add
     * Usage: map.add(key, value);
     * ---------------------------
     * Associates <code>key</code> with <code>value</code> in this map.
     * A synonym for the put method.
     */
    void add(const KeyType& key, const ValueType& value);

    /*
     * Method: addAll
     * Usage: map.addAll(map2);
     * ------------------------
     * Adds all key/value pairs from the given map to this map.
     * If both maps contain a pair for the same key, the one from map2 will
     * replace the one from this map.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     * Identical in behavior to putAll.
     */
    Map& addAll(const Map& map2);
    Map& addAll(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Method: back
     * Usage: KeyType value = map.back();
     * ------------------------------------
     * Returns the last key in the map in the order established by the
     * <code>foreach</code> macro.  If the map is empty, generates an error.
     */
    KeyType back() const;

    /*
     * Method: clear
     * Usage: map.clear();
     * -------------------
     * Removes all entries from this map.
     */
    void clear();
    
    /*
     * Method: containsKey
     * Usage: if (map.containsKey(key)) ...
     * ------------------------------------
     * Returns <code>true</code> if there is an entry for <code>key</code>
     * in this map.
     */
    bool containsKey(const KeyType& key) const;

    /*
     * Method: equals
     * Usage: if (map.equals(map2)) ...
     * --------------------------------
     * Returns <code>true</code> if the two maps contain exactly the same
     * key/value pairs, and <code>false</code> otherwise.
     */
    bool equals(const Map& map2) const;

    /*
     * Method: front
     * Usage: KeyType value = map.front();
     * -------------------------------------
     * Returns the first key in the map in the order established by the
     * <code>foreach</code> macro.  If the map is empty, generates an error.
     */
    KeyType front() const;

    /*
     * Method: get
     * Usage: ValueType value = map.get(key);
     * --------------------------------------
     * Returns the value associated with <code>key</code> in this map.
     * If <code>key</code> is not found, <code>get</code> returns the
     * default value for <code>ValueType</code>.
     */
    ValueType get(const KeyType& key) const;

    /*
     * Method: isEmpty
     * Usage: if (map.isEmpty()) ...
     * -----------------------------
     * Returns <code>true</code> if this map contains no entries.
     */
    bool isEmpty() const;
    
    /*
     * Method: keys
     * Usage: Vector<KeyType> keys = map.keys();
     * -----------------------------------------
     * Returns a collection containing all keys in this map.
     * Note that this implementation makes a deep copy of the keys,
     * so it is inefficient to call on large maps.
     */
    Vector<KeyType> keys() const;
    
    /*
     * Method: mapAll
     * Usage: map.mapAll(fn);
     * ----------------------
     * Iterates through the map entries and calls <code>fn(key, value)</code>
     * for each one.  The keys are processed in ascending order, as defined
     * by the comparison function.
     */
    void mapAll(void (*fn)(KeyType, ValueType)) const;
    void mapAll(void (*fn)(const KeyType&, const ValueType&)) const;
    
    template <typename FunctorType>
    void mapAll(FunctorType fn) const;

    /*
     * Method: put
     * Usage: map.put(key, value);
     * ---------------------------
     * Associates <code>key</code> with <code>value</code> in this map.
     * Any previous value associated with <code>key</code> is replaced
     * by the new value.
     */
    void put(const KeyType& key, const ValueType& value);

    /*
     * Method: putAll
     * Usage: map.putAll(map2);
     * ------------------------
     * Adds all key/value pairs from the given map to this map.
     * If both maps contain a pair for the same key, the one from map2 will
     * replace the one from this map.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     * Identical in behavior to addAll.
     */
    Map& putAll(const Map& map2);
    Map& putAll(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Method: remove
     * Usage: map.remove(key);
     * -----------------------
     * Removes any entry for <code>key</code> from this map.
     */
    void remove(const KeyType& key);

    /*
     * Method: removeAll
     * Usage: map.removeAll(map2);
     * ---------------------------
     * Removes all key/value pairs from this map that are contained in the given map.
     * If both maps contain the same key but it maps to different values, that
     * mapping will not be removed.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     */
    Map& removeAll(const Map& map2);
    Map& removeAll(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Method: retainAll
     * Usage: map.retainAll(map2);
     * ---------------------------
     * Removes all key/value pairs from this map that are not contained in the given map.
     * If both maps contain the same key but it maps to different values, that
     * mapping will be removed.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     */
    Map& retainAll(const Map& map2);
    Map& retainAll(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Method: size
     * Usage: int nEntries = map.size();
     * ---------------------------------
     * Returns the number of entries in this map.
     */
    int size() const;
    
    /*
     * Method: toString
     * Usage: string str = map.toString();
     * -----------------------------------
     * Converts the map to a printable string representation.
     */
    std::string toString() const;

    /*
     * Method: values
     * Usage: Vector<ValueType> values = map.values();
     * -----------------------------------------------
     * Returns a collection containing all values in this map.
     * Note that this implementation makes a deep copy of the values,
     * so it is inefficient to call on large maps.
     */
    Vector<ValueType> values() const;

    /*
     * Operator: []
     * Usage: map[key]
     * ---------------
     * Selects the value associated with <code>key</code>.  This syntax
     * makes it easy to think of a map as an "associative array"
     * indexed by the key type.  If <code>key</code> is already present
     * in the map, this function returns a reference to its associated
     * value.  If key is not present in the map, a new entry is created
     * whose value is set to the default for the value type.
     */
    ValueType& operator [](const KeyType& key);
    ValueType operator [](const KeyType& key) const;

    /*
     * Operator: ==
     * Usage: if (map1 == map2) ...
     * ----------------------------
     * Compares two maps for equality.
     */
    bool operator ==(const Map& map2) const;

    /*
     * Operator: !=
     * Usage: if (map1 != map2) ...
     * ----------------------------
     * Compares two maps for inequality.
     */
    bool operator !=(const Map& map2) const;

    /*
     * Operators: <, <=, >, >=
     * Usage: if (map1 < map2) ...
     * ---------------------------
     * Relational operators to compare two maps.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const Map& map2) const;
    bool operator <=(const Map& map2) const;
    bool operator >(const Map& map2) const;
    bool operator >=(const Map& map2) const;

    /*
     * Operator: +
     * Usage: map1 + map2
     * ------------------
     * Returns the union of the two maps, equivalent to a copy of the first map
     * with addAll called on it passing the second map as a parameter.
     * If the two maps both contain a mapping for the same key, the mapping
     * from the second map is favored.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    Map operator +(const Map& map2) const;
    Map operator +(std::initializer_list<std::pair<KeyType, ValueType> > list) const;

    /*
     * Operator: +=
     * Usage: map1 += map2;
     * --------------------
     * Adds all key/value pairs from the given map to this map.
     * Equivalent to calling addAll(map2).
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    Map& operator +=(const Map& map2);
    Map& operator +=(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Operator: -
     * Usage: map1 - map2
     * ------------------
     * Returns the difference of the two maps, equivalent to a copy of the first map
     * with removeAll called on it passing the second map as a parameter.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    Map operator -(const Map& map2) const;
    Map operator -(std::initializer_list<std::pair<KeyType, ValueType> > list) const;

    /*
     * Operator: -=
     * Usage: map1 -= map2;
     * --------------------
     * Removes all key/value pairs from the given map to this map.
     * Equivalent to calling removeAll(map2).
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    Map& operator -=(const Map& map2);
    Map& operator -=(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Operator: *
     * Usage: map1 * map2
     * ------------------
     * Returns the intersection of the two maps, equivalent to a copy of the first map
     * with retainAll called on it passing the second map as a parameter.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    Map operator *(const Map& map2) const;
    Map operator *(std::initializer_list<std::pair<KeyType, ValueType> > list) const;

    /*
     * Operator: *=
     * Usage: map1 *= map2;
     * ---------------------
     * Removes all key/value pairs that are not found in the given map from this map.
     * Equivalent to calling retainAll(map2).
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    Map& operator *=(const Map& map2);
    Map& operator *=(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Additional Map operations
     * -------------------------
     * In addition to the methods listed in this interface, the Map
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * All iteration is guaranteed to proceed in the order established by
     * the comparison function passed to the constructor, which ordinarily
     * matches the order of the key type.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes:
     * ---------------------
     * The map class is represented using a binary search tree.  The
     * specific implementation used here is the classic AVL algorithm
     * developed by Georgii Adel'son-Vel'skii and Evgenii Landis in 1962.
     */

private:
    /* Constant definitions */
    static const int BST_LEFT_HEAVY = -1;
    static const int BST_IN_BALANCE = 0;
    static const int BST_RIGHT_HEAVY = +1;

    /* Type definition for nodes in the binary search tree */
    struct BSTNode {
        KeyType key;             /* The key stored in this node         */
        ValueType value;         /* The corresponding value             */
        BSTNode* left;           /* Subtree containing all smaller keys */
        BSTNode* right;          /* Subtree containing all larger keys  */
        int bf;                  /* AVL balance factor                  */
    };

    /*
     * Implementation notes: Comparator
     * --------------------------------
     * The Comparator class encapsulates a functor that compares two values
     * of KeyType.  In contrast to the classes in the STL, all of which embed
     * the comparator in the type, the Map class and its derivatives pass an
     * optional Comparator value.  While this strategy results in a more
     * complex implementation, it has the advantage of allowing maps and sets
     * to carry their own comparators without forcing the client to include
     * the comparator in the template declaration.  This simplification is
     * particularly important for the Graph class.
     *
     * The allocation is required in the TemplateComparator class because
     * the type std::binary_function has subclasses but does not define a
     * virtual destructor.
     */
    class Comparator {
    public:
        virtual ~Comparator() { /* empty */ }
        virtual bool lessThan(const KeyType& k1, const KeyType& k2) = 0;
        virtual Comparator* clone() = 0;
    };

    /*
     * Compares based on an external less-than function that is passed in
     * by the client at construction.
     */
    class FunctionComparator : public Comparator {
    public:
        FunctionComparator(void* lessFunc) {
            this->lessFunc = lessFunc;
        }

        virtual bool lessThan(const KeyType& k1, const KeyType& k2) {
            bool (*less)(KeyType, KeyType) =
                    (bool (*)(KeyType, KeyType)) this->lessFunc;
            return less(k1, k2);
        }

        virtual Comparator* clone() {
            return new FunctionComparator(lessFunc);
        }

    private:
        void* lessFunc;
    };

    /*
     * Compares based on an external less-than function that is passed in
     * by the client at construction.
     * This is the same as FunctionComparator except that it uses a comparison
     * function that accepts its arguments by const reference.
     */
    class FunctionConstRefComparator : public Comparator {
    public:
        FunctionConstRefComparator(void* lessFunc) {
            this->lessFunc = lessFunc;
        }

        virtual bool lessThan(const KeyType& k1, const KeyType& k2) {
            bool (*less)(const KeyType&, const KeyType&) =
                    (bool (*)(const KeyType&, const KeyType&)) this->lessFunc;
            return less(k1, k2);
        }

        virtual Comparator* clone() {
            return new FunctionConstRefComparator(lessFunc);
        }

    private:
        void* lessFunc;
    };

    /*
     * Compares based on an internal template less-than function derived from
     * the language standard std::less comparison function mechanism.
     */
    template <typename CompareType>
    class TemplateComparator : public Comparator {
    public:
        TemplateComparator(const CompareType& compareType) {
            this->cmp = compareType;
        }

        virtual bool lessThan(const KeyType& k1, const KeyType& k2) {
            return (cmp)(k1, k2);
        }

        virtual Comparator* clone() {
            return new TemplateComparator<CompareType>(cmp);
        }

    private:
        CompareType cmp;
    };

    Comparator& getComparator() const {
        return *cmpp;
    }

    // instance variables
    BSTNode* root;      // pointer to the root of the tree
    int nodeCount;      // number of entries in the map
    Comparator* cmpp;   // pointer to the comparator
    unsigned int m_version = 0; // structure version for detecting invalid iterators

    // private methods

    /*
     * Implementation notes: findNode(t, key)
     * --------------------------------------
     * Searches the tree rooted at t to find the specified key, searching
     * in the left or right subtree, as approriate.  If a matching node
     * is found, findNode returns a pointer to the value cell in that node.
     * If no matching node exists in the tree, findNode returns nullptr.
     */
    ValueType* findNode(BSTNode* t, const KeyType& key) const {
        if (!t) {
            return nullptr;
        }
        int sign = compareKeys(key, t->key);
        if (sign == 0) {
            return &t->value;
        }
        if (sign < 0) {
            return findNode(t->left, key);
        } else {
            return findNode(t->right, key);
        }
    }

    /*
     * Implementation notes: addNode(t, key, heightFlag)
     * -------------------------------------------------
     * Searches the tree rooted at t to find the specified key, searching
     * in the left or right subtree, as approriate.  If a matching node
     * is found, addNode returns a pointer to the value cell in that node,
     * just like findNode.  If no matching node exists in the tree, addNode
     * creates a new node with a default value.  The heightFlag reference
     * parameter returns a bool indicating whether the height of the tree
     * was changed by this operation.
     */
    ValueType* addNode(BSTNode*& t, const KeyType& key, bool& heightFlag) {
        heightFlag = false;
        if (!t)  {
            t = new BSTNode();
            t->key = key;
            t->value = ValueType();
            t->bf = BST_IN_BALANCE;
            t->left = t->right = nullptr;
            heightFlag = true;
            nodeCount++;
            return &t->value;
        }
        
        int sign = compareKeys(key, t->key);
        if (sign == 0) {
            return &t->value;
        }
        ValueType* vp = nullptr;
        int bfDelta = BST_IN_BALANCE;
        if (sign < 0) {
            vp = addNode(t->left, key, heightFlag);
            if (heightFlag) {
                bfDelta = BST_LEFT_HEAVY;
            }
        } else {
            vp = addNode(t->right, key, heightFlag);
            if (heightFlag) {
                bfDelta = BST_RIGHT_HEAVY;
            }
        }
        updateBF(t, bfDelta);
        heightFlag = (bfDelta != 0 && t->bf != BST_IN_BALANCE);
        return vp;
    }

    /*
     * Implementation notes: removeNode(t, key)
     * ----------------------------------------
     * Removes the node containing the specified key from the tree rooted
     * at t.  The return value is true if the height of this subtree
     * changes.  The removeTargetNode method does the actual deletion.
     */
    bool removeNode(BSTNode*& t, const KeyType& key) {
        if (!t) {
            return false;
        }
        int sign = compareKeys(key, t->key);
        if (sign == 0) {
            return removeTargetNode(t);
        }
        int bfDelta = BST_IN_BALANCE;
        if (sign < 0) {
            if (removeNode(t->left, key)) {
                bfDelta = BST_RIGHT_HEAVY;
            }
        } else {
            if (removeNode(t->right, key)) {
                bfDelta = BST_LEFT_HEAVY;
            }
        }
        updateBF(t, bfDelta);
        return bfDelta != 0 && t->bf == BST_IN_BALANCE;
    }

    /*
     * Implementation notes: removeTargetNode(t)
     * -----------------------------------------
     * Removes the node which is passed by reference as t.  The easy case
     * occurs when either (or both) of the children is null; all you need
     * to do is replace the node with its non-null child, if any.  If both
     * children are non-null, this code finds the rightmost descendent of
     * the left child; this node may not be a leaf, but will have no right
     * child.  Its left child replaces it in the tree, after which the
     * replacement data is moved to the position occupied by the target node.
     */
    bool removeTargetNode(BSTNode*& t) {
        BSTNode* toDelete = t;
        if (!t->left) {
            t = t->right;
            delete toDelete;
            nodeCount--;
            return true;
        } else if (!t->right) {
            t = t->left;
            delete toDelete;
            nodeCount--;
            return true;
        } else {
            BSTNode* successor = t->left;
            while (successor->right) {
                successor = successor->right;
            }
            t->key = successor->key;
            t->value = successor->value;
            if (removeNode(t->left, successor->key)) {
                updateBF(t, BST_RIGHT_HEAVY);
                return (t->bf == BST_IN_BALANCE);
            }
            return false;
        }
    }

    /*
     * Implementation notes: updateBF(t, bfDelta)
     * ------------------------------------------
     * Updates the balance factor in the node and rebalances the tree
     * if necessary.
     */
    void updateBF(BSTNode*& t, int bfDelta) {
        t->bf += bfDelta;
        if (t->bf < BST_LEFT_HEAVY) {
            fixLeftImbalance(t);
        } else if (t->bf > BST_RIGHT_HEAVY) {
            fixRightImbalance(t);
        }
    }

    /*
     * Implementation notes: fixLeftImbalance(t)
     * -----------------------------------------
     * This function is called when a node has been found that is out
     * of balance with the longer subtree on the left.  Depending on
     * the balance factor of the left child, the code performs a
     * single or double rotation.
     */
    void fixLeftImbalance(BSTNode*& t) {
        BSTNode *child = t->left;
        if (child->bf == BST_RIGHT_HEAVY) {
            int oldBF = child->right->bf;
            rotateLeft(t->left);
            rotateRight(t);
            t->bf = BST_IN_BALANCE;
            switch (oldBF) {
            case BST_LEFT_HEAVY:
                t->left->bf = BST_IN_BALANCE;
                t->right->bf = BST_RIGHT_HEAVY;
                break;
            case BST_IN_BALANCE:
                t->left->bf = t->right->bf = BST_IN_BALANCE;
                break;
            case BST_RIGHT_HEAVY:
                t->left->bf = BST_LEFT_HEAVY;
                t->right->bf = BST_IN_BALANCE;
                break;
            }
        } else if (child->bf == BST_IN_BALANCE) {
            rotateRight(t);
            t->bf = BST_RIGHT_HEAVY;
            t->right->bf = BST_LEFT_HEAVY;
        } else {
            rotateRight(t);
            t->right->bf = t->bf = BST_IN_BALANCE;
        }
    }

    /*
     * Implementation notes: rotateLeft(t)
     * -----------------------------------
     * This function performs a single left rotation of the tree
     * that is passed by reference.  The balance factors
     * are unchanged by this function and must be corrected at a
     * higher level of the algorithm.
     */
    void rotateLeft(BSTNode*& t) {
        BSTNode* child = t->right;
        t->right = child->left;
        child->left = t;
        t = child;
    }

    /*
     * Implementation notes: fixRightImbalance(t)
     * ------------------------------------------
     * This function is called when a node has been found that
     * is out of balance with the longer subtree on the right.
     * Depending on the balance factor of the right child, the
     * code performs a single or double rotation.
     */
    void fixRightImbalance(BSTNode*& t) {
        BSTNode* child = t->right;
        if (child->bf == BST_LEFT_HEAVY) {
            int oldBF = child->left->bf;
            rotateRight(t->right);
            rotateLeft(t);
            t->bf = BST_IN_BALANCE;
            switch (oldBF) {
            case BST_LEFT_HEAVY:
                t->left->bf = BST_IN_BALANCE;
                t->right->bf = BST_RIGHT_HEAVY;
                break;
            case BST_IN_BALANCE:
                t->left->bf = t->right->bf = BST_IN_BALANCE;
                break;
            case BST_RIGHT_HEAVY:
                t->left->bf = BST_LEFT_HEAVY;
                t->right->bf = BST_IN_BALANCE;
                break;
            }
        } else if (child->bf == BST_IN_BALANCE) {
            rotateLeft(t);
            t->bf = BST_LEFT_HEAVY;
            t->left->bf = BST_RIGHT_HEAVY;
        } else {
            rotateLeft(t);
            t->left->bf = t->bf = BST_IN_BALANCE;
        }
    }

    /*
     * Implementation notes: rotateRight(t)
     * ------------------------------------
     * This function performs a single right rotation of the tree
     * that is passed by reference.  The balance factors
     * are unchanged by this function and must be corrected at a
     * higher level of the algorithm.
     */
    void rotateRight(BSTNode*& t) {
        BSTNode* child = t->left;
        t->left = child->right;
        child->right = t;
        t = child;
    }

    /*
     * Implementation notes: deleteTree(t)
     * -----------------------------------
     * Deletes all the nodes in the tree.
     */
    void deleteTree(BSTNode* t) {
        if (t) {
            deleteTree(t->left);
            deleteTree(t->right);
            delete t;
        }
    }

    /*
     * Implementation notes: mapAll
     * ----------------------------
     * Calls fn(key, value) for every key-value pair in the tree.
     */
    void mapAll(BSTNode* t, void (*fn)(KeyType, ValueType)) const {
        if (t) {
            mapAll(t->left, fn);
            fn(t->key, t->value);
            mapAll(t->right, fn);
        }
    }

    void mapAll(BSTNode* t,
                void (*fn)(const KeyType&, const ValueType&)) const {
        if (t) {
            mapAll(t->left, fn);
            fn(t->key, t->value);
            mapAll(t->right, fn);
        }
    }

    template <typename FunctorType>
    void mapAll(BSTNode* t, FunctorType fn) const {
        if (t) {
            mapAll(t->left, fn);
            fn(t->key, t->value);
            mapAll(t->right, fn);
        }
    }

    void deepCopy(const Map& other) {
        root = copyTree(other.root);
        nodeCount = other.nodeCount;
        cmpp = (!other.cmpp) ? nullptr : other.cmpp->clone();
        m_version++;
    }

    BSTNode* copyTree(BSTNode* const t) {
        if (!t) {
            return nullptr;
        } else {
            BSTNode* np = new BSTNode;
            np->key = t->key;
            np->value = t->value;
            np->bf = t->bf;
            np->left = copyTree(t->left);
            np->right = copyTree(t->right);
            return np;
        }
    }

public:
    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods in
     * the public portion of the interface would make that interface more
     * difficult to understand for the average client.
     */

    /* Extended constructors */
    template <typename CompareType>
    explicit Map(CompareType cmp) {
        root = nullptr;
        nodeCount = 0;
        cmpp = new TemplateComparator<CompareType>(cmp);
    }

    /*
     * Implementation notes: compareKeys(k1, k2)
     * -----------------------------------------
     * Compares the keys k1 and k2 and returns an integer (-1, 0, or +1)
     * depending on whether k1 < k2, k1 == k2, or k1 > k2, respectively.
     */
    int compareKeys(const KeyType& k1, const KeyType& k2) const {
        if (cmpp->lessThan(k1, k2)) {
            return -1;
        } else if (cmpp->lessThan(k2, k1)) {
            return +1;
        } else {
            return 0;
        }
    }

    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return maps by value
     * and assign from one map to another.
     */
    Map& operator =(const Map& src) {
        if (this != &src) {
            clear();
            if (cmpp) {
                // because we are about to clone() the other map's comparator
                delete cmpp;
                cmpp = nullptr;
            }
            deepCopy(src);
        }
        return *this;
    }

    Map(const Map& src) : root(nullptr), nodeCount(0), cmpp(nullptr) {
        deepCopy(src);
    }

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public std::iterator<std::input_iterator_tag, KeyType> {
    private:
        struct NodeMarker {
            BSTNode* np;
            bool processed;
        };

        const Map* mp;               // pointer to the map
        int index;                   // index of current element
        Stack<NodeMarker> stack;     // stack of unprocessed nodes
        unsigned int itr_version;

        void findLeftmostChild() {
            BSTNode *np = stack.peek().np;
            if (!np) {
                return;
            }
            while (np->left) {
                NodeMarker marker = { np->left,  false };
                stack.push(marker);
                np = np->left;
            }
        }

    public:
        iterator()
                : mp(nullptr),
                  index(0),
                  itr_version(0) {
            /* Empty */
        }

        iterator(const Map* theMap, bool end)
                : mp(theMap) {
            if (end || mp->nodeCount == 0) {
                index = mp->nodeCount;
            } else {
                index = 0;
                NodeMarker marker = { mp->root, false };
                stack.push(marker);
                findLeftmostChild();
            }
            itr_version = mp->version();
        }

        iterator(const iterator& it)
                : mp(it.mp),
                  index(it.index),
                  stack(it.stack),
                  itr_version(it.itr_version) {
            // empty
        }

        iterator& operator ++() {
            stanfordcpplib::collections::checkVersion(*mp, *this);
            NodeMarker marker = stack.pop();
            BSTNode* np = marker.np;
            if (!np->right) {
                while (!stack.isEmpty() && stack.peek().processed) {
                    stack.pop();
                }
            } else {
                marker.processed = true;
                stack.push(marker);
                marker.np = np->right;
                marker.processed = false;
                stack.push(marker);
                findLeftmostChild();
            }
            index++;
            return *this;
        }

        iterator operator ++(int) {
            stanfordcpplib::collections::checkVersion(*mp, *this);
            iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const iterator& rhs) {
            return mp == rhs.mp && index == rhs.index;
        }

        bool operator !=(const iterator& rhs) {
            return !(*this == rhs);
        }

        KeyType& operator *() {
            stanfordcpplib::collections::checkVersion(*mp, *this);
            return stack.peek().np->key;
        }

        KeyType* operator ->() {
            stanfordcpplib::collections::checkVersion(*mp, *this);
            return &stack.peek().np->key;
        }

        unsigned int version() const {
            return itr_version;
        }

        friend class Map;
    };

    /*
     * Returns an iterator positioned at the first key of the map.
     */
    iterator begin() const {
        return iterator(this, /* end */ false);
    }

    /*
     * Returns an iterator positioned at the last key of the map.
     */
    iterator end() const {
        return iterator(this, /* end */ true);
    }

    /*
     * Returns the internal version of this collection.
     * This is used to check for invalid iterators and issue error messages.
     */
    unsigned int version() const;
};

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>::Map() : root(nullptr), nodeCount(0) {
    cmpp = new TemplateComparator<std::less<KeyType> >(std::less<KeyType>());
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>::Map(bool lessFunc(KeyType, KeyType))
        : root(nullptr), nodeCount(0) {
    cmpp = new FunctionComparator((void*) lessFunc);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>::Map(bool lessFunc(const KeyType&, const KeyType&))
        : root(nullptr), nodeCount(0) {
    cmpp = new FunctionConstRefComparator((void*) lessFunc);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>::Map(std::initializer_list<std::pair<KeyType, ValueType> > list)
        : root(nullptr), nodeCount(0) {
    cmpp = new TemplateComparator<std::less<KeyType> >(std::less<KeyType>());
    putAll(list);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>::Map(std::initializer_list<std::pair<KeyType, ValueType> > list,
                             bool lessFunc(KeyType, KeyType))
        : root(nullptr), nodeCount(0) {
    cmpp = new FunctionComparator((void*) lessFunc);
    putAll(list);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>::Map(std::initializer_list<std::pair<KeyType, ValueType> > list,
                             bool lessFunc(const KeyType&, const KeyType&))
        : root(nullptr), nodeCount(0) {
    cmpp = new FunctionConstRefComparator((void*) lessFunc);
    putAll(list);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>::~Map() {
    clear();
    if (cmpp) {
        delete cmpp;
        cmpp = nullptr;
    }
}

template <typename KeyType, typename ValueType>
void Map<KeyType, ValueType>::add(const KeyType& key,
                                  const ValueType& value) {
    put(key, value);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::addAll(const Map& map2) {
    return putAll(map2);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::addAll(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    return putAll(list);
}

template <typename KeyType, typename ValueType>
KeyType Map<KeyType, ValueType>::back() const {
    if (isEmpty()) {
        error("Map::back: map is empty");
    }
    BSTNode* node = root;
    while (node && node->right) {
        node = node->right;
    }
    return node->key;
}

template <typename KeyType, typename ValueType>
void Map<KeyType, ValueType>::clear() {
    deleteTree(root);
    root = nullptr;
    nodeCount = 0;
    m_version++;
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::containsKey(const KeyType& key) const {
    return findNode(root, key) != nullptr;
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::equals(const Map<KeyType, ValueType>& map2) const {
    return stanfordcpplib::collections::equalsMap(*this, map2);
}

template <typename KeyType, typename ValueType>
KeyType Map<KeyType, ValueType>::front() const {
    if (isEmpty()) {
        error("Map::front: map is empty");
    }
    return *begin();
}

template <typename KeyType, typename ValueType>
ValueType Map<KeyType, ValueType>::get(const KeyType& key) const {
    ValueType* vp = findNode(root, key);
    if (!vp) {
        return ValueType();
    }
    return *vp;
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::isEmpty() const {
    return nodeCount == 0;
}

template <typename KeyType,typename ValueType>
Vector<KeyType> Map<KeyType, ValueType>::keys() const {
    Vector<KeyType> keyset;
    for (const KeyType& key : *this) {
        keyset.add(key);
    }
    return keyset;
}

template <typename KeyType, typename ValueType>
void Map<KeyType, ValueType>::mapAll(void (*fn)(KeyType, ValueType)) const {
    mapAll(root, fn);
}

template <typename KeyType, typename ValueType>
void Map<KeyType, ValueType>::mapAll(void (*fn)(const KeyType &,
                                                const ValueType &)) const {
    mapAll(root, fn);
}

template <typename KeyType, typename ValueType>
template <typename FunctorType>
void Map<KeyType, ValueType>::mapAll(FunctorType fn) const {
    mapAll(root, fn);
}

template <typename KeyType, typename ValueType>
void Map<KeyType, ValueType>::put(const KeyType& key,
                                  const ValueType& value) {
    bool dummy;
    *addNode(root, key, dummy) = value;
    m_version++;
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::putAll(const Map& map2) {
    for (const KeyType& key : map2) {
        put(key, map2.get(key));
    }
    return *this;
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::putAll(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    for (const std::pair<KeyType, ValueType>& pair : list) {
        put(pair.first, pair.second);
    }
    return *this;
}

template <typename KeyType, typename ValueType>
void Map<KeyType, ValueType>::remove(const KeyType& key) {
    removeNode(root, key);
    m_version++;
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::removeAll(const Map& map2) {
    for (const KeyType& key : map2) {
        if (containsKey(key) && get(key) == map2.get(key)) {
            remove(key);
        }
    }
    return *this;
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::removeAll(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    for (const std::pair<KeyType, ValueType>& pair : list) {
        if (containsKey(pair.first) && get(pair.first) == pair.second) {
            remove(pair.first);
        }
    }
    return *this;
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::retainAll(const Map& map2) {
    Vector<KeyType> toRemove;
    for (const KeyType& key : *this) {
        if (!map2.containsKey(key) || get(key) != map2.get(key)) {
            toRemove.add(key);
        }
    }
    for (const KeyType& key : toRemove) {
        remove(key);
    }
    return *this;
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::retainAll(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    Map<KeyType, ValueType> map2(list);
    retainAll(map2);
    return *this;
}

template <typename KeyType, typename ValueType>
int Map<KeyType, ValueType>::size() const {
    return nodeCount;
}

template <typename KeyType, typename ValueType>
std::string Map<KeyType, ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename KeyType,typename ValueType>
Vector<ValueType> Map<KeyType, ValueType>::values() const {
    Vector<ValueType> values;
    for (const KeyType& key : *this) {
        values.add(this->get(key));
    }
    return values;
}

template <typename KeyType,typename ValueType>
unsigned int  Map<KeyType, ValueType>::version() const {
    return m_version;
}

template <typename KeyType, typename ValueType>
ValueType & Map<KeyType, ValueType>::operator [](const KeyType& key) {
    bool dummy;
    return *addNode(root, key, dummy);
}

template <typename KeyType, typename ValueType>
ValueType Map<KeyType, ValueType>::operator [](const KeyType& key) const {
    return get(key);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType> Map<KeyType, ValueType>::operator +(const Map& map2) const {
    Map<KeyType, ValueType> result = *this;
    return result.putAll(map2);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType> Map<KeyType, ValueType>::operator +(
        std::initializer_list<std::pair<KeyType, ValueType> > list) const {
    Map<KeyType, ValueType> result = *this;
    return result.putAll(list);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::operator +=(const Map& map2) {
    return putAll(map2);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::operator +=(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    return putAll(list);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType> Map<KeyType, ValueType>::operator -(const Map& map2) const {
    Map<KeyType, ValueType> result = *this;
    return result.removeAll(map2);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType> Map<KeyType, ValueType>::operator -(
        std::initializer_list<std::pair<KeyType, ValueType> > list) const {
    Map<KeyType, ValueType> result = *this;
    return result.removeAll(list);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::operator -=(const Map& map2) {
    return removeAll(map2);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::operator -=(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    return removeAll(list);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType> Map<KeyType, ValueType>::operator *(const Map& map2) const {
    Map<KeyType, ValueType> result = *this;
    return result.retainAll(map2);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType> Map<KeyType, ValueType>::operator *(
        std::initializer_list<std::pair<KeyType, ValueType> > list) const {
    Map<KeyType, ValueType> result = *this;
    return result.retainAll(list);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::operator *=(const Map& map2) {
    return retainAll(map2);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::operator *=(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    return retainAll(list);
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::operator ==(const Map& map2) const {
    return equals(map2);
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::operator !=(const Map& map2) const {
    return !equals(map2);   // BUGFIX 2016/01/27, thanks to O. Zeng
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::operator <(const Map& map2) const {
    return stanfordcpplib::collections::compareMaps(*this, map2) < 0;
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::operator <=(const Map& map2) const {
    return stanfordcpplib::collections::compareMaps(*this, map2) <= 0;
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::operator >(const Map& map2) const {
    return stanfordcpplib::collections::compareMaps(*this, map2) > 0;
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::operator >=(const Map& map2) const {
    return stanfordcpplib::collections::compareMaps(*this, map2) >= 0;
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename KeyType, typename ValueType>
std::ostream& operator <<(std::ostream& os,
                          const Map<KeyType, ValueType>& map) {
    return stanfordcpplib::collections::writeMap(os, map);
}

template <typename KeyType, typename ValueType>
std::istream& operator >>(std::istream& is, Map<KeyType,ValueType>& map) {
    KeyType key;
    ValueType value;
    return stanfordcpplib::collections::readMap(is, map, key, value, /* descriptor */ std::string("Map::operator >>"));
}

/*
 * Template hash function for maps.
 * Requires the key and value types in the Map to have a hashCode function.
 */
template <typename K, typename V>
int hashCode(const Map<K, V>& map) {
    return stanfordcpplib::collections::hashCodeMap(map);
}

/*
 * Function: randomKey
 * Usage: element = randomKey(map);
 * --------------------------------
 * Returns a randomly chosen key of the given map.
 * Throws an error if the map is empty.
 */
template <typename K, typename V>
const K& randomKey(const Map<K, V>& map) {
    if (map.isEmpty()) {
        error("randomKey: empty map was passed");
    }
    int index = randomInteger(0, map.size() - 1);
    int i = 0;
    for (const K& key : map) {
        if (i == index) {
            return key;
        }
        i++;
    }
    
    // this code will never be reached
    static Vector<K> v = map.keys();
    return v[0];
}

#endif // _map_h

/////////////////////// END code extracted from StanfordCPPLib/collections/map.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/set.h ///////////////////////
/*
 * File: set.h
 * -----------
 * This file exports the <code>Set</code> class, which implements a
 * collection for storing a set of distinct elements.
 * 
 * @version 2018/03/19
 * - added constructors that accept a comparison function
 * @version 2018/03/10
 * - added methods front, back
 * @version 2016/12/09
 * - added iterator version checking support (implicitly via Map)
 * @version 2016/12/06
 * - slight speedup bug fix in equals() method
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/11
 * - added containsAll, isSupersetOf methods
 * @version 2016/08/10
 * - added support for std initializer_list usage, such as {1, 2, 3}
 *   in constructor, addAll, containsAll, isSubsetOf, isSupersetOf, removeAll,
 *   retainAll, and operators +, +=, -, -=, *, *=
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added template hashCode function
 * @version 2014/10/10
 * - removed use of __foreach macro
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _set_h
#define _set_h

#include <initializer_list>
#include <iostream>
#include <set>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: Set<ValueType>
 * ---------------------
 * This class stores a collection of distinct elements.
 */
template <typename ValueType>
class Set {
public:
    /*
     * Constructor: Set
     * Usage: Set<ValueType> set;
     * --------------------------
     * Initializes an empty set of the specified element type.
     * Elements will be ordered according to their "natural" less-than ordering
     * as dictated by the operator <.
     * The ValueType must have an operator < in order to be used in this set.
     */
    Set();

    /*
     * Constructor: Set
     * Usage: Set<ValueType> set(lessFunc);
     * -----------------------------------------------
     * Initializes a new empty set, using the given "less-than" comparison
     * function to order any elements that are later added.
     * The function should return true if the first argument is less than the
     * second, and false if not.
     * The function can accept the two elements to compare either by value
     * or by const reference.
     * Note that the elements are stored in order sorted by lessFunc
     * internally and not necessarily the order in which they are written
     * in the initializer list.
     */
    Set(bool lessFunc(ValueType, ValueType));
    Set(bool lessFunc(const ValueType&, const ValueType&));

    /*
     * Constructor: Set
     * Usage: Set<ValueType> set {1, 2, 3};
     * ------------------------------------
     * Initializes a new set that stores the given elements.
     * Note that the elements are stored in sorted order internally and not
     * necessarily the order in which they are written in the initializer list.
     */
    Set(std::initializer_list<ValueType> list);

    /*
     * Constructor: Set
     * Usage: Set<ValueType> set({1, 2, 3}, lessFunc);
     * -----------------------------------------------
     * Initializes a new set that stores the given elements, using the given
     * "less-than" comparison function to order them.
     * The function should return true if the first argument is less than the
     * second, and false if not.
     * The function can accept the two elements to compare either by value
     * or by const reference.
     * Note that the elements are stored in order sorted by lessFunc
     * internally and not necessarily the order in which they are written
     * in the initializer list.
     */
    Set(std::initializer_list<ValueType> list, bool lessFunc(ValueType, ValueType));
    Set(std::initializer_list<ValueType> list, bool lessFunc(const ValueType&, const ValueType&));

    /*
     * Destructor: ~Set
     * ----------------
     * Frees any heap storage associated with this set.
     */
    virtual ~Set();
    
    /*
     * Method: add
     * Usage: set.add(value);
     * ----------------------
     * Adds an element to this set, if it was not already there.  For
     * compatibility with the STL <code>set</code> class, this method
     * is also exported as <code>insert</code>.
     */
    void add(const ValueType& value);
    
    /*
     * Method: addAll
     * Usage: set.addAll(set2);
     * ------------------------
     * Adds all elements of the given other set to this set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Returns a reference to this set.
     * Identical in behavior to the += operator.
     */
    Set<ValueType>& addAll(const Set<ValueType>& set);
    Set<ValueType>& addAll(std::initializer_list<ValueType> list);

    /*
     * Method: back
     * Usage: ValueType value = set.back();
     * ------------------------------------
     * Returns the last value in the set in the order established by the
     * <code>foreach</code> macro.  If the set is empty, generates an error.
     */
    ValueType back() const;

    /*
     * Method: clear
     * Usage: set.clear();
     * -------------------
     * Removes all elements from this set.
     */
    void clear();

    /*
     * Method: contains
     * Usage: if (set.contains(value)) ...
     * -----------------------------------
     * Returns <code>true</code> if the specified value is in this set.
     */
    bool contains(const ValueType& value) const;

    /*
     * Method: containsAll
     * Usage: if (set.containsAll(set2)) ...
     * -------------------------------------
     * Returns <code>true</code> if every value from the given other set
     * is also found in this set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Equivalent in behavior to isSupersetOf.
     */
    bool containsAll(const Set<ValueType>& set2) const;
    bool containsAll(std::initializer_list<ValueType> list) const;

    /*
     * Method: equals
     * Usage: if (set.equals(set2)) ...
     * --------------------------------
     * Returns <code>true</code> if this set contains exactly the same values
     * as the given other set.
     * Identical in behavior to the == operator.
     */
    bool equals(const Set<ValueType>& set2) const;
    
    /*
     * Method: first
     * Usage: ValueType value = set.first();
     * -------------------------------------
     * Returns the first value in the set in the order established by the
     * <code>foreach</code> macro.  If the set is empty, <code>first</code>
     * generates an error.
     * Equivalent to front.
     */
    ValueType first() const;

    /*
     * Method: front
     * Usage: ValueType value = set.front();
     * -------------------------------------
     * Returns the first value in the set in the order established by the
     * <code>foreach</code> macro.  If the set is empty, generates an error.
     * Equivalent to first.
     */
    ValueType front() const;

    /*
     * Method: insert
     * Usage: set.insert(value);
     * -------------------------
     * Adds an element to this set, if it was not already there.  This
     * method is exported for compatibility with the STL <code>set</code> class.
     */
    void insert(const ValueType& value);
    
    /*
     * Method: isEmpty
     * Usage: if (set.isEmpty()) ...
     * -----------------------------
     * Returns <code>true</code> if this set contains no elements.
     */
    bool isEmpty() const;

    /*
     * Method: isSubsetOf
     * Usage: if (set.isSubsetOf(set2)) ...
     * ------------------------------------
     * Implements the subset relation on sets.  It returns
     * <code>true</code> if every element of this set is
     * contained in <code>set2</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    bool isSubsetOf(const Set& set2) const;
    bool isSubsetOf(std::initializer_list<ValueType> list) const;

    /*
     * Method: isSupersetOf
     * Usage: if (set.isSupersetOf(set2)) ...
     * --------------------------------------
     * Implements the superset relation on sets.  It returns
     * <code>true</code> if every element of this set is
     * contained in <code>set2</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Equivalent in behavior to containsAll.
     */
    bool isSupersetOf(const Set& set2) const;
    bool isSupersetOf(std::initializer_list<ValueType> list) const;

    /*
     * Method: mapAll
     * Usage: set.mapAll(fn);
     * ----------------------
     * Iterates through the elements of the set and calls <code>fn(value)</code>
     * for each one.  The values are processed in ascending order, as defined
     * by the comparison function.
     */
    void mapAll(void (*fn)(ValueType)) const;
    void mapAll(void (*fn)(const ValueType&)) const;

    template <typename FunctorType>
    void mapAll(FunctorType fn) const;

    /*
     * Method: remove
     * Usage: set.remove(value);
     * -------------------------
     * Removes an element from this set.  If the value was not
     * contained in the set, no error is generated and the set
     * remains unchanged.
     */
    void remove(const ValueType& value);
    
    /*
     * Method: removeAll
     * Usage: set.removeAll(set2);
     * ---------------------------
     * Removes all elements of the given other set from this set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Returns a reference to this set.
     * Identical in behavior to the -= operator.
     */
    Set<ValueType>& removeAll(const Set<ValueType>& set);
    Set<ValueType>& removeAll(std::initializer_list<ValueType> list);

    /*
     * Method: retainAll
     * Usage: set.retainAll(set2);
     * ---------------------------
     * Removes all elements from this set that are not contained in the given
     * other set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Returns a reference to this set.
     * Identical in behavior to the *= operator.
     */
    Set<ValueType>& retainAll(const Set<ValueType>& set);
    Set<ValueType>& retainAll(std::initializer_list<ValueType> list);

    /*
     * Method: size
     * Usage: count = set.size();
     * --------------------------
     * Returns the number of elements in this set.
     */
    int size() const;
    
    /*
     * Method: toStlset
     * Usage: set<ValueType> set2 = set1.toStlSet();
     * ---------------------------------------------
     * Returns an STL set object with the same elements as this Set.
     */
    std::set<ValueType> toStlSet() const;

    /*
     * Method: toString
     * Usage: string str = set.toString();
     * -----------------------------------
     * Converts the set to a printable string representation.
     */
    std::string toString() const;

    /*
     * Operator: ==
     * Usage: set1 == set2
     * -------------------
     * Returns <code>true</code> if <code>set1</code> and <code>set2</code>
     * contain the same elements.
     */
    bool operator ==(const Set& set2) const;

    /*
     * Operator: !=
     * Usage: set1 != set2
     * -------------------
     * Returns <code>true</code> if <code>set1</code> and <code>set2</code>
     * are different.
     */
    bool operator !=(const Set& set2) const;

    /*
     * Operators: <, >, <=, >=
     * Usage: if (set1 <= set2) ...
     * ...
     * ----------------------------
     * Relational operators to compare two sets.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const Set& set2) const;
    bool operator <=(const Set& set2) const;
    bool operator >(const Set& set2) const;
    bool operator >=(const Set& set2) const;
    
    /*
     * Operator: +
     * Usage: set1 + set2
     *        set1 + element
     * ---------------------
     * Returns the union of sets <code>set1</code> and <code>set2</code>, which
     * is the set of elements that appear in at least one of the two sets.
     * You can also pass an initializer list such as {1, 2, 3}.
     * The right hand set can be replaced by an element of the value type, in
     * which case the operator returns a new set formed by adding that element.
     */
    Set operator +(const Set& set2) const;
    Set operator +(std::initializer_list<ValueType> list) const;
    Set operator +(const ValueType& element) const;

    /*
     * Operator: *
     * Usage: set1 * set2
     * ------------------
     * Returns the intersection of sets <code>set1</code> and <code>set2</code>,
     * which is the set of all elements that appear in both.
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    Set operator *(const Set& set2) const;
    Set operator *(std::initializer_list<ValueType> list) const;

    /*
     * Operator: -
     * Usage: set1 - set2
     *        set1 - element
     * ---------------------
     * Returns the difference of sets <code>set1</code> and <code>set2</code>,
     * which is all of the elements that appear in <code>set1</code> but
     * not <code>set2</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     * The right hand set can be replaced by an element of the value type, in
     * which case the operator returns a new set formed by removing that element.
     */
    Set operator -(const Set& set2) const;
    Set operator -(std::initializer_list<ValueType> list) const;
    Set operator -(const ValueType& element) const;

    /*
     * Operator: +=
     * Usage: set1 += set2;
     *        set1 += value;
     * ---------------------
     * Adds all of the elements from <code>set2</code> (or the single
     * specified value) to <code>set1</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     * As a convenience, the <code>Set</code> package also overloads the comma
     * operator so that it is possible to initialize a set like this:
     *
     *<pre>
     *    Set&lt;int&gt; digits;
     *    digits += 0, 1, 2, 3, 4, 5, 6, 7, 8, 9;
     *</pre>
     */
    Set& operator +=(const Set& set2);
    Set& operator +=(std::initializer_list<ValueType> list);
    Set& operator +=(const ValueType& value);

    /*
     * Operator: *=
     * Usage: set1 *= set2;
     * --------------------
     * Removes any elements from <code>set1</code> that are not present in
     * <code>set2</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    Set& operator *=(const Set& set2);
    Set& operator *=(std::initializer_list<ValueType> list);

    /*
     * Operator: -=
     * Usage: set1 -= set2;
     *        set1 -= value;
     * ---------------------
     * Removes the elements from <code>set2</code> (or the single
     * specified value) from <code>set1</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     * As a convenience, the <code>Set</code> package also overloads the comma
     * operator so that it is possible to remove multiple elements from a set
     * like this:
     *
     *<pre>
     *    digits -= 0, 2, 4, 6, 8;
     *</pre>
     *
     * which removes the values 0, 2, 4, 6, and 8 from the set
     * <code>digits</code>.
     */
    Set& operator -=(const Set& set2);
    Set& operator -=(std::initializer_list<ValueType> list);
    Set& operator -=(const ValueType& value);

    /*
     * Additional Set operations
     * -------------------------
     * In addition to the methods listed in this interface, the Set
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * The iteration forms process the Set in ascending order.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    Map<ValueType, bool> map;            /* Map used to store the element     */
    bool removeFlag;                     /* Flag to differentiate += and -=   */

public:
    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support the comma operator, deep copying, and iteration.
     * Including these methods in the public interface would make
     * that interface more difficult to understand for the average client.
     */

    /* Extended constructors */
    template <typename CompareType>
    explicit Set(CompareType cmp) : map(Map<ValueType, bool>(cmp)), removeFlag(false) {
        // Empty
    }

    Set& operator ,(const ValueType& value) {
        if (this->removeFlag) {
            this->remove(value);
        } else {
            this->add(value);
        }
        return *this;
    }

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public std::iterator<std::input_iterator_tag,ValueType> {
    private:
        typename Map<ValueType,bool>::iterator mapit;  /* Iterator for the map */

    public:
        iterator() {
            /* Empty */
        }

        iterator(typename Map<ValueType,bool>::iterator it) : mapit(it) {
            /* Empty */
        }

        iterator(const iterator& it) {
            mapit = it.mapit;
        }

        iterator& operator ++() {
            ++mapit;
            return *this;
        }

        iterator operator ++(int) {
            iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const iterator& rhs) {
            return mapit == rhs.mapit;
        }

        bool operator !=(const iterator& rhs) {
            return !(*this == rhs);
        }

        ValueType& operator *() {
            return *mapit;
        }

        ValueType* operator ->() {
            return &**this;
        }
    };

    iterator begin() const {
        return iterator(map.begin());
    }

    iterator end() const {
        return iterator(map.end());
    }
};

template <typename ValueType>
Set<ValueType>::Set() : removeFlag(false) {
    // empty
}

template <typename ValueType>
Set<ValueType>::Set(bool lessFunc(ValueType, ValueType))
        : map(lessFunc) {
    // empty
}

template <typename ValueType>
Set<ValueType>::Set(bool lessFunc(const ValueType&, const ValueType&))
        : map(lessFunc) {
    // empty
}

template <typename ValueType>
Set<ValueType>::Set(std::initializer_list<ValueType> list) {
    addAll(list);
}

template <typename ValueType>
Set<ValueType>::Set(std::initializer_list<ValueType> list, bool lessFunc(ValueType, ValueType))
        : map(lessFunc) {
    addAll(list);
}

template <typename ValueType>
Set<ValueType>::Set(std::initializer_list<ValueType> list, bool lessFunc(const ValueType&, const ValueType&))
        : map(lessFunc) {
    addAll(list);
}

template <typename ValueType>
Set<ValueType>::~Set() {
    /* Empty */
}

template <typename ValueType>
void Set<ValueType>::add(const ValueType& value) {
    map.put(value, true);
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::addAll(const Set& set2) {
    for (const ValueType& value : set2) {
        this->add(value);
    }
    return *this;
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::addAll(std::initializer_list<ValueType> list) {
    for (const ValueType& value : list) {
        this->add(value);
    }
    return *this;
}

template <typename ValueType>
ValueType Set<ValueType>::back() const {
    if (isEmpty()) {
        error("Set::back: set is empty");
    }
    return map.back();
}

template <typename ValueType>
void Set<ValueType>::clear() {
    map.clear();
}

template <typename ValueType>
bool Set<ValueType>::contains(const ValueType& value) const {
    return map.containsKey(value);
}

template <typename ValueType>
bool Set<ValueType>::containsAll(const Set<ValueType>& set2) const {
    for (const ValueType& value : set2) {
        if (!contains(value)) {
            return false;
        }
    }
    return true;
}

template <typename ValueType>
bool Set<ValueType>::containsAll(std::initializer_list<ValueType> list) const {
    for (const ValueType& value : list) {
        if (!contains(value)) {
            return false;
        }
    }
    return true;
}

template <typename ValueType>
bool Set<ValueType>::equals(const Set<ValueType>& set2) const {
    // optimization: if literally same set, stop
    if (this == &set2) {
        return true;
    }

    if (size() != set2.size()) {
        return false;
    }

    // BUGFIX: don't need to check set2.isSubsetOf(*this) because they are
    // the same size - credit to Stanford student G. Boullanger 2016/12/05
    return isSubsetOf(set2);
}

template <typename ValueType>
ValueType Set<ValueType>::first() const {
    if (isEmpty()) {
        error("Set::first: set is empty");
    }
    return *begin();
}

template <typename ValueType>
ValueType Set<ValueType>::front() const {
    if (isEmpty()) {
        error("Set::front: set is empty");
    }
    return map.front();
}

template <typename ValueType>
void Set<ValueType>::insert(const ValueType& value) {
    map.put(value, true);
}

template <typename ValueType>
bool Set<ValueType>::isEmpty() const {
    return map.isEmpty();
}

template <typename ValueType>
bool Set<ValueType>::isSubsetOf(const Set& set2) const {
    auto it = begin();
    auto end = this->end();
    while (it != end) {
        if (!set2.map.containsKey(*it)) {
            return false;
        }
        ++it;
    }
    return true;
}

template <typename ValueType>
bool Set<ValueType>::isSubsetOf(std::initializer_list<ValueType> list) const {
    Set<ValueType> set2(list);
    return isSubsetOf(set2);
}

template <typename ValueType>
bool Set<ValueType>::isSupersetOf(const Set& set2) const {
    return containsAll(set2);
}

template <typename ValueType>
bool Set<ValueType>::isSupersetOf(std::initializer_list<ValueType> list) const {
    return containsAll(list);
}

template <typename ValueType>
void Set<ValueType>::mapAll(void (*fn)(ValueType)) const {
    map.mapAll(fn);
}

template <typename ValueType>
void Set<ValueType>::mapAll(void (*fn)(const ValueType&)) const {
    map.mapAll(fn);
}

template <typename ValueType>
template <typename FunctorType>
void Set<ValueType>::mapAll(FunctorType fn) const {
    map.mapAll(fn);
}

template <typename ValueType>
void Set<ValueType>::remove(const ValueType& value) {
    map.remove(value);
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::removeAll(const Set& set2) {
    Vector<ValueType> toRemove;
    for (const ValueType& value : *this) {
        if (set2.map.containsKey(value)) {
            toRemove.add(value);
        }
    }
    for (const ValueType& value : toRemove) {
        remove(value);
    }
    return *this;
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::removeAll(std::initializer_list<ValueType> list) {
    for (const ValueType& value : list) {
        remove(value);
    }
    return *this;
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::retainAll(const Set& set2) {
    Vector<ValueType> toRemove;
    for (ValueType value : *this) {
        if (!set2.map.containsKey(value)) {
            toRemove.add(value);
        }
    }
    for (ValueType value : toRemove) {
        this->remove(value);
    }
    return *this;
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::retainAll(std::initializer_list<ValueType> list) {
    Set<ValueType> set2(list);
    return retainAll(set2);
}

template <typename ValueType>
int Set<ValueType>::size() const {
    return map.size();
}

template <typename ValueType>
std::set<ValueType> Set<ValueType>::toStlSet() const {
    std::set<ValueType> result;
    for (ValueType value : *this) {
        result.insert(value);
    }
    return result;
}

template <typename ValueType>
std::string Set<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

/*
 * Implementation notes: set operators
 * -----------------------------------
 * The implementations for the set operators use iteration to walk
 * over the elements in one or both sets.
 */
template <typename ValueType>
bool Set<ValueType>::operator ==(const Set& set2) const {
    return equals(set2);
}

template <typename ValueType>
bool Set<ValueType>::operator !=(const Set& set2) const {
    return !equals(set2);
}

template <typename ValueType>
bool Set<ValueType>::operator <(const Set& set2) const {
    return stanfordcpplib::collections::compare(*this, set2) < 0;
}

template <typename ValueType>
bool Set<ValueType>::operator <=(const Set& set2) const {
    return stanfordcpplib::collections::compare(*this, set2) <= 0;
}

template <typename ValueType>
bool Set<ValueType>::operator >(const Set& set2) const {
    return stanfordcpplib::collections::compare(*this, set2) > 0;
}

template <typename ValueType>
bool Set<ValueType>::operator >=(const Set& set2) const {
    return stanfordcpplib::collections::compare(*this, set2) >= 0;
}

template <typename ValueType>
Set<ValueType> Set<ValueType>::operator +(const Set& set2) const {
    Set<ValueType> set = *this;
    set.addAll(set2);
    return set;
}

template <typename ValueType>
Set<ValueType> Set<ValueType>::operator +(std::initializer_list<ValueType> list) const {
    Set<ValueType> set = *this;
    set.addAll(list);
    return set;
}

template <typename ValueType>
Set<ValueType> Set<ValueType>::operator +(const ValueType& element) const {
    Set<ValueType> set = *this;
    set.add(element);
    return set;
}

template <typename ValueType>
Set<ValueType> Set<ValueType>::operator *(const Set& set2) const {
    Set<ValueType> set = *this;
    return set.retainAll(set2);
}

template <typename ValueType>
Set<ValueType> Set<ValueType>::operator *(std::initializer_list<ValueType> list) const {
    Set<ValueType> set = *this;
    return set.retainAll(list);
}

template <typename ValueType>
Set<ValueType> Set<ValueType>::operator -(const Set& set2) const {
    Set<ValueType> set = *this;
    return set.removeAll(set2);
}

template <typename ValueType>
Set<ValueType> Set<ValueType>::operator -(std::initializer_list<ValueType> list) const {
    Set<ValueType> set = *this;
    return set.removeAll(list);
}

template <typename ValueType>
Set<ValueType> Set<ValueType>::operator -(const ValueType& element) const {
    Set<ValueType> set = *this;
    set.remove(element);
    return set;
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::operator +=(const Set& set2) {
    return addAll(set2);
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::operator +=(std::initializer_list<ValueType> list) {
    return addAll(list);
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::operator +=(const ValueType& value) {
    add(value);
    removeFlag = false;
    return *this;
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::operator *=(const Set& set2) {
    return retainAll(set2);
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::operator *=(std::initializer_list<ValueType> list) {
    return retainAll(list);
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::operator -=(const Set& set2) {
    return removeAll(set2);
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::operator -=(std::initializer_list<ValueType> list) {
    return removeAll(list);
}

template <typename ValueType>
Set<ValueType>& Set<ValueType>::operator -=(const ValueType& value) {
    remove(value);
    removeFlag = true;
    return *this;
}

template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const Set<ValueType>& set) {
    return stanfordcpplib::collections::writeCollection(os, set);
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, Set<ValueType>& set) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, set, element, /* descriptor */ "Set::operator >>");
}

/*
 * Template hash function for sets.
 * Requires the element type in the Set to have a hashCode function.
 */
template <typename T>
int hashCode(const Set<T>& set) {
    return stanfordcpplib::collections::hashCodeCollection(set);
}

/*
 * Function: randomElement
 * Usage: element = randomElement(set);
 * ------------------------------------
 * Returns a randomly chosen element of the given set.
 * Throws an error if the set is empty.
 */
template <typename T>
const T& randomElement(const Set<T>& set) {
    return stanfordcpplib::collections::randomElement(set);
}

#endif // _set_h

/////////////////////// END code extracted from StanfordCPPLib/collections/set.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/hashmap.h ///////////////////////
/*
 * File: hashmap.h
 * ---------------
 * This file exports the <code>HashMap</code> class, which stores
 * a set of <i>key</i>-<i>value</i> pairs.
 * 
 * @version 2018/03/10
 * - added methods front, back
 * @version 2017/11/30
 * - bug fix for iterator version checking support
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2016/10/14
 * - modified floating-point equality tests to use floatingPointEqual function
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/10
 * - added support for std initializer_list usage, such as
 *   {{"a", 1}, {"b", 2}, {"c", 3}} in constructor, putAll, removeAll, retainAll,
 *   operators +, +=, -, -=, *, *=
 * - added addAll method
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * - fixed bug where string quotes would not show when map was printed
 * @version 2015/06/19
 * - fixed deepCopy code that was causing copies to have different hash code than
 *   the original they were copied from (credit to SL Wen Zhang for finding the bug)
 * @version 2014/11/13
 * - added add() method as synonym for put()
 * - added template hashCode function
 * - moved hashCode functions to hashcode.h/cpp
 * @version 2014/10/29
 * - moved hashCode functions out to hashcode.h
 * @version 2014/10/10
 * - added comparison operators ==, !=
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _hashmap_h
#define _hashmap_h

#include <cstdlib>
#include <initializer_list>
#include <string>
#include <utility>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: HashMap<KeyType,ValueType>
 * ---------------------------------
 * This class implements an efficient association between
 * <b><i>keys</i></b> and <b><i>values</i></b>.  This class is
 * identical to the <a href="Map-class.html"><code>Map</code></a> class
 * except for the fact that it uses a hash table as its underlying
 * representation.  Although the <code>HashMap</code> class operates in
 * constant time, the iterator for <code>HashMap</code> returns the
 * values in a seemingly random order.
 */
template <typename KeyType, typename ValueType>
class HashMap {
public:
    /*
     * Constructor: HashMap
     * Usage: HashMap<KeyType,ValueType> map;
     * --------------------------------------
     * Initializes a new empty map that associates keys and values of
     * the specified types.  The type used for the key must define
     * the <code>==</code> operator, and there must be a free function
     * with the following signature:
     *
     *<pre>
     *    int hashCode(KeyType key);
     *</pre>
     *
     * that returns a positive integer determined by the key.  This interface
     * exports <code>hashCode</code> functions for <code>string</code> and
     * the C++ primitive types.
     */
    HashMap();

    /*
     * Constructor: HashMap
     * Usage: HashMap<ValueType> map {{"a", 1}, {"b", 2}, {"c", 3}};
     * -------------------------------------------------------------
     * Initializes a new map that stores the given pairs.
     * Note that the pairs are stored in unpredictable order internally and not
     * necessarily the order in which they are written in the initializer list.
     */
    HashMap(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Destructor: ~HashMap
     * --------------------
     * Frees any heap storage associated with this map.
     */
    virtual ~HashMap();

    /*
     * Method: add
     * Usage: map.add(key, value);
     * ---------------------------
     * Associates <code>key</code> with <code>value</code> in this map.
     * A synonym for the put method.
     */
    void add(const KeyType& key, const ValueType& value);

    /*
     * Method: addAll
     * Usage: map.addAll(map2);
     * ------------------------
     * Adds all key/value pairs from the given map to this map.
     * If both maps contain a pair for the same key, the one from map2 will
     * replace the one from this map.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     * Identical in behavior to putAll.
     */
    HashMap& addAll(const HashMap& map2);
    HashMap& addAll(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Method: back
     * Usage: KeyType value = map.back();
     * ----------------------------------
     * Returns the last key in the map in the order established by the
     * <code>foreach</code> macro.
     * Note that since the keys are stored in an unpredictable order,
     * this is not necessarily equal to the "largest" key value in any particular
     * sorting order; it is just the key that would happen to be emitted last
     * from a for-each loop.
     * If the map is empty, generates an error.
     */
    KeyType back() const;

    /*
     * Method: clear
     * Usage: map.clear();
     * -------------------
     * Removes all entries from this map.
     */
    void clear();

    /*
     * Method: containsKey
     * Usage: if (map.containsKey(key)) ...
     * ------------------------------------
     * Returns <code>true</code> if there is an entry for <code>key</code>
     * in this map.
     */
    bool containsKey(const KeyType& key) const;

    /*
     * Method: equals
     * Usage: if (map.equals(map2)) ...
     * --------------------------------
     * Returns <code>true</code> if the two maps contain exactly the same
     * key/value pairs, and <code>false</code> otherwise.
     */
    bool equals(const HashMap& map2) const;

    /*
     * Method: front
     * Usage: KeyType value = map.front();
     * -----------------------------------
     * Returns the first key in the map in the order established by the
     * <code>foreach</code> macro.
     * Note that since the keys are stored in an unpredictable order,
     * this is not necessarily equal to the "smallest" key value in any particular
     * sorting order; it is just the key that would happen to be emitted first
     * from a for-each loop.
     * If the map is empty, generates an error.
     */
    KeyType front() const;

    /*
     * Method: get
     * Usage: ValueType value = map.get(key);
     * --------------------------------------
     * Returns the value associated with <code>key</code> in this map.
     * If <code>key</code> is not found, <code>get</code> returns the
     * default value for <code>ValueType</code>.
     */
    ValueType get(const KeyType& key) const;

    /*
     * Method: isEmpty
     * Usage: if (map.isEmpty()) ...
     * -----------------------------
     * Returns <code>true</code> if this map contains no entries.
     */
    bool isEmpty() const;
    
    /*
     * Method: keys
     * Usage: Vector<KeyType> keys = map.keys();
     * -----------------------------------------
     * Returns a collection containing all keys in this map.
     * Note that this implementation makes a deep copy of the keys,
     * so it is inefficient to call on large maps.
     */
    Vector<KeyType> keys() const;

    /*
     * Method: mapAll
     * Usage: map.mapAll(fn);
     * ----------------------
     * Iterates through the map entries and calls <code>fn(key, value)</code>
     * for each one.  The keys are processed in an undetermined order.
     */
    void mapAll(void (*fn)(KeyType, ValueType)) const;
    void mapAll(void (*fn)(const KeyType&, const ValueType&)) const;
    
    template <typename FunctorType>
    void mapAll(FunctorType fn) const;

    /*
     * Method: put
     * Usage: map.put(key, value);
     * ---------------------------
     * Associates <code>key</code> with <code>value</code> in this map.
     * Any previous value associated with <code>key</code> is replaced
     * by the new value.
     */
    void put(const KeyType& key, const ValueType& value);

    /*
     * Method: putAll
     * Usage: map.putAll(map2);
     * ---------------------------
     * Adds all key/value pairs from the given map to this map.
     * If both maps contain a pair for the same key, the one from map2 will
     * replace the one from this map.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     */
    HashMap& putAll(const HashMap& map2);
    HashMap& putAll(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Method: remove
     * Usage: map.remove(key);
     * -----------------------
     * Removes any entry for <code>key</code> from this map.
     * If the given key is not found, has no effect.
     */
    void remove(const KeyType& key);

    /*
     * Method: removeAll
     * Usage: map.removeAll(map2);
     * ---------------------------
     * Removes all key/value pairs from this map that are contained in the given map.
     * If both maps contain the same key but it maps to different values, that
     * mapping will not be removed.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     */
    HashMap& removeAll(const HashMap& map2);
    HashMap& removeAll(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Method: retainAll
     * Usage: map.retainAll(map2);
     * ---------------------------
     * Removes all key/value pairs from this map that are not contained in the given map.
     * If both maps contain the same key but it maps to different values, that
     * mapping will be removed.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     */
    HashMap& retainAll(const HashMap& map2);
    HashMap& retainAll(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Method: size
     * Usage: int nEntries = map.size();
     * ---------------------------------
     * Returns the number of entries in this map.
     */
    int size() const;

    /*
     * Method: toString
     * Usage: string str = map.toString();
     * -----------------------------------
     * Converts the map to a printable string representation.
     */
    std::string toString() const;

    /*
     * Method: values
     * Usage: Vector<ValueType> values = map.values();
     * -----------------------------------------------
     * Returns a collection containing all values in this map.
     * Note that this implementation makes a deep copy of the values,
     * so it is inefficient to call on large maps.
     */
    Vector<ValueType> values() const;

    /*
     * Operator: []
     * Usage: map[key]
     * ---------------
     * Selects the value associated with <code>key</code>.  This syntax
     * makes it easy to think of a map as an "associative array"
     * indexed by the key type.  If <code>key</code> is already present
     * in the map, this function returns a reference to its associated
     * value.  If key is not present in the map, a new entry is created
     * whose value is set to the default for the value type.
     */
    ValueType& operator [](const KeyType& key);
    ValueType operator [](const KeyType& key) const;

    /*
     * Operator: ==
     * Usage: if (map1 == map2) ...
     * ----------------------------
     * Compares two maps for equality.
     */
    bool operator ==(const HashMap& map2) const;

    /*
     * Operator: !=
     * Usage: if (map1 != map2) ...
     * ----------------------------
     * Compares two maps for inequality.
     */
    bool operator !=(const HashMap& map2) const;

    /*
     * Operator: +
     * Usage: map1 + map2
     * ------------------
     * Returns the union of the two maps, equivalent to a copy of the first map
     * with addAll called on it passing the second map as a parameter.
     * If the two maps both contain a mapping for the same key, the mapping
     * from the second map is favored.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    HashMap operator +(const HashMap& map2) const;
    HashMap operator +(std::initializer_list<std::pair<KeyType, ValueType> > list) const;

    /*
     * Operator: +=
     * Usage: map1 += map2;
     * --------------------
     * Adds all key/value pairs from the given map to this map.
     * Equivalent to calling addAll(map2).
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    HashMap& operator +=(const HashMap& map2);
    HashMap& operator +=(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Operator: -
     * Usage: map1 - map2
     * ------------------
     * Returns the difference of the two maps, equivalent to a copy of the first map
     * with removeAll called on it passing the second map as a parameter.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    HashMap operator -(const HashMap& map2) const;
    HashMap operator -(std::initializer_list<std::pair<KeyType, ValueType> > list) const;

    /*
     * Operator: -=
     * Usage: map1 -= map2;
     * --------------------
     * Removes all key/value pairs from the given map to this map.
     * Equivalent to calling removeAll(map2).
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    HashMap& operator -=(const HashMap& map2);
    HashMap& operator -=(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Operator: *
     * Usage: map1 * map2
     * ------------------
     * Returns the intersection of the two maps, equivalent to a copy of the first map
     * with retainAll called on it passing the second map as a parameter.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    HashMap operator *(const HashMap& map2) const;
    HashMap operator *(std::initializer_list<std::pair<KeyType, ValueType> > list) const;

    /*
     * Operator: *=
     * Usage: map1 *= map2;
     * ---------------------
     * Removes all key/value pairs that are not found in the given map from this map.
     * Equivalent to calling retainAll(map2).
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    HashMap& operator *=(const HashMap& map2);
    HashMap& operator *=(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Additional HashMap operations
     * -----------------------------
     * In addition to the methods listed in this interface, the HashMap
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * The HashMap class makes no guarantees about the order of iteration.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes:
     * ---------------------
     * The HashMap class is represented using a hash table that uses
     * bucket chaining to resolve collisions.
    */
private:
    /* Constant definitions */
    static const int INITIAL_BUCKET_COUNT = 101;
    static const int MAX_LOAD_PERCENTAGE = 70;

    /* Type definition for cells in the bucket chain */
    struct Cell {
        KeyType key;
        ValueType value;
        Cell* next;
    };

    /* Instance variables */
    Vector<Cell*> buckets;
    int nBuckets;
    int numEntries;
    unsigned int m_version = 0; // structure version for detecting invalid iterators

    /* Private methods */

    /*
     * Private method: createBuckets
     * Usage: createBuckets(nBuckets);
     * -------------------------------
     * Sets up the vector of buckets to have nBuckets entries, each null.
     * If asked to make empty vector, makes one bucket just to simplify
     * handling elsewhere.
     */
    void createBuckets(int nBuckets) {
        if (nBuckets == 0) {
            nBuckets = 1;
        }
        buckets = Vector<Cell*>(nBuckets, nullptr);
        this->nBuckets = nBuckets;
        numEntries = 0;
    }

    /*
     * Private method: deleteBuckets
     * Usage: deleteBuckets(buckets);
     * ------------------------------
     * Deletes all the cells in the linked lists contained in vector.
     */
    void deleteBuckets(Vector<Cell*>& buckets) {
        for (int i = 0; i < buckets.size(); i++) {
            Cell* cp = buckets[i];
            while (cp) {
                Cell* np = cp->next;
                delete cp;
                cp = np;
            }
            buckets[i] = nullptr;
        }
    }

    /*
     * Private method: expandAndRehash
     * Usage: expandAndRehash();
     * -------------------------
     * This method is used to increase the number of buckets in the map
     * and then rehashes all existing entries and adds them into new buckets.
     * This operation is used when the load factor (i.e. the number of cells
     * per bucket) has increased enough to warrant this O(N) operation to
     * enlarge and redistribute the entries.
     */
    void expandAndRehash() {
        Vector<Cell*> oldBuckets = buckets;
        createBuckets(oldBuckets.size() * 2 + 1);
        for (int i = 0; i < oldBuckets.size(); i++) {
            for (Cell* cp = oldBuckets[i]; cp != nullptr; cp = cp->next) {
                put(cp->key, cp->value);
            }
        }
        deleteBuckets(oldBuckets);
    }

    /*
     * Private method: findCell
     * Usage: Cell* cp = findCell(bucket, key);
     *        Cell* cp = findCell(bucket, key, parent);
     * ------------------------------------------------
     * Finds a cell in the chain for the specified bucket that matches key.
     * If a match is found, the return value is a pointer to the cell containing
     * the matching key.  If no match is found, the function returns nullptr.
     * If the optional third argument is supplied, it is filled in with the
     * cell preceding the matching cell to allow the client to splice out
     * the target cell in the delete call.  If parent is null, it indicates
     * that the cell is the first cell in the bucket chain.
     */
    Cell* findCell(int bucket, const KeyType& key) const {
        Cell *dummy;
        return findCell(bucket, key, dummy);
    }

    Cell* findCell(int bucket, const KeyType& key, Cell*& parent) const {
        parent = nullptr;
        Cell* cp = buckets.get(bucket);
        while (cp && !(key == cp->key)) {
            parent = cp;
            cp = cp->next;
        }
        return cp;
    }

    void deepCopy(const HashMap& src) {
        createBuckets(src.nBuckets);
        for (int i = 0; i < src.nBuckets; i++) {
            // BUGFIX: was just calling put(), which reversed the chains;
            // now deep-copy the chains exactly as they were to preserve hashcode
            Cell* endOfChain = nullptr;
            for (Cell* cp = src.buckets.get(i); cp != nullptr; cp = cp->next) {
                // put(cp->key, cp->value);
                
                // copy the cell and put at end of bucket list
                Cell* copy = new Cell();
                copy->key = cp->key;
                copy->value = cp->value;
                copy->next = nullptr;
                if (!endOfChain) {
                    // first node in bucket
                    buckets.set(i, copy);
                } else {
                    // not first node; put after existing node
                    endOfChain->next = copy;
                    endOfChain = copy;
                }
                endOfChain = copy;
                numEntries++;
            }
        }
        m_version++;
    }

public:
    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods
     * in the public interface would make that interface more
     * difficult to understand for the average client.
     */

    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return maps by value
     * and assign from one map to another.
     */
    HashMap& operator =(const HashMap& src) {
        if (this != &src) {
            clear();
            deepCopy(src);
        }
        return *this;
    }

    HashMap(const HashMap& src) {
        deepCopy(src);
    }

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public std::iterator<std::input_iterator_tag, KeyType> {
    private:
        const HashMap* mp;           /* Pointer to the map           */
        int bucket;                  /* Index of current bucket      */
        unsigned int itr_version;    /* Version for checking for modification */
        Cell* cp;                    /* Current cell in bucket chain */

    public:
        iterator()
                : mp(nullptr),
                  bucket(0),
                  itr_version(0),
                  cp(nullptr) {
            // empty
        }

        iterator(const HashMap* mp, bool end)
                : mp(mp),
                  bucket(0),
                  itr_version(0),
                  cp(nullptr) {
            if (mp) {
                itr_version = mp->version();
            }
            if (end) {
                bucket = mp->nBuckets;
            } else {
                bucket = 0;
                cp = mp->buckets.get(bucket);
                while (!cp && ++bucket < mp->nBuckets) {
                    cp = mp->buckets.get(bucket);
                }
            }
        }

        iterator(const iterator& it)
                : mp(it.mp),
                  bucket(it.bucket),
                  itr_version(it.itr_version),
                  cp(it.cp) {
            // empty
        }

        iterator& operator ++() {
            stanfordcpplib::collections::checkVersion(*mp, *this);
            cp = cp->next;
            while (!cp && ++bucket < mp->nBuckets) {
                cp = mp->buckets.get(bucket);
            }
            return *this;
        }

        iterator operator ++(int) {
            stanfordcpplib::collections::checkVersion(*mp, *this);
            iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const iterator& rhs) {
            return mp == rhs.mp && bucket == rhs.bucket && cp == rhs.cp;
        }

        bool operator !=(const iterator& rhs) {
            return !(*this == rhs);
        }

        KeyType& operator *() {
            stanfordcpplib::collections::checkVersion(*mp, *this);
            return cp->key;
        }

        KeyType* operator ->() {
            stanfordcpplib::collections::checkVersion(*mp, *this);
            return &cp->key;
        }

        unsigned int version() const {
            return itr_version;
        }

        friend class HashMap;
    };

    /*
     * Returns an iterator positioned at the first key of the map.
     */
    iterator begin() const {
        return iterator(this, /* end */ false);
    }

    /*
     * Returns an iterator positioned at the last key of the map.
     */
    iterator end() const {
        return iterator(this, /* end */ true);
    }

    /*
     * Returns the internal version of this collection.
     * This is used to check for invalid iterators and issue error messages.
     */
    unsigned int version() const {
        return m_version;
    }
};

/*
 * Implementation notes: HashMap class
 * -----------------------------------
 * In this map implementation, the entries are stored in a hashtable.
 * The hashtable keeps a vector of "buckets", where each bucket is a
 * linked list of elements that share the same hash code (i.e. hash
 * collisions are resolved by chaining). The buckets are dynamically
 * allocated so that we can change the the number of buckets (rehash)
 * when the load factor becomes too high. The map should provide O(1)
 * performance on the put/remove/get operations.
 */
template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>::HashMap() {
    createBuckets(INITIAL_BUCKET_COUNT);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>::HashMap(std::initializer_list<std::pair<KeyType, ValueType> > list) {
    createBuckets(INITIAL_BUCKET_COUNT);
    putAll(list);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>::~HashMap() {
    deleteBuckets(buckets);
    numEntries = 0;
}

template <typename KeyType, typename ValueType>
void HashMap<KeyType, ValueType>::add(const KeyType& key, const ValueType& value) {
    put(key, value);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::addAll(const HashMap& map2) {
    return putAll(map2);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::addAll(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    return putAll(list);
}

template <typename KeyType, typename ValueType>
KeyType HashMap<KeyType, ValueType>::back() const {
    if (isEmpty()) {
        error("HashMap::back: map is empty");
    }

    // find last non-null bucket
    Cell* cell = nullptr;
    for (int i = buckets.size() - 1; i >= 0; i--) {
        cell = buckets[i];
        if (cell) {
            // find last non-null cell within bucket
            while (cell->next) {
                cell = cell->next;
            }
            return cell->key;
        }
    }

    // we should never get here
    error("HashMap::back: never found a non-empty cell bucket");
    return cell->key;
}

template <typename KeyType, typename ValueType>
void HashMap<KeyType, ValueType>::clear() {
    deleteBuckets(buckets);
    numEntries = 0;
    m_version++;
}

template <typename KeyType, typename ValueType>
bool HashMap<KeyType, ValueType>::containsKey(const KeyType& key) const {
    return findCell(hashCode(key) % nBuckets, key) != nullptr;
}

template <typename KeyType, typename ValueType>
bool HashMap<KeyType, ValueType>::equals(const HashMap<KeyType, ValueType>& map2) const {
    return stanfordcpplib::collections::equalsMap(*this, map2);
}

template <typename KeyType, typename ValueType>
KeyType HashMap<KeyType, ValueType>::front() const {
    if (isEmpty()) {
        error("HashMap::front: map is empty");
    }
    return *begin();
}

template <typename KeyType, typename ValueType>
ValueType HashMap<KeyType, ValueType>::get(const KeyType& key) const {
    Cell* cp = findCell(hashCode(key) % nBuckets, key);
    if (!cp) {
        return ValueType();
    }
    return cp->value;
}

template <typename KeyType, typename ValueType>
bool HashMap<KeyType, ValueType>::isEmpty() const {
    return size() == 0;
}

template <typename KeyType, typename ValueType>
Vector<KeyType> HashMap<KeyType, ValueType>::keys() const {
    Vector<KeyType> keyset;
    for (const KeyType& key : *this) {
        keyset.add(key);
    }
    return keyset;
}

template <typename KeyType, typename ValueType>
void HashMap<KeyType, ValueType>::mapAll(void (*fn)(KeyType, ValueType)) const {
    for (int i = 0; i < buckets.size(); i++) {
        for (Cell* cp = buckets.get(i); cp != nullptr; cp = cp->next) {
            fn(cp->key, cp->value);
        }
    }
}

template <typename KeyType, typename ValueType>
void HashMap<KeyType, ValueType>::mapAll(void (*fn)(const KeyType&,
                                                   const ValueType&)) const {
    for (int i = 0; i < buckets.size(); i++) {
        for (Cell* cp = buckets.get(i); cp != nullptr; cp = cp->next) {
            fn(cp->key, cp->value);
        }
    }
}

template <typename KeyType, typename ValueType>
template <typename FunctorType>
void HashMap<KeyType, ValueType>::mapAll(FunctorType fn) const {
    for (int i = 0; i < buckets.size(); i++) {
        for (Cell* cp = buckets.get(i); cp != nullptr; cp = cp->next) {
            fn(cp->key, cp->value);
        }
    }
}

template <typename KeyType, typename ValueType>
void HashMap<KeyType, ValueType>::put(const KeyType& key, const ValueType& value) {
    (*this)[key] = value;
    m_version++;
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::putAll(const HashMap& map2) {
    for (const KeyType& key : map2) {
        put(key, map2.get(key));
    }
    return *this;
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::putAll(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    for (const std::pair<KeyType, ValueType>& pair : list) {
        put(pair.first, pair.second);
    }
    return *this;
}

template <typename KeyType, typename ValueType>
void HashMap<KeyType, ValueType>::remove(const KeyType& key) {
    int bucket = hashCode(key) % nBuckets;
    Cell *parent;
    Cell* cp = findCell(bucket, key, parent);
    if (cp) {
        if (!parent) {
            buckets[bucket] = cp->next;
        } else {
            parent->next = cp->next;
        }
        delete cp;
        numEntries--;
        m_version++;
    }
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::removeAll(const HashMap& map2) {
    for (const KeyType& key : map2) {
        if (containsKey(key) && get(key) == map2.get(key)) {
            remove(key);
        }
    }
    return *this;
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::removeAll(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    for (const std::pair<KeyType, ValueType>& pair : list) {
        if (containsKey(pair.first) && get(pair.first) == pair.second) {
            remove(pair.first);
        }
    }
    return *this;
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::retainAll(const HashMap& map2) {
    Vector<KeyType> toRemove;
    for (const KeyType& key : *this) {
        if (!map2.containsKey(key) || get(key) != map2.get(key)) {
            toRemove.add(key);
        }
    }
    for (const KeyType& key : toRemove) {
        remove(key);
    }
    return *this;
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::retainAll(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    HashMap<KeyType, ValueType> map2(list);
    retainAll(map2);
    return *this;
}

template <typename KeyType, typename ValueType>
int HashMap<KeyType, ValueType>::size() const {
    return numEntries;
}

template <typename KeyType, typename ValueType>
std::string HashMap<KeyType, ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename KeyType, typename ValueType>
Vector<ValueType> HashMap<KeyType, ValueType>::values() const {
    Vector<ValueType> values;
    for (const KeyType& key : *this) {
        values.add(this->get(key));
    }
    return values;
}

template <typename KeyType, typename ValueType>
ValueType& HashMap<KeyType, ValueType>::operator [](const KeyType& key) {
    int bucket = hashCode(key) % nBuckets;
    Cell* cp = findCell(bucket, key);
    if (!cp) {
        if (numEntries > MAX_LOAD_PERCENTAGE * nBuckets / 100.0) {
            expandAndRehash();
            bucket = hashCode(key) % nBuckets;
        }
        cp = new Cell;
        cp->key = key;
        cp->value = ValueType();
        cp->next = buckets[bucket];
        buckets[bucket] = cp;
        numEntries++;
        m_version++;
    }
    return cp->value;
}

template <typename KeyType, typename ValueType>
ValueType HashMap<KeyType, ValueType>::operator [](const KeyType& key) const {
    return get(key);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType> HashMap<KeyType, ValueType>::operator +(const HashMap& map2) const {
    HashMap<KeyType, ValueType> result = *this;
    return result.putAll(map2);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType> HashMap<KeyType, ValueType>::operator +(
        std::initializer_list<std::pair<KeyType, ValueType> > list) const {
    HashMap<KeyType, ValueType> result = *this;
    return result.putAll(list);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::operator +=(const HashMap& map2) {
    return putAll(map2);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::operator +=(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    return putAll(list);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType> HashMap<KeyType, ValueType>::operator -(const HashMap& map2) const {
    HashMap<KeyType, ValueType> result = *this;
    return result.removeAll(map2);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType> HashMap<KeyType, ValueType>::operator -(
        std::initializer_list<std::pair<KeyType, ValueType> > list) const {
    HashMap<KeyType, ValueType> result = *this;
    return result.removeAll(list);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::operator -=(const HashMap& map2) {
    return removeAll(map2);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::operator -=(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    return removeAll(list);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType> HashMap<KeyType, ValueType>::operator *(const HashMap& map2) const {
    HashMap<KeyType, ValueType> result = *this;
    return result.retainAll(map2);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType> HashMap<KeyType, ValueType>::operator *(
        std::initializer_list<std::pair<KeyType, ValueType> > list) const {
    HashMap<KeyType, ValueType> result = *this;
    return result.retainAll(list);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::operator *=(const HashMap& map2) {
    return retainAll(map2);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::operator *=(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    return retainAll(list);
}

template <typename KeyType, typename ValueType>
bool HashMap<KeyType, ValueType>::operator ==(const HashMap& map2) const {
    return equals(map2);
}

template <typename KeyType, typename ValueType>
bool HashMap<KeyType, ValueType>::operator !=(const HashMap& map2) const {
    return !equals(map2);   // BUGFIX 2016/09/24
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename KeyType, typename ValueType>
std::ostream& operator <<(std::ostream& os,
                          const HashMap<KeyType, ValueType>& map) {
    return stanfordcpplib::collections::writeMap(os, map);
}

template <typename KeyType, typename ValueType>
std::istream& operator >>(std::istream& is,
                          HashMap<KeyType, ValueType>& map) {
    KeyType key;
    ValueType value;
    return stanfordcpplib::collections::readMap(is, map, key, value, /* descriptor */ std::string("HashMap::operator >>"));
}

/*
 * Template hash function for hash maps.
 * Requires the key and value types in the HashMap to have a hashCode function.
 */
template <typename K, typename V>
int hashCode(const HashMap<K, V>& map) {
    return stanfordcpplib::collections::hashCodeMap(map, /* orderMatters */ false);
}

/*
 * Function: randomKey
 * Usage: element = randomKey(map);
 * --------------------------------
 * Returns a randomly chosen key of the given map.
 * Throws an error if the map is empty.
 */
template <typename K, typename V>
const K& randomKey(const HashMap<K, V>& map) {
    if (map.isEmpty()) {
        error("randomKey: empty hash map was passed");
    }
    int index = randomInteger(0, map.size() - 1);
    int i = 0;
    for (const K& key : map) {
        if (i == index) {
            return key;
        }
        i++;
    }
    
    // this code will never be reached
    static Vector<K> v = map.keys();
    return v[0];
}

#endif // _hashmap_h

/////////////////////// END code extracted from StanfordCPPLib/collections/hashmap.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/hashset.h ///////////////////////
/*
 * File: hashset.h
 * ---------------
 * This file exports the <code>HashSet</code> class, which
 * implements an efficient abstraction for storing sets of values.
 * 
 * @version 2018/03/10
 * - added methods front, back
 * @version 2016/12/09
 * - added iterator version checking support (implicitly via HashMap)
 * @version 2016/12/06
 * - slight speedup bug fix in equals() method
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/11
 * - added containsAll, isSupersetOf methods
 * @version 2016/08/10
 * - added support for std initializer_list usage, such as {1, 2, 3}
 *   in constructor, addAll, containsAll, isSubsetOf, isSupersetOf, removeAll,
 *   retainAll, and operators +, +=, -, -=, *, *=
 * - bug fix in hashCode function
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added template hashCode function
 * @version 2014/10/10
 * - removed foreach patch
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _hashset_h
#define _hashset_h

#include <initializer_list>
#include <iostream>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: HashSet<ValueType>
 * -------------------------
 * This class implements an efficient abstraction for storing sets
 * of distinct elements.  This class is identical to the <code>Set</code>
 * class except for the fact that it uses a hash table as its underlying
 * representation.  The advantage of the <code>HashSet</code> class is that
 * it operates in constant time, as opposed to the <i>O</i>(log <i>N</i>)
 * time for the <code>Set</code> class.  The disadvantage of
 * <code>HashSet</code> is that iterators return the values in a
 * seemingly random order.
 */
template <typename ValueType>
class HashSet {
public:
    /*
     * Constructor: HashSet
     * Usage: HashSet<ValueType> set;
     * ------------------------------
     * Initializes an empty set of the specified element type.
     */
    HashSet();

    /*
     * Constructor: HashSet
     * Usage: HashSet<ValueType> set {1, 2, 3};
     * ----------------------------------------
     * Initializes a new set that stores the given elements.
     * Note that the elements are stored in unpredictable order internally and not
     * necessarily the order in which they are written in the initializer list.
     */
    HashSet(std::initializer_list<ValueType> list);

    /*
     * Destructor: ~HashSet
     * --------------------
     * Frees any heap storage associated with this set.
     */
    virtual ~HashSet();

    /*
     * Method: add
     * Usage: set.add(value);
     * ----------------------
     * Adds an element to this set, if it was not already there.  For
     * compatibility with the STL <code>set</code> class, this method
     * is also exported as <code>insert</code>.
     */
    void add(const ValueType& value);
    
    /*
     * Method: addAll
     * Usage: set.addAll(set2);
     * ----------------------
     * Adds all elements of the given other set to this set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Returns a reference to this set.
     * Identical in behavior to the += operator.
     */
    HashSet<ValueType>& addAll(const HashSet<ValueType>& set);
    HashSet<ValueType>& addAll(std::initializer_list<ValueType> list);

    /*
     * Method: back
     * Usage: ValueType value = set.back();
     * ------------------------------------
     * Returns the last value in the set in the order established by the
     * <code>foreach</code> macro.
     * Note that since the values are stored in an unpredictable order,
     * this is not necessarily equal to the "largest" value in any particular
     * sorting order; it is just the value that would happen to be emitted last
     * from a for-each loop.
     * If the set is empty, generates an error.
     */
    ValueType back() const;

    /*
     * Method: clear
     * Usage: set.clear();
     * -------------------
     * Removes all elements from this set.
     */
    void clear();
    
    /*
     * Method: contains
     * Usage: if (set.contains(value)) ...
     * -----------------------------------
     * Returns <code>true</code> if the specified value is in this set.
     */
    bool contains(const ValueType& value) const;

    /*
     * Method: containsAll
     * Usage: if (set.containsAll(set2)) ...
     * -------------------------------------
     * Returns <code>true</code> if every value from the given other set
     * is also found in this set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Equivalent in behavior to isSupersetOf.
     */
    bool containsAll(const HashSet<ValueType>& set2) const;
    bool containsAll(std::initializer_list<ValueType> list) const;

    /*
     * Method: equals
     * Usage: if (set.equals(set2)) ...
     * -----------------------------------
     * Returns <code>true</code> if this set contains exactly the same values
     * as the given other set.
     * Identical in behavior to the == operator.
     */
    bool equals(const HashSet<ValueType>& set2) const;
    
    /*
     * Method: first
     * Usage: ValueType value = set.first();
     * -------------------------------------
     * Returns the first value in the set in the order established by the
     * <code>foreach</code> macro.  If the set is empty, <code>first</code>
     * generates an error.
     */
    ValueType first() const;

    /*
     * Method: front
     * Usage: ValueType value = set.front();
     * ------------------------------------
     * Returns the last value in the set in the order established by the
     * <code>foreach</code> macro.
     * Note that since the values are stored in an unpredictable order,
     * this is not necessarily equal to the "largest" value in any particular
     * sorting order; it is just the value that would happen to be emitted last
     * from a for-each loop.
     * If the set is empty, generates an error.
     * Equivalent to first.
     */
    ValueType front() const;

    /*
     * Method: insert
     * Usage: set.insert(value);
     * -------------------------
     * Adds an element to this set, if it was not already there.  This
     * method is exported for compatibility with the STL <code>set</code> class.
     */
    void insert(const ValueType& value);

    /*
     * Method: isEmpty
     * Usage: if (set.isEmpty()) ...
     * -----------------------------
     * Returns <code>true</code> if this set contains no elements.
     */
    bool isEmpty() const;
    
    /*
     * Method: isSubsetOf
     * Usage: if (set.isSubsetOf(set2)) ...
     * ------------------------------------
     * Implements the subset relation on sets.  It returns
     * <code>true</code> if every element of this set is
     * contained in <code>set2</code>.
     * Note that this will be true if the sets are equal.
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    bool isSubsetOf(const HashSet& set2) const;
    bool isSubsetOf(std::initializer_list<ValueType> list) const;

    /*
     * Method: isSupersetOf
     * Usage: if (set.isSupersetOf(set2)) ...
     * --------------------------------------
     * Implements the superset relation on sets.  It returns
     * <code>true</code> if every element of this set is
     * contained in <code>set2</code>.
     * Note that this will be true if the sets are equal.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Equivalent in behavior to containsAll.
     */
    bool isSupersetOf(const HashSet& set2) const;
    bool isSupersetOf(std::initializer_list<ValueType> list) const;

    /*
     * Method: mapAll
     * Usage: set.mapAll(fn);
     * ----------------------
     * Iterates through the elements of the set and calls <code>fn(value)</code>
     * for each one.  The values are processed in ascending order, as defined
     * by the comparison function.
     */
    void mapAll(void (*fn)(ValueType)) const;
    void mapAll(void (*fn)(const ValueType&)) const;

    template <typename FunctorType>
    void mapAll(FunctorType fn) const;
    
    /*
     * Method: remove
     * Usage: set.remove(value);
     * -------------------------
     * Removes an element from this set.  If the value was not
     * contained in the set, no error is generated and the set
     * remains unchanged.
     */
    void remove(const ValueType& value);
    
    /*
     * Method: removeAll
     * Usage: set.removeAll(set2);
     * ---------------------------
     * Removes all elements of the given other set from this set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Returns a reference to this set.
     * Identical in behavior to the -= operator.
     */
    HashSet<ValueType>& removeAll(const HashSet<ValueType>& set);
    HashSet<ValueType>& removeAll(std::initializer_list<ValueType> list);

    /*
     * Method: retainAll
     * Usage: set.retainAll(set2);
     * ----------------------
     * Removes all elements from this set that are not contained in the given
     * other set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Returns a reference to this set.
     * Identical in behavior to the *= operator.
     */
    HashSet<ValueType>& retainAll(const HashSet<ValueType>& set);
    HashSet<ValueType>& retainAll(std::initializer_list<ValueType> list);

    /*
     * Method: size
     * Usage: count = set.size();
     * --------------------------
     * Returns the number of elements in this set.
     */
    int size() const;
    
    /*
     * Method: toString
     * Usage: string str = set.toString();
     * -----------------------------------
     * Converts the set to a printable string representation.
     */
    std::string toString() const;

    /*
     * Operator: ==
     * Usage: set1 == set2
     * -------------------
     * Returns <code>true</code> if <code>set1</code> and <code>set2</code>
     * contain the same elements.
     */
    bool operator ==(const HashSet& set2) const;

    /*
     * Operator: !=
     * Usage: set1 != set2
     * -------------------
     * Returns <code>true</code> if <code>set1</code> and <code>set2</code>
     * are different.
     */
    bool operator !=(const HashSet& set2) const;

    /*
     * Operator: +
     * Usage: set1 + set2
     *        set1 + element
     * ---------------------
     * Returns the union of sets <code>set1</code> and <code>set2</code>, which
     * is the set of elements that appear in at least one of the two sets.  The
     * right hand set can be replaced by an element of the value type, in which
     * case the operator returns a new set formed by adding that element.
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    HashSet operator +(const HashSet& set2) const;
    HashSet operator +(std::initializer_list<ValueType> list) const;
    HashSet operator +(const ValueType& element) const;

    /*
     * Operator: *
     * Usage: set1 * set2
     * ------------------
     * Returns the intersection of sets <code>set1</code> and <code>set2</code>,
     * which is the set of all elements that appear in both.
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    HashSet operator *(const HashSet& set2) const;
    HashSet operator *(std::initializer_list<ValueType> list) const;

    /*
     * Operator: -
     * Usage: set1 - set2
     *        set1 - element
     * ---------------------
     * Returns the difference of sets <code>set1</code> and <code>set2</code>,
     * which is all of the elements that appear in <code>set1</code> but
     * not <code>set2</code>.  The right hand set can be replaced by an
     * element of the value type, in which case the operator returns a new
     * set formed by removing that element.
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    HashSet operator -(const HashSet& set2) const;
    HashSet operator -(std::initializer_list<ValueType> list) const;
    HashSet operator -(const ValueType& element) const;

    /*
     * Operator: +=
     * Usage: set1 += set2;
     *        set1 += value;
     * ---------------------
     * Adds all of the elements from <code>set2</code> (or the single
     * specified value) to <code>set1</code>.  As a convenience, the
     * <code>HashSet</code> package also overloads the comma operator so
     * that it is possible to initialize a set like this:
     *
     *<pre>
     *    HashSet&lt;int&lt; digits;
     *    digits += 0, 1, 2, 3, 4, 5, 6, 7, 8, 9;
     *</pre>
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    HashSet& operator +=(const HashSet& set2);
    HashSet& operator +=(std::initializer_list<ValueType> list);
    HashSet& operator +=(const ValueType& value);

    /*
     * Operator: *=
     * Usage: set1 *= set2;
     * --------------------
     * Removes any elements from <code>set1</code> that are not present in
     * <code>set2</code>.
     */
    HashSet& operator *=(const HashSet& set2);
    HashSet& operator *=(std::initializer_list<ValueType> list);

    /*
     * Operator: -=
     * Usage: set1 -= set2;
     *        set1 -= value;
     * ---------------------
     * Removes the elements from <code>set2</code> (or the single
     * specified value) from <code>set1</code>.  As a convenience, the
     * <code>HashSet</code> package also overloads the comma operator so
     * that it is possible to remove multiple elements from a set
     * like this:
     *
     *<pre>
     *    digits -= 0, 2, 4, 6, 8;
     *</pre>
     *
     * which removes the values 0, 2, 4, 6, and 8 from the set
     * <code>digits</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    HashSet& operator -=(const HashSet& set2);
    HashSet& operator -=(std::initializer_list<ValueType> list);
    HashSet& operator -=(const ValueType& value);

    /*
     * Additional HashSet operations
     * -----------------------------
     * In addition to the methods listed in this interface, the HashSet
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * The iteration forms process the HashSet in an unspecified order.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    HashMap<ValueType, bool> map;        /* Map used to store the element     */
    bool removeFlag;                     /* Flag to differentiate += and -=   */

public:
    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support the comma operator, deep copying, and iteration.
     * Including these methods in the public interface would make
     * that interface more difficult to understand for the average client.
     */
    HashSet& operator ,(const ValueType& value) {
        if (this->removeFlag) {
            this->remove(value);
        } else {
            this->add(value);
        }
        return *this;
    }

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public std::iterator<std::input_iterator_tag,ValueType> {
    private:
        typename HashMap<ValueType,bool>::iterator mapit;

    public:
        iterator() {
            /* Empty */
        }

        iterator(typename HashMap<ValueType, bool>::iterator it) : mapit(it) {
            /* Empty */
        }

        iterator(const iterator& it) {
            mapit = it.mapit;
        }

        iterator& operator ++() {
            ++mapit;
            return *this;
        }

        iterator operator ++(int) {
            iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const iterator& rhs) {
            return mapit == rhs.mapit;
        }

        bool operator !=(const iterator& rhs) {
            return !(*this == rhs);
        }

        ValueType& operator *() {
            return *mapit;
        }

        ValueType* operator ->() {
            return mapit;
        }
    };

    iterator begin() const {
        return iterator(map.begin());
    }

    iterator end() const {
        return iterator(map.end());
    }
};

template <typename ValueType>
HashSet<ValueType>::HashSet() : removeFlag(false) {
    /* Empty */
}

template <typename ValueType>
HashSet<ValueType>::HashSet(std::initializer_list<ValueType> list)
        : removeFlag(false) {
    addAll(list);
}

template <typename ValueType>
HashSet<ValueType>::~HashSet() {
    /* Empty */
}

template <typename ValueType>
void HashSet<ValueType>::add(const ValueType& value) {
    map.put(value, true);
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::addAll(const HashSet& set2) {
    for (const ValueType& value : set2) {
        this->add(value);
    }
    return *this;
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::addAll(std::initializer_list<ValueType> list) {
    for (const ValueType& value : list) {
        this->add(value);
    }
    return *this;
}

template <typename ValueType>
ValueType HashSet<ValueType>::back() const {
    if (isEmpty()) {
        error("HashSet::back: set is empty");
    }
    return map.back();
}

template <typename ValueType>
void HashSet<ValueType>::clear() {
    map.clear();
}

template <typename ValueType>
bool HashSet<ValueType>::contains(const ValueType& value) const {
    return map.containsKey(value);
}

template <typename ValueType>
bool HashSet<ValueType>::containsAll(const HashSet<ValueType>& set2) const {
    for (const ValueType& value : set2) {
        if (!contains(value)) {
            return false;
        }
    }
    return true;
}

template <typename ValueType>
bool HashSet<ValueType>::containsAll(std::initializer_list<ValueType> list) const {
    for (const ValueType& value : list) {
        if (!contains(value)) {
            return false;
        }
    }
    return true;
}

template <typename ValueType>
bool HashSet<ValueType>::equals(const HashSet<ValueType>& set2) const {
    // optimization: if literally same set, stop
    if (this == &set2) {
        return true;
    }
    
    if (size() != set2.size()) {
        return false;
    }
    
    // BUGFIX: don't need to check set2.isSubsetOf(*this) because they are
    // the same size - credit to Stanford student G. Boullanger 2016/12/05
    return isSubsetOf(set2);
}

template <typename ValueType>
ValueType HashSet<ValueType>::first() const {
    if (isEmpty()) {
        error("HashSet::first: set is empty");
    }
    return map.front();
}

template <typename ValueType>
ValueType HashSet<ValueType>::front() const {
    if (isEmpty()) {
        error("HashSet::front: set is empty");
    }
    return map.front();
}

template <typename ValueType>
void HashSet<ValueType>::insert(const ValueType& value) {
    map.put(value, true);
}

template <typename ValueType>
bool HashSet<ValueType>::isEmpty() const {
    return map.isEmpty();
}

template <typename ValueType>
bool HashSet<ValueType>::isSubsetOf(const HashSet& set2) const {
    iterator it = begin();
    iterator end = this->end();
    while (it != end) {
        if (!set2.map.containsKey(*it)) {
            return false;
        }
        ++it;
    }
    return true;
}

template <typename ValueType>
bool HashSet<ValueType>::isSubsetOf(std::initializer_list<ValueType> list) const {
    HashSet<ValueType> set2(list);
    return isSubsetOf(set2);
}

template <typename ValueType>
bool HashSet<ValueType>::isSupersetOf(const HashSet& set2) const {
    return containsAll(set2);
}

template <typename ValueType>
bool HashSet<ValueType>::isSupersetOf(std::initializer_list<ValueType> list) const {
    return containsAll(list);
}

template <typename ValueType>
void HashSet<ValueType>::mapAll(void (*fn)(ValueType)) const {
    map.mapAll(fn);
}

template <typename ValueType>
void HashSet<ValueType>::mapAll(void (*fn)(const ValueType&)) const {
    map.mapAll(fn);
}

template <typename ValueType>
template <typename FunctorType>
void HashSet<ValueType>::mapAll(FunctorType fn) const {
    map.mapAll(fn);
}

template <typename ValueType>
void HashSet<ValueType>::remove(const ValueType& value) {
    map.remove(value);
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::removeAll(const HashSet& set2) {
    Vector<ValueType> toRemove;
    for (const ValueType& value : *this) {
        if (set2.map.containsKey(value)) {
            toRemove.add(value);
        }
    }
    for (const ValueType& value : toRemove) {
        remove(value);
    }
    return *this;
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::removeAll(std::initializer_list<ValueType> list) {
    for (const ValueType& value : list) {
        remove(value);
    }
    return *this;
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::retainAll(const HashSet& set2) {
    Vector<ValueType> toRemove;
    for (const ValueType& value : *this) {
        if (!set2.map.containsKey(value)) {
            toRemove.add(value);
        }
    }
    for (const ValueType& value : toRemove) {
        remove(value);
    }
    return *this;
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::retainAll(std::initializer_list<ValueType> list) {
    HashSet<ValueType> set2(list);
    return retainAll(set2);
}

template <typename ValueType>
int HashSet<ValueType>::size() const {
    return map.size();
}

template <typename ValueType>
std::string HashSet<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

/*
 * Implementation notes: set operators
 * -----------------------------------
 * The implementations for the set operators use iteration to walk
 * over the elements in one or both sets.
 */
template <typename ValueType>
bool HashSet<ValueType>::operator ==(const HashSet& set2) const {
    return equals(set2);
}

template <typename ValueType>
bool HashSet<ValueType>::operator !=(const HashSet& set2) const {
    return !equals(set2);
}

template <typename ValueType>
HashSet<ValueType> HashSet<ValueType>::operator +(const HashSet& set2) const {
    HashSet<ValueType> set = *this;
    set.addAll(set2);
    return set;
}

template <typename ValueType>
HashSet<ValueType> HashSet<ValueType>::operator +(std::initializer_list<ValueType> list) const {
    HashSet<ValueType> set = *this;
    set.addAll(list);
    return set;
}

template <typename ValueType>
HashSet<ValueType> HashSet<ValueType>::operator +(const ValueType& element) const {
    HashSet<ValueType> set = *this;
    set.add(element);
    return set;
}

template <typename ValueType>
HashSet<ValueType> HashSet<ValueType>::operator *(const HashSet& set2) const {
    HashSet<ValueType> set = *this;
    return set.retainAll(set2);
}

template <typename ValueType>
HashSet<ValueType> HashSet<ValueType>::operator *(std::initializer_list<ValueType> list) const {
    HashSet<ValueType> set = *this;
    return set.retainAll(list);
}

template <typename ValueType>
HashSet<ValueType> HashSet<ValueType>::operator -(const HashSet& set2) const {
    HashSet<ValueType> set = *this;
    return set.removeAll(set2);
}

template <typename ValueType>
HashSet<ValueType> HashSet<ValueType>::operator -(std::initializer_list<ValueType> list) const {
    HashSet<ValueType> set = *this;
    return set.removeAll(list);
}

template <typename ValueType>
HashSet<ValueType> HashSet<ValueType>::operator -(const ValueType& element) const {
    HashSet<ValueType> set = *this;
    set.remove(element);
    return set;
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::operator +=(const HashSet& set2) {
    return addAll(set2);
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::operator +=(std::initializer_list<ValueType> list) {
    return addAll(list);
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::operator +=(const ValueType& value) {
    add(value);
    removeFlag = false;
    return *this;
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::operator *=(const HashSet& set2) {
    return retainAll(set2);
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::operator *=(std::initializer_list<ValueType> list) {
    return retainAll(list);
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::operator -=(const HashSet& set2) {
    return removeAll(set2);
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::operator -=(std::initializer_list<ValueType> list) {
    return removeAll(list);
}

template <typename ValueType>
HashSet<ValueType>& HashSet<ValueType>::operator -=(const ValueType& value) {
    remove(value);
    removeFlag = true;
    return *this;
}

template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const HashSet<ValueType>& set) {
    return stanfordcpplib::collections::writeCollection(os, set);
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, HashSet<ValueType>& set) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, set, element, /* descriptor */ "HashSet::operator >>");
}

/*
 * Template hash function for hash sets.
 * Requires the element type in the HashSet to have a hashCode function.
 */
template <typename T>
int hashCode(const HashSet<T>& set) {
    return stanfordcpplib::collections::hashCodeCollection(set, /* orderMatters */ false);
}

/*
 * Function: randomElement
 * Usage: element = randomElement(set);
 * ------------------------------------
 * Returns a randomly chosen element of the given set.
 * Throws an error if the set is empty.
 */
template <typename T>
const T& randomElement(const HashSet<T>& set) {
    return stanfordcpplib::collections::randomElement(set);
}

#endif // _hashset_h

/////////////////////// END code extracted from StanfordCPPLib/collections/hashset.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/graph.h ///////////////////////
/*
 * File: graph.h
 * -------------
 * This file exports a parameterized Graph class used to represent graphs,
 * which consist of a set of nodes (vertices) and a set of arcs (edges).
 * 
 * @version 2018/09/07
 * - reformatted doc-style comments
 * @version 2018/03/10
 * - added methods front, back
 * - fixed compiler issue with getArcSet call
 * @version 2017/11/14
 * - added nodeCount, arcCount, getNodeNames
 * @version 2016/12/09
 * - added iterator version checking support (implicitly via Map)
 * - fixed bug in getInverseNeighborNames function
 * @version 2016/12/01
 * - removed memory leaks of graph node and arc structures
 * - fixed bug in containsNode method (was returning false positives)
 * - fixed bugs in some node/arc methods (should not crash on empty/null args)
 * @version 2016/11/29
 * - added getNeighborNames, getInverseNeighborNames
 * @version 2016/11/26
 * - added getInverseArcSet
 * @version 2016/11/19
 * - changed addNode to not throw when adding duplicates
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added iterator begin(), end() support so that students can directly
 *   for-each over the vertices of a graph.
 * - added comparison operators ==, !=, <, etc.
 * - added template hashCode function
 * @version 2014/10/20
 * - converted functions to accept const string& rather than string for speed
 * - added iterator/for-each support over nodes; begin() / end() members
 * - updated various methods that accept node/arc pointers to verify
 *   that those nodes/arcs are part of the graph first, and to check for null
 * @version 2014/10/10
 * - removed use of __foreach macro
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _graph_h
#define _graph_h

#include <string>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * This class represents a graph with the specified node and arc types.
 * The <code>NodeType</code> and <code>ArcType</code> parameters indicate
 * the structure type or class used for nodes and arcs, respectively.
 * These types can contain any fields or methods required by the client,
 * but must contain the following fields required by the <code>Graph</code>
 * package itself:
 *
 * <p>The <code>NodeType</code> definition must include:
 * <ul>
 *   <li>A <code>string</code> field called <code>name</code>
 *   <li>A <code>Set&lt;ArcType *&gt;</code> field called <code>arcs</code>
 * </ul>
 *
 * <p>The <code>ArcType</code> definition must include:
 * <ul>
 *   <li>A <code>NodeType *</code> field called <code>start</code>
 *   <li>A <code>NodeType *</code> field called <code>finish</code>
 * </ul>
 */
template <typename NodeType, typename ArcType>
class Graph {
public:
    /**
     * Creates an empty graph.
     * @bigoh O(1)
     */
    Graph();
    
    /**
     * Frees the internal storage allocated to represent the graph.
     * @bigoh O(V + E)
     */
    virtual ~Graph();
    
    /**
     * Adds a directed arc to the graph from node n1 to n2.
     * If either node is not found in the graph, said node will be added to the graph.
     * Returns a pointer to the arc in case the client needs to capture this value.
     * @bigoh O(log V + log E)
     */
    ArcType* addArc(const std::string& n1, const std::string& n2);

    /**
     * Adds a directed arc to the graph from node n1 to n2.
     * If either node is not found in the graph, said node will be added to the graph.
     * Returns a pointer to the arc in case the client needs to capture this value.
     *
     * @throw ErrorException if any pointer passed is null
     * @bigoh O(log V + log E)
     */
    ArcType* addArc(NodeType* n1, NodeType* n2);

    /**
     * Adds the given arc to the graph.
     * If the start/finish nodes passed are not already part of the graph,
     * they are added to the graph.
     * Returns a pointer to the arc in case the client needs to capture this value.
     *
     * Memory management: Once you hand me this ArcType* pointer, our code owns it.
     * We will delete/free it when done with it.
     * You do not need to (and should not) free it yourself.
     *
     * @throw ErrorException if any pointer passed is null
     * @bigoh O(log V + log E)
     */
    ArcType* addArc(ArcType* arc);

    /**
     * Adds a node to the graph.  The first version of this method
     * creates a new node of the appropriate type and initializes its
     * fields; the second assumes that the client has already created
     * the node and simply adds it to the graph.
     * Returns a pointer to the node.
     * If a node with the given name is already present, does nothing.
     *
     * Memory management: Once you hand me this NodeType* pointer, our code owns it.
     * We will delete/free it when done with it.
     * You do not need to (and should not) free it yourself.
     *
     * @throw ErrorException if any pointer passed is null
     * @bigoh O(log V)
     */
    NodeType* addNode(const std::string& name);

    /**
     * Adds a node to the graph.
     * This version assumes that the client has already created the node structure
     * and simply adds it to the graph.
     * Returns a pointer to the node.
     * If a node with the given name is already present, does nothing.
     *
     * Memory management: Once you hand me this NodeType* pointer, our code owns it.
     * We will delete/free it when done with it.
     * You do not need to (and should not) free it yourself.
     *
     * @throw ErrorException if any pointer passed is null
     * @bigoh O(log V)
     */
    NodeType* addNode(NodeType* node);

    /**
     * Returns the number of arcs in the graph.
     * @bigoh O(1)
     */
    int arcCount() const;

    /**
     * Returns the last node in the graph in the order as would be returned by
     * a for-each loop or iterator.
     * @throw ErrorException if the graph is empty
     * @bigoh O(1)
     */
    NodeType* back() const;

    /**
     * Reinitializes the graph to be empty, removing all nodes and arcs
     * and freeing any heap storage used by their corresponding internal structures.
     * @bigoh O(V + E)
     */
    void clear();

    /**
     * Removes all arcs from the graph, freeing the heap storage used by their
     * corresponding internal structures. The graph's nodes remain intact.
     * @bigoh O(E)
     */
    void clearArcs();

    /**
     * Removes all arcs from the graph that start from the given node,
     * freeing the heap storage used by their corresponding internal structures.
     * The graph's nodes remain intact.
     * If the given node pointer is null or not found in the graph, has no effect.
     * @bigoh O(log V + E)
     */
    void clearArcs(NodeType* node);

    /**
     * Removes all arcs from the graph that start from the given node,
     * freeing the heap storage used by their corresponding internal structures.
     * The graph's nodes remain intact.
     * If the given node is not found in the graph, has no effect.
     * @bigoh O(E log E)
     */
    void clearArcs(const std::string& name);

    /**
     * Returns true if there exists an arc directly between the given two nodes.
     * If either node is null or is not contained in this graph, returns false.
     * @bigoh O(log E)
     */
    bool containsArc(NodeType* node1, NodeType* node2) const;

    /**
     * Returns true if there exists an arc directly between the given two nodes.
     * If either node is not contained in this graph, returns false.
     * @bigoh O(log E)
     */
    bool containsArc(const std::string& node1, const std::string& node2) const;

    /**
     * Returns true if the given arc exists in this graph.
     * If the given arc is null or either of its nodes are not contained in
     * this graph, returns false.
     * @bigoh O(log E)
     */
    bool containsArc(ArcType* arc) const;

    /**
     * Returns true if there exists a node in this graph with the given name.
     * @bigoh O(log V)
     */
    bool containsNode(const std::string& name) const;

    /**
     * Returns true if the given node is part of this graph.
     * If the pointer passed is null, returns false.
     * @bigoh O(log V)
     */
    bool containsNode(NodeType* node) const;

    /**
     * Compares two graphs for equality.
     * Returns <code>true</code> if this graph contains exactly the same
     * nodes, arcs, and connections as the given other graph.
     * Identical in behavior to the == operator.
     * @bigoh O(V log V + E log E)
     */
    bool equals(const Graph<NodeType, ArcType>& graph2) const;
    
    /**
     * Returns the first node in the graph in the order as would be returned by
     * a for-each loop or iterator.
     * @throw ErrorException if the graph is empty
     * @bigoh O(1)
     */
    NodeType* front() const;

    /**
     * Returns the arc, if any, from node1 to node2.
     * If multiple arcs exist between the given two nodes, which is returned is unspecified.
     * If either pointer passed is null or no such arc exists, returns a null pointer.
     * @bigoh O(log V + log E)
     */
    ArcType* getArc(NodeType* node1, NodeType* node2) const;

    /**
     * Returns the arc, if any, from node1 to node2.
     * If multiple arcs exist between the given two nodes, which is returned is unspecified.
     * If no such arc exists, returns a null pointer.
     * @bigoh O(log V + log E)
     */
    ArcType* getArc(const std::string& node1, const std::string& node2) const;

    /**
     * Returns the set of all arcs in the graph.
     * @bigoh O(1)
     */
    const Set<ArcType*>& getArcSet() const;

    /**
     * Returns the set of all arcs that start at the specified node,
     * indicated as a pointer to its node structure.
     * If the pointer passed is null or the given node is not found in the graph,
     * returns an empty set.
     * @bigoh O(1)
     */
    const Set<ArcType*>& getArcSet(NodeType* node) const;

    /**
     * Returns the set of all arcs that start at the specified node.
     * If the given node is not found in the graph, returns an empty set.
     * @bigoh O(1)
     */
    const Set<ArcType*>& getArcSet(const std::string& name) const;

    /**
     * Returns the set of outbound arcs to the given node from other nodes.
     * In other words, getInverseArcSet(n1) is the set of all nodes n2
     * such that there exists an arc E starting from n2 and ending at n1.
     *
     * If any pointer passed is null, or if the given node is not found
     * in this graph, returns an empty set.
     * @bigoh O(E)
     */
    const Set<ArcType*> getInverseArcSet(NodeType* node) const;

    /**
     * Returns the set of outbound arcs to the given node from other nodes.
     * In other words, getInverseArcSet(n1) is the set of all nodes n2
     * such that there exists an arc E starting from n2 and ending at n1.
     *
     * If the given node is not found in this graph, returns an empty set.
     * @bigoh O(E)
     */
    const Set<ArcType*> getInverseArcSet(const std::string& name) const;

    /**
     * Returns the set of strings of names of nodes that are neighbors of the
     * given node.
     * In other words, getInverseNeighborNames(n1) is the set of all strings n2
     * such that there exists an arc E starting from n2 and ending at n1.
     *
     * If any pointer passed is null, or if the given node is not found
     * in this graph, returns an empty set.
     * @bigoh O(E)
     */
    Set<std::string> getInverseNeighborNames(NodeType* node) const;

    /**
     * Returns the set of strings of names of nodes that are neighbors of the
     * given node.
     * In other words, getInverseNeighborNames(n1) is the set of all strings n2
     * such that there exists an arc E starting from n2 and ending at n1.
     *
     * If the given node is not found in this graph, returns an empty set.
     * @bigoh O(E)
     */
    Set<std::string> getInverseNeighborNames(const std::string& node) const;

    /**
     * Returns the set of nodes that are neighbors of the specified node.
     * In other words, getInverseNeighbors(n1) is the set of all nodes n2
     * such that there exists an arc E starting from n2 and ending at n1.
     *
     * If any pointer passed is null, or if the given node is not found
     * in this graph, returns an empty set.
     * @bigoh O(E)
     */
    Set<NodeType*> getInverseNeighbors(NodeType* node) const;

    /**
     * Returns the set of nodes that are neighbors of the specified node.
     * In other words, getInverseNeighbors(n1) is the set of all nodes n2
     * such that there exists an arc E starting from n2 and ending at n1.
     *
     * If the given node is not found in this graph, returns an empty set.
     * @bigoh O(E)
     */
    Set<NodeType*> getInverseNeighbors(const std::string& node) const;

    /**
     * Returns the set of node names that are neighbors of the specified node.
     * In other words, getNeighbors(n1) is the set of all strings n2
     * such that there exists an arc E starting from n1 and ending at n2.
     *
     * If any pointer passed is null, or if the given node is not found
     * in this graph, returns an empty set.
     * @bigoh O(log V)
     */
    Set<std::string> getNeighborNames(NodeType* node) const;

    /**
     * Returns the set of node names that are neighbors of the specified node.
     * In other words, getNeighbors(n1) is the set of all strings n2
     * such that there exists an arc E starting from n1 and ending at n2.
     *
     * If the given node is not found in this graph, returns an empty set.
     * @bigoh O(log V)
     */
    Set<std::string> getNeighborNames(const std::string& node) const;

    /**
     * Returns the set of nodes that are neighbors of the specified node.
     * In other words, getNeighbors(n1) is the set of all nodes n2
     * such that there exists an arc E starting from n1 and ending at n2.
     *
     * If any pointer passed is null, or if the given node is not found
     * in this graph, returns an empty set.
     * @bigoh O(log V)
     */
    Set<NodeType*> getNeighbors(NodeType* node) const;

    /**
     * Returns the set of nodes that are neighbors of the specified node.
     * In other words, getNeighbors(n1) is the set of all nodes n2
     * such that there exists an arc E starting from n1 and ending at n2.
     *
     * If the given node is not found in this graph, returns an empty set.
     * @bigoh O(log V)
     */
    Set<NodeType*> getNeighbors(const std::string& node) const;

    /**
     * Looks up a node in the name table attached to the graph and
     * returns a pointer to that node.
     * If no node with the specified name exists, returns <code>nullptr</code>.
     * @bigoh O(log V)
     */
    NodeType* getNode(const std::string& name) const;

    /**
     * Returns the set of the names of all nodes in the graph.
     * Similar to getNodeSet but returns a set of strings rather than a set
     * of pointers to nodes.
     * @bigoh O(V log V)
     */
    Set<std::string> getNodeNames() const;
    
    /**
     * Returns the set of all nodes in the graph.
     * These are direct pointers to the internal NodeType* structures in the
     * graph, so any modifications you make to them will be reflected in the graph.
     * @bigoh O(1)
     */
    const Set<NodeType*>& getNodeSet() const;

    /**
     * Returns <code>true</code> if the graph contains an arc from
     * <code>n1</code> to <code>n2</code>.
     * If any pointer passed is null, or if either node is not contained
     * in this graph, returns false.
     * @bigoh O(log V)
     */
    bool isConnected(NodeType* n1, NodeType* n2) const;

    /**
     * Returns <code>true</code> if the graph contains an arc from
     * <code>n1</code> to <code>n2</code>.
     * If either node is not contained in this graph, returns false.
     * @bigoh O(log V)
     */
    bool isConnected(const std::string& s1, const std::string& s2) const;

    /**
     * Returns true if the graph contains an edge from v1 to v2.
     * If either of the vertexes supplied is not found in the graph, returns false.
     * @bigoh O(log V)
     */
    bool isNeighbor(const std::string& node1, const std::string& node2) const;

    /**
     * Returns true if the graph contains an edge from v1 to v2.
     * If either of the vertexes supplied is null or is not found in the graph, returns false.
     * @bigoh O(log V)
     */
    bool isNeighbor(NodeType* node1, NodeType* node2) const;

    /**
     * Returns <code>true</code> if the graph contains no vertexes.
     * @bigoh O(1)
     */
    bool isEmpty() const;

    /**
     * Returns the number of nodes in the graph.
     * Equivalent to size().
     * @bigoh O(1)
     */
    int nodeCount() const;

    /**
     * Removes an arc from v1 to v2 in the graph, specified by the names of its endpoints.
     * If more than one arc connects the specified endpoints, all of them are removed.
     * If no arc connects the given endpoints, or the given arc is not found,
     * the call has no effect.
     * @bigoh O(E + log V)
     */
    void removeArc(const std::string& s1, const std::string& s2);

    /**
     * Removes an arc from v1 to v2 in the graph, specified by the node pointers
     * at its endpoints.
     * If more than one arc connects the specified endpoints, all of them are removed.
     * If no arc connects the given endpoints, or the given arc is not found,
     * the call has no effect.
     * @bigoh O(E + log V)
     */
    void removeArc(NodeType* n1, NodeType* n2);

    /**
     * Removes the given arc from the graph, specified as an arc pointer.
     * If more than one arc connects the specified endpoints, all of them are removed.
     * If no arc connects the given endpoints, or the given arc is not found,
     * the call has no effect.
     *
     * Memory management: Our code will delete/free the ArcType* object when done with it.
     * You do not need to (and should not) free it yourself.
     * @bigoh O(log E + log V)
     */
    void removeArc(ArcType* arc);

    /**
     * Removes the node with the given name from the graph.
     * Removing a node also removes all arcs that contain that node.
     * If a node name is passed that is not part of the graph,
     * the call has no effect.
     * @bigoh O(E + log V)
     */
    void removeNode(const std::string& name);

    /**
     * Removes a node from the graph, specified as a pointer value.
     * Removing a node also removes all arcs that contain that node.
     * If a node or name is passed that is null or is not part of the graph,
     * the call has no effect.
     *
     * Memory management: Our code will delete/free the NodeType* object when done with it.
     * You do not need to (and should not) free it yourself.
     * @bigoh O(E + log V)
     */
    void removeNode(NodeType* node);

    /**
     * Reads the data for an arc from the scanner.
     * The <code>forward</code> argument points to the arc in the forward direction.
     * If the arc is undirected, <code>backward</code> points to the reverse arc;
     * for directed arcs, the <code>backward</code> pointer is <code>nullptr</code>.
     *
     * The default implementation of this method is empty.
     * Clients that want to initialize other fields in the arc must override
     * this method so that it initializes one or both arc, as appropriate.
     */
    virtual void scanArcData(TokenScanner &, ArcType* /*forward*/, ArcType* /*backward*/) {
        // empty
    }

    /**
     * This method reads one "entry" for the graph, which is either a node
     * description or an arc description.  The <code>scanGraphEntry</code>
     * method returns <code>true</code> if it reads an entry, and
     * <code>false</code> at the end of file or at text that cannot be
     * recognized as a graph entry.
     *
     * Node entries consist of the name of a node (which may be quoted
     * if it contains special characters), optionally followed by data for
     * the node.  Arc descriptions have one of the following forms:
     *
     * <pre>
     * n1 -> n2
     * n1 - n2
     * </pre>
     *
     * either of which can be followed by data for the arc.
     * The first form creates a single directed arc; the second creates two arcs,
     * one in each direction.
     *
     * Clients who want to read node or arc data must override the empty
     * versions of <code>scanNodeData</code> and <code>scanArcData</code>
     * included in this interface.
     */
    virtual bool scanGraphEntry(TokenScanner& scanner);

    /**
     * Reads the data for the specified node from the scanner.
     * The default implementation of this method is empty.
     * Clients that want to initialize other fields in the node from the token
     * stream must override this method.
     */
    virtual void scanNodeData(TokenScanner&, NodeType*) {
        /* Empty */
    }

    /**
     * Returns the number of nodes in the graph.
     * Equivalent to nodeCount.
     * @bigoh O(1)
     */
    int size() const;

    /**
     * Converts the graph to a printable string representation.
     * @return a string such as <code>"{A, B, C, D, A - B, B - D, C - D}"</code>.
     * @bigoh O(V + E)
     */
    std::string toString() const;
    
    /**
     * Writes the data for the arc to the output stream.
     * The default implementation of this method is empty.
     * Clients that want to store other fields from the arc must override this
     * method so that it writes that data in a form that scanArcData can read.
     */
    virtual void writeArcData(std::ostream&, ArcType*) const {
        // empty
    }

    /**
     * Writes the data for the node to the output stream.
     * The default implementation of this method is empty.
     * Clients that want to store other fields from the node must override this
     * method so that it writes that data in a form that scanNodeData can read.
     */
    virtual void writeNodeData(std::ostream&, NodeType*) const {
        // empty
    }

    /**
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     *
     * @private
     */
    class graph_iterator : public std::iterator<std::input_iterator_tag, NodeType*> {
    public:
        graph_iterator() : m_graph(nullptr) {
            // empty
        }

        graph_iterator(const Graph& graph, bool end) {
            m_graph = &graph;
            if (end) {
                m_itr = m_graph->getNodeSet().end();
            } else {
                m_itr = m_graph->getNodeSet().begin();
            }
        }

        graph_iterator(const graph_iterator& it)
                : m_graph(it.m_graph), m_itr(it.m_itr) {
            // empty
        }

        graph_iterator& operator ++() {
            m_itr++;
            return *this;
        }

        graph_iterator operator ++(int) {
            graph_iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const graph_iterator& rhs) {
            return m_graph == rhs.m_graph && m_itr == rhs.m_itr;
        }

        bool operator !=(const graph_iterator& rhs) {
            return !(*this == rhs);
        }

        NodeType* operator *() {
            return *m_itr;
        }

        NodeType** operator ->() {
            return &(*m_itr);
        }

        friend class Graph;
        
    private:
        const Graph* m_graph;
        typename Set<NodeType*>::iterator m_itr;
    };
    
    /**
     * Returns an STL iterator positioned at the first vertex in the graph.
     * @bigoh O(1)
     */
    graph_iterator begin() const {
        return graph_iterator(*this, /* end */ false);
    }

    /**
     * Returns an STL iterator positioned after the last vertex in the graph.
     * @bigoh O(1)
     */
    graph_iterator end() const {
        return graph_iterator(*this, /* end */ true);
    }
    
    /**
     * Relational operators to compare two graphs.
     * The ==, != operators require that the ValueType has a == operator
     * so that the elements can be tested for equality.
     * @bigoh O(V log V + E log E)
     */
    bool operator ==(const Graph& graph2) const;

    /**
     * Relational operators to compare two graphs.
     * The ==, != operators require that the ValueType has a == operator
     * so that the elements can be tested for equality.
     * @bigoh O(V log V + E log E)
     */
    bool operator !=(const Graph& graph2) const;

    /**
     * Relational operators to compare two graphs.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(V log V + E log E)
     */
    bool operator <(const Graph& graph2) const;

    /**
     * Relational operators to compare two graphs.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(V log V + E log E)
     */
    bool operator <=(const Graph& graph2) const;

    /**
     * Relational operators to compare two graphs.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(V log V + E log E)
     */
    bool operator >(const Graph& graph2) const;

    /**
     * Relational operators to compare two graphs.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(V log V + E log E)
     */
    bool operator >=(const Graph& graph2) const;

    
    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /**
     * This template class establishes the ordering for nodes and arcs.
     * Nodes are processed in alphabetical order by node name; arcs are
     * compared in much the same way, looking first at the start node and
     * then continuing on to look at the finish node if the start nodes
     * match.  These functions, however, indicate equality only if the
     * arguments are identical, in the sense that they are at the same
     * address.  If two distinct arcs, for example, connect the same pair
     * of nodes (which is perfectly legal in the graph abstraction and can
     * be used, for example, to represent multiple modes of travel between
     * two nodes), those arcs are not the same.
     *
     * @private
     */
    class GraphComparator {
    public:
        bool operator ()(NodeType* n1, NodeType* n2) {
            return compare(n1, n2) < 0;
        }

        bool operator ()(ArcType* a1, ArcType* a2) {
            return compare(a1, a2) < 0;
        }
    };

private:
    Set<NodeType*> nodes;                  /* The set of nodes in the graph */
    Set<ArcType*> arcs;                    /* The set of arcs in the graph  */
    Map<std::string, NodeType*> nodeMap;   /* A map from names to nodes     */
    GraphComparator comparator;            /* The comparator for this graph */

public:
    /**
     * These functions are part of the public interface of the class but are
     * defined here to avoid adding confusion to the Graph class.
     *
     * @private
     */
    Graph& operator =(const Graph& src);

    /**
     * These functions are part of the public interface of the class but are
     * defined here to avoid adding confusion to the Graph class.
     *
     * @private
     */
    Graph(const Graph& src);

    /**
     * Compares two nodes for ordering within a set.
     *
     * @private
     */
    static int compare(NodeType* n1, NodeType* n2) {
        if (n1 == n2) {
            return 0;
        }
        if (n1->name < n2->name) {
            return -1;
        }
        if (n1->name > n2->name) {
            return +1;
        }
        return (n1 < n2) ? -1 : +1;
    }

    /**
     * Compares two arcs for ordering within a set.
     *
     * @private
     */
    static int compare(ArcType* a1, ArcType* a2) {
        if (a1 == a2) {
            return 0;
        }
        NodeType* n1 = a1->start;
        NodeType* n2 = a2->start;
        if (n1 != n2) {
            return compare(n1, n2);
        }
        n1 = a1->finish;
        n2 = a2->finish;
        if (n1 != n2) {
            return compare(n1, n2);
        }
        return (a1 < a2) ? -1 : +1;
    }

private:
    void deepCopy(const Graph& src);
    NodeType* getExistingNode(const std::string& name, const std::string& member = "") const;
    int graphCompare(const Graph& graph2) const;
    bool isExistingArc(ArcType* arc) const;
    bool isExistingNode(NodeType* node) const;
    void verifyExistingNode(NodeType* node, const std::string& member = "") const;
    void verifyNotNull(void* p, const std::string& member = "") const;
    NodeType* scanNode(TokenScanner& scanner);
};

/*
 * Implementation notes: Graph constructor
 * ---------------------------------------
 * Even though the body of the Graph constructor is empty, important
 * work is done by the initializers, which ensure that the nodes and
 * arcs set are given the correct comparison functions.
 */
template <typename NodeType, typename ArcType>
Graph<NodeType, ArcType>::Graph() {
    comparator = GraphComparator();
    nodes = Set<NodeType*>(comparator);
    arcs = Set<ArcType*>(comparator);
}

template <typename NodeType, typename ArcType>
Graph<NodeType, ArcType>::Graph(const Graph& src) {
    nodes = Set<NodeType*>(comparator);
    arcs = Set<ArcType*>(comparator);
    deepCopy(src);
}

/*
 * Implementation notes: Graph destructor
 * --------------------------------------
 * The destructor must free all heap storage used by this graph to
 * represent the nodes and arcs.  The clear method must also reclaim
 * this memory, which means that the destructor can simply call
 * clear to do the work.
 */
template <typename NodeType, typename ArcType>
Graph<NodeType, ArcType>::~Graph() {
    clear();
}

/*
 * Implementation notes: addArc
 * ----------------------------
 * The addArc method appears in three forms, as described in the
 * interface.  The code for each form of the method, however, is
 * quite straightforward.
 */
template <typename NodeType, typename ArcType>
ArcType* Graph<NodeType, ArcType>::addArc(const std::string& s1, const std::string& s2) {
    return addArc(getExistingNode(s1, "addArc"), getExistingNode(s2, "addArc"));
}

template <typename NodeType, typename ArcType>
ArcType* Graph<NodeType, ArcType>::addArc(NodeType* n1, NodeType* n2) {
    verifyExistingNode(n1, "addArc");
    verifyExistingNode(n2, "addArc");
    ArcType* arc = getArc(n1, n2);
    if (arc) {
        return arc;
    } else {
        arc = new ArcType();
        arc->start = n1;
        arc->finish = n2;
        return addArc(arc);
    }
}

template <typename NodeType, typename ArcType>
ArcType* Graph<NodeType, ArcType>::addArc(ArcType* arc) {
    verifyNotNull(arc, "addArc");
    if (!isExistingNode(arc->start)) {
        addNode(arc->start);
    }
    if (!isExistingNode(arc->finish)) {
        addNode(arc->finish);
    }
    arc->start->arcs.add(arc);
    arcs.add(arc);
    return arc;
}

/*
 * Implementation notes: addNode
 * -----------------------------
 * The addNode method appears in two forms: one that creates a node
 * from its name and one that assumes that the client has created
 * the new node.  In each case, the implementation must add the node
 * the set of nodes for the graph and add the name-to-node association
 * to the node map.
 */
template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::addNode(const std::string& name) {
    NodeType* node = getNode(name);
    if (node) {
        return node;   // vertex already exists
    }
    node = new NodeType();
    node->arcs = Set<ArcType*>(comparator);
    node->name = name;
    return addNode(node);
}

template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::addNode(NodeType* node) {
    verifyNotNull(node, "addNode");
    NodeType* existingNode = getNode(node->name);
    if (existingNode) {
        *existingNode = *node;   // copy state from parameter
        return existingNode;
    } else {
        nodes.add(node);
        nodeMap[node->name] = node;
        return node;
    }
}

template <typename NodeType, typename ArcType>
int Graph<NodeType, ArcType>::arcCount() const {
    return getArcSet().size();
}

template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::back() const {
    if (this->isEmpty()) {
        error("Graph::back: graph is empty");
    }
    return this->nodes.back();
}

/*
 * Implementation notes: clear
 * ---------------------------
 * The implementation of clear first frees the nodes and arcs in
 * their respective sets and then uses the Set class clear method
 * to ensure that these sets are empty.
 */
template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::clear() {
    for (NodeType* node : nodes) {
        delete node;
    }
    for (ArcType* arc : arcs) {
        delete arc;
    }
    arcs.clear();
    nodes.clear();
    nodeMap.clear();
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::clearArcs() {
    Set<ArcType*> arcsCopy = getArcSet();   // makes a copy
    for (ArcType* arc : arcsCopy) {
        removeArc(arc);
    }
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::clearArcs(NodeType* node) {
    if (isExistingNode(node)) {
        Set<ArcType*> arcsCopy = getArcSet(node);   // makes a copy
        for (ArcType* arc : arcsCopy) {
            removeArc(arc);
        }
    }
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::clearArcs(const std::string& name) {
    Set<ArcType*> arcsCopy = getArcSet(name);   // makes a copy
    for (ArcType* arc : arcsCopy) {
        removeArc(arc);
    }
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::containsArc(NodeType* node1, NodeType* node2) const {
    return getArc(node1, node2) != nullptr;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::containsArc(const std::string& node1, const std::string& node2) const {
    return getArc(node1, node2) != nullptr;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::containsArc(ArcType* arc) const {
    if (!arc) {
        return false;
    } else {
        return this->getArcSet().contains(arc);
    }
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::containsNode(const std::string& name) const {
    return nodeMap.containsKey(name);
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::containsNode(NodeType* node) const {
    if (node) {
        return nodes.contains(node);
    } else {
        return false;
    }
}


template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::equals(const Graph<NodeType, ArcType>& graph2) const {
    return *this == graph2;
}

template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::front() const {
    if (this->isEmpty()) {
        error("Graph::front: graph is empty");
    }
    return this->nodes.front();
}

template <typename NodeType, typename ArcType>
ArcType* Graph<NodeType, ArcType>::getArc(NodeType* node1, NodeType* node2) const {
    if (!containsNode(node1) || !containsNode(node2)) {
        return nullptr;
    }
    for (ArcType* arc : getArcSet(node1)) {
        if (arc->finish == node2) {
            return arc;
        }
    }
    return nullptr;
}

template <typename NodeType, typename ArcType>
ArcType* Graph<NodeType, ArcType>::getArc(const std::string& node1, const std::string& node2) const {
    return getArc(getNode(node1), getNode(node2));
}

template <typename NodeType, typename ArcType>
const Set<ArcType*>& Graph<NodeType, ArcType>::getArcSet() const {
    return arcs;
}

template <typename NodeType, typename ArcType>
const Set<ArcType*>& Graph<NodeType, ArcType>::getArcSet(NodeType* node) const {
    if (isExistingNode(node)) {
        return node->arcs;
    } else {
        static Set<ArcType*> set;   // empty
        return set;
    }
}

template <typename NodeType, typename ArcType>
const Set<ArcType*>& Graph<NodeType, ArcType>::getArcSet(const std::string& name) const {
    return getArcSet(getNode(name));
}

template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::getExistingNode(const std::string& name, const std::string& member) const {
    NodeType* node = nodeMap.get(name);
    if (!node) {
        error("Graph::" + member + ": no node named " + name);
    }
    return node;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isExistingArc(ArcType* arc) const {
    return arc && arcs.contains(arc);
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isExistingNode(NodeType* node) const {
    return node && nodeMap.containsKey(node->name) && nodeMap.get(node->name) == node;
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::verifyExistingNode(NodeType* node, const std::string& member) const {
    verifyNotNull(node, member);
    if (!isExistingNode(node)) {
        error("Graph::" + member + ": node not found in graph");
    }
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::verifyNotNull(void* p, const std::string& member) const {
    if (!p) {
        error("Graph::" + member + ": parameter cannot be null");
    }
}

template <typename NodeType, typename ArcType>
const Set<ArcType*> Graph<NodeType, ArcType>::getInverseArcSet(NodeType* node) const {
    Set<ArcType*> set;
    if (isExistingNode(node)) {
        for (ArcType* arc : getArcSet()) {
            if (arc->finish == node) {
                set.add(arc);
            }
        }
    }
    return set;
}

template <typename NodeType, typename ArcType>
const Set<ArcType*> Graph<NodeType, ArcType>::getInverseArcSet(const std::string& nodeName) const {
    return getInverseArcSet(getNode(nodeName));
}

template <typename NodeType, typename ArcType>
Set<std::string> Graph<NodeType, ArcType>::getInverseNeighborNames(NodeType* node) const {
    Set<std::string> set;
    if (isExistingNode(node)) {
        for (ArcType* arc : getArcSet()) {
            if (arc->finish == node) {
                set.add(arc->start->name);
            }
        }
    }
    return set;
}

template <typename NodeType, typename ArcType>
Set<std::string> Graph<NodeType, ArcType>::getInverseNeighborNames(const std::string& name) const {
    return getInverseNeighborNames(getNode(name));
}

template <typename NodeType, typename ArcType>
Set<NodeType*> Graph<NodeType, ArcType>::getInverseNeighbors(NodeType* node) const {
    Set<NodeType*> set;
    if (isExistingNode(node)) {
        for (ArcType* arc : getArcSet()) {
            if (arc->finish == node) {
                set.add(arc->start);
            }
        }
    }
    return set;
}

template <typename NodeType, typename ArcType>
Set<NodeType*> Graph<NodeType, ArcType>::getInverseNeighbors(const std::string& nodeName) const {
    return getInverseNeighbors(getNode(nodeName));
}

template <typename NodeType, typename ArcType>
Set<std::string> Graph<NodeType, ArcType>::getNeighborNames(NodeType* node) const {
    Set<std::string> neighbors;
    if (isExistingNode(node)) {
        for (ArcType* arc : node->arcs) {
            neighbors.add(arc->finish->name);
        }
    }
    return neighbors;
}

template <typename NodeType, typename ArcType>
Set<std::string> Graph<NodeType, ArcType>::getNeighborNames(const std::string& name) const {
    return getNeighborNames(getNode(name));
}

/*
 * Implementation notes: getNeighbors
 * ----------------------------------
 * This implementation recomputes the set each time, which is reasonably
 * efficient if the degree of the node is small.
 */
template <typename NodeType, typename ArcType>
Set<NodeType*> Graph<NodeType, ArcType>::getNeighbors(NodeType* node) const {
    Set<NodeType*> nodesResult = Set<NodeType*>(comparator);
    if (isExistingNode(node)) {
        for (ArcType* arc : node->arcs) {
            nodesResult.add(arc->finish);
        }
    }
    return nodesResult;
}

template <typename NodeType, typename ArcType>
Set<NodeType*> Graph<NodeType, ArcType>::getNeighbors(const std::string& name) const {
    return getNeighbors(getNode(name));
}

/*
 * Implementation notes: getNode, getExistingNode
 * ----------------------------------------------
 * The getNode method simply looks up the name in the map, which correctly
 * returns nullptr if the name is not found.  Other methods in the
 * implementation call the private method getExistingNode instead,
 * which checks for a null value and signals an error.
 */
template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::getNode(const std::string& name) const {
    return nodeMap.get(name);
}

template <typename NodeType, typename ArcType>
Set<std::string> Graph<NodeType, ArcType>::getNodeNames() const {
    Set<std::string> nodeNames;
    for (NodeType* node : nodes) {
        nodeNames.add(node->name);
    }
    return nodeNames;
}

/*
 * Implementation notes: getNodeSet, getArcSet
 * -------------------------------------------
 * These methods simply return the set requested by the client.  The
 * sets are returned by reference for efficiency, because doing so
 * eliminates the need to copy the set.
 */
template <typename NodeType, typename ArcType>
const Set<NodeType*>& Graph<NodeType, ArcType>::getNodeSet() const {
    return nodes;
}

/*
 * Implementation notes: isConnected
 * ---------------------------------
 * Node n1 is connected to n2 if any of the arcs leaving n1 finish at n2.
 * The two versions of this method allow nodes to be specified either as
 * node pointers or by name.
 */
template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isConnected(NodeType* n1, NodeType* n2) const {
    // don't call verifyExistingNode here because it will throw an error
    // if n1 or n2 is not found; should just make the call return false
    if (!isExistingNode(n1) || !isExistingNode(n2)) {
        return false;
    }
    for (ArcType* arc : n1->arcs) {
        if (arc->finish == n2) {
            return true;
        }
    }
    return false;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isConnected(const std::string& s1, const std::string& s2) const {
    // don't call getExistingNode here because it will throw an error
    // if s1 or s2 is not found; should just make the call return false
    return isConnected(nodeMap.get(s1), nodeMap.get(s2));
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isNeighbor(const std::string& node1, const std::string& node2) const {
    return isConnected(node1, node2);
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isNeighbor(NodeType* node1, NodeType* node2) const {
    return isConnected(node1, node2);
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isEmpty() const {
    return nodes.isEmpty();
}

template <typename NodeType, typename ArcType>
int Graph<NodeType, ArcType>::nodeCount() const {
    return getNodeSet().size();
}

/*
 * Implementation notes: removeArc
 * -------------------------------
 * These methods remove arcs from the graph, which is ordinarily simply
 * a matter of removing the arc from two sets: the set of arcs in the
 * graph as a whole and the set of arcs in the starting node.  The
 * methods that remove an arc specified by its endpoints, however,
 * must take account of the fact that there might be more than one
 * such arc and delete all of them.
 */
template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::removeArc(const std::string& s1, const std::string& s2) {
    // don't call getExistingNode here because it will throw an error
    // if s1 or s2 is not found; should just make the call have no effect
    removeArc(nodeMap.get(s1), nodeMap.get(s2));
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::removeArc(NodeType* n1, NodeType* n2) {
    // don't call verifyExistingNode here because it will throw an error
    // if n1 or n2 is not found; should just make the call have no effect
    if (!isExistingNode(n1) || !isExistingNode(n2)) {
        return;
    }
    Vector<ArcType*> toRemove;
    for (ArcType* arc : arcs) {
        if (arc->start == n1 && arc->finish == n2) {
            toRemove.add(arc);
        }
    }
    for (ArcType* arc : toRemove) {
        removeArc(arc);
    }
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::removeArc(ArcType* arc) {
    if (!isExistingArc(arc)) {
        return;
    }
    arc->start->arcs.remove(arc);
    arcs.remove(arc);
    delete arc;
}

/*
 * Implementation notes: removeNode
 * --------------------------------
 * The removeNode method must remove the specified node but must
 * also remove any arcs in the graph containing the node.  To avoid
 * changing the node set during iteration, this implementation creates
 * a vector of arcs that require deletion.
 */
template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::removeNode(const std::string& name) {
    // don't call getExistingNode here because it will throw an error
    // if name is not found; should just make the call have no effect
    removeNode(nodeMap.get(name));
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::removeNode(NodeType* node) {
    // don't call verifyExistingNode here because it will throw an error
    // if node is not found; should just make the call have no effect
    if (!isExistingNode(node)) {
        return;
    }
    Vector<ArcType*> toRemove;
    for (ArcType* arc : arcs) {
        if (arc->start == node || arc->finish == node) {
            toRemove.add(arc);
        }
    }
    for (ArcType* arc : toRemove) {
        removeArc(arc);
    }
    nodes.remove(node);
    nodeMap.remove(node->name);
    delete node;
}

/*
 * Implementation notes: scanGraphEntry
 * ------------------------------------
 * The scanGraphEntry and its helper methods take a scanner that is
 * initialized to the input stream and has the options ignoreWhitespace,
 * scanStrings, and scanNumbers set.
 */
template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::scanGraphEntry(TokenScanner& scanner) {
    NodeType* n1 = scanNode(scanner);
    if (!n1) {
        return false;
    }
    std::string op = scanner.nextToken();
    if (op != "-" && op != "->") {
        scanner.saveToken(op);
        return true;
    }
    NodeType* n2 = scanNode(scanner);
    if (!n2) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("Graph::scanGraphEntry: Missing node after " + op);
#endif
        return false;
    }
    ArcType* forward = new ArcType();
    forward->start = n1;
    forward->finish = n2;
    addArc(forward);
    ArcType* backward = nullptr;
    if (op == "-") {
        backward = new ArcType();
        backward->start = n2;
        backward->finish = n1;
        addArc(backward);
    }
    scanArcData(scanner, forward, backward);
    return true;
}

template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::scanNode(TokenScanner& scanner) {
    std::string token = scanner.nextToken();
    switch (scanner.getTokenType(token)) {
    case TokenScanner::WORD:
        break;
    case TokenScanner::STRING:
        token = scanner.getStringValue(token);
        break;
    default:
        scanner.saveToken(token);
        return nullptr;
    }
    NodeType* node = getNode(token);
    if (!node) {
        node = new NodeType();
        node->name = token;
        scanNodeData(scanner, node);
        addNode(node);
    }
    return node;
}

/*
 * Implementation notes: size, isEmpty
 * -----------------------------------
 * These methods are defined in terms of the node set, so the implementation
 * simply forwards the request there.  Note that it is impossible for a
 * graph to have arcs if it has no nodes.
 */
template <typename NodeType, typename ArcType>
int Graph<NodeType, ArcType>::size() const {
    return nodes.size();
}

template <typename NodeType, typename ArcType>
std::string Graph<NodeType, ArcType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

/*
 * Implementation notes: operator =, copy constructor
 * -------------------------------------------------
 * These methods ensure that copying a graph creates an entirely new
 * parallel structure of nodes and arcs.
 */
template <typename NodeType, typename ArcType>
Graph<NodeType,ArcType>&
Graph<NodeType, ArcType>::operator =(const Graph& src) {
    if (this != &src) {
        clear();
        deepCopy(src);
    }
    return *this;
}

/*
 * Private method: deepCopy
 * ------------------------
 * Common code factored out of the copy constructor and operator= to
 * copy the contents from the other graph.
 */
template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::deepCopy(const Graph& src) {
    for (NodeType* oldNode : src.nodes) {
        NodeType* newNode = new NodeType();
        *newNode = *oldNode;
        newNode->arcs.clear();
        addNode(newNode);
    }
    for (ArcType* oldArc : src.arcs) {
        ArcType* newArc = new ArcType();
        *newArc = *oldArc;
        newArc->start = getExistingNode(oldArc->start->name, "deepCopy");
        newArc->finish = getExistingNode(oldArc->finish->name, "deepCopy");
        addArc(newArc);
    }
}


/**
 * Compares two graphs for <, <=, ==, !=, >, >= relational operators.
 * Vertices are compared, including their neighboring arcs.
 *
 * @private
 */
template <typename NodeType, typename ArcType>
int Graph<NodeType, ArcType>::graphCompare(const Graph<NodeType, ArcType>& graph2) const {
    // optimization: if literally the same graph, return true
    if (this == &graph2) {
        return 0;
    }
    
    auto itr1 = begin();
    auto itr2 = graph2.begin();
    auto g1end = end();
    auto g2end = graph2.end();
    
    while (itr1 != g1end && itr2 != g2end) {
        // compare each pair of elements from iterators
        NodeType* node1 = *itr1;
        NodeType* node2 = *itr2;
        
        // optimization: if literally same node, equal; don't compare
        if (node1 != node2) {
            // first check names
            if (node1->name != node2->name) {
                return node1->name.compare(node2->name);
            }
            
            // then check all arcs, pairwise
            auto eitr1 = node1->arcs.begin();
            auto eitr2 = node2->arcs.begin();
            auto e1end = node1->arcs.end();
            auto e2end = node2->arcs.end();
            while (eitr1 != e1end && eitr2 != e2end) {
                ArcType* arc1 = *eitr1;
                ArcType* arc2 = *eitr2;
                
                // optimization: if literally same arc, equal; don't compare
                if (arc1 != arc2) {
                    // first check start vertex names, then end vertex names
                    if (arc1->start->name != arc2->start->name) {
                        return arc1->start->name.compare(arc2->start->name);
                    } else if (arc1->finish->name != arc2->finish->name) {
                        return arc1->finish->name.compare(arc2->finish->name);
                    }
                }
                eitr1++;
                eitr2++;
            }
            
            // if we get here, everything from me matched graph2, so either arcs equal,
            // or one is shorter than the other (fewer arcs) and is therefore less
            if (eitr1 == e1end && eitr2 == e2end) {
                // keep going
            } else if (eitr1 == e1end) {
                return -1;
            } else {
                return 1;
            }
        }
        
        // if we get here, those two vertices and their outbound arcs
        // were equal; so advance to next element
        itr1++;
        itr2++;
    }
    
    // if we get here, everything from me matched graph2, so either equal,
    // or one is shorter than the other (fewer vertices) and is therefore less
    if (itr1 == g1end && itr2 == g2end) {
        return 0;
    } else if (itr1 == g1end) {
        return -1;
    } else {
        return 1;
    }
}

/*
 * Operators
 */
template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::operator ==(const Graph& graph2) const {
    // optimization: if sizes not same, graphs not equal
    if (nodes.size() != graph2.nodes.size()
            || arcs.size() != graph2.arcs.size()
            || nodeMap.size() != graph2.nodeMap.size()) {
        return false;
    }
    return graphCompare(graph2) == 0;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::operator !=(const Graph& graph2) const {
    return !(*this == graph2);
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::operator <(const Graph& graph2) const {
    return graphCompare(graph2) < 0;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::operator <=(const Graph& graph2) const {
    return graphCompare(graph2) <= 0;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::operator >(const Graph& graph2) const {
    return graphCompare(graph2) > 0;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::operator >=(const Graph& graph2) const {
    return graphCompare(graph2) >= 0;
}

/**
 * Writes the given graph to the given output stream.
 * The insertion and extraction operators for graphs are more complicated
 * than for the standard collection types because the nodes and arcs can
 * contain client-specific data.  To ensure that this information is
 * correctly written and read by these operators, clients must override
 * the methods writeNodeData, writeArcData, scanNodeData, and scanArcData.
 */
template <typename NodeType, typename ArcType>
std::ostream& operator <<(std::ostream& os, const Graph<NodeType, ArcType>& g) {
    os << "{";
    bool started = false;
    for (NodeType* node : g.getNodeSet()) {
        if (started) {
            os << ", ";
        }
        writeGenericValue(os, node->name, stringIsInteger(node->name) || stringIsReal(node->name));
        g.writeNodeData(os, node);
        started = true;
    }
    for (ArcType* arc : g.getArcSet()) {
        os << ", ";
        writeGenericValue(os, arc->start->name, stringIsInteger(arc->start->name) || stringIsReal(arc->start->name));
        os << " -> ";
        writeGenericValue(os, arc->finish->name, stringIsInteger(arc->finish->name) || stringIsReal(arc->finish->name));
        g.writeArcData(os, arc);
    }
    return os << "}";
}

/**
 * Reads the given graph from the given input stream.
 * The insertion and extraction operators for graphs are more complicated
 * than for the standard collection types because the nodes and arcs can
 * contain client-specific data.  To ensure that this information is
 * correctly written and read by these operators, clients must override
 * the methods writeNodeData, writeArcData, scanNodeData, and scanArcData.
 */
template <typename NodeType, typename ArcType>
std::istream& operator >>(std::istream& is, Graph<NodeType, ArcType>& g) {
    TokenScanner scanner(is);
    scanner.ignoreWhitespace();
    scanner.scanNumbers();
    scanner.scanStrings();
    scanner.addOperator("->");
    std::string token = scanner.nextToken();
    if (token != "{") {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("Graph::operator >>: Missing {");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }
    g.clear();
    while (g.scanGraphEntry(scanner)) {
        token = scanner.nextToken();
        if (token == "}") {
            scanner.saveToken(token);
        } else if (token != ",") {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
            error("Graph::operator >>: Unexpected token " + token);
#endif
            is.setstate(std::ios_base::failbit);
            return is;
        }
    }
    token = scanner.nextToken();
    if (token != "}") {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("Graph::operator >>: Missing }");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }
    return is;
}

/**
 * Template hash function for graphs.
 */
template <typename NodeType, typename ArcType>
int hashCode(const Graph<NodeType, ArcType>& graph) {
    int code = hashSeed();
    for (NodeType* node : graph) {
        code = hashMultiplier() * code + hashCode(node->name);
    }
    for (ArcType* arc : graph.getArcSet()) {
        code = hashMultiplier() * code + hashCode(arc->start->name);
        code = hashMultiplier() * code + hashCode(arc->finish->name);
    }
    return (code & hashMask());
}

#endif // _graph_h

/////////////////////// END code extracted from StanfordCPPLib/collections/graph.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/gridlocation.h ///////////////////////
/*
 * File: gridlocation.h
 * --------------------
 * This file exports the <code>GridLocation</code> structure, which is a small
 * structure representing a row and column.
 * The row/column values are allowed to be negative or out of bounds; if an
 * out-of-bounds location is passed to a grid, the grid will throw an error.
 *
 * Several members of the <code>Grid</code> and <code>SparseGrid</code> classes
 * have been retrofitted to accept <code>GridLocation</code>s in place of integers
 * for row/column indexes.
 *
 * This file also declares the <code>GridLocationRange</code> class,
 * which represents a 2D range of grid locations that can be looped over.
 *
 * See gridlocation.cpp for the implementation of each member.
 *
 * @version 2018/03/12
 * - initial version
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _gridlocation_h
#define _gridlocation_h

#include <iostream>
#include <iterator>
#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

class GridLocationRange;   // forward declaration

struct GridLocation {
public:
    /*
     * Constructs a location representing the given row and column (default 0).
     * Any indexes are allowed, including negatives and out-of-bounds indexes.
     */
    GridLocation(int row = 0, int col = 0);

    /*
     * Returns a range of locations that are <= the given range away from this one.
     * For example, if you pass 1, will return the 9 locations in range (r-1, c-1) thru (r+1, c+1).
     * The rowMajor parameter indicates whether the range will emit its members
     * in row-major (default) or column-major order.
     */
    GridLocationRange neighbors(int range = 1, bool rowMajor = true) const;

    /*
     * Returns a string representation of this location, such as "r2c17".
     */
    std::string toString() const;

    /* row and column data - may be directly accessed or modified */
    int row;
    int col;
};

/*
 * Returns an integer hash code for this grid location.
 */
int hashCode(const GridLocation& loc);

/*
 * Relational operators for comparing grid locations.
 */
bool operator <(const GridLocation& loc1, const GridLocation& loc2);
bool operator <=(const GridLocation& loc1, const GridLocation& loc2);
bool operator ==(const GridLocation& loc1, const GridLocation& loc2);
bool operator !=(const GridLocation& loc1, const GridLocation& loc2);
bool operator >(const GridLocation& loc1, const GridLocation& loc2);
bool operator >=(const GridLocation& loc1, const GridLocation& loc2);

/*
 * I/O stream operators for reading or writing locations in their toString format.
 */
std::ostream& operator <<(std::ostream& out, const GridLocation& loc);
std::istream& operator >>(std::istream& input, GridLocation& loc);


/*
 * Represents a range of grid locations.
 * The actual individual grid locations are not all created and stored in
 * this object; that would require a lot of memory usage.
 * Instead, we primarily use this class for for-each looping over a given range
 * of locations using its internal iterator.
 *
 * Common usage pattern:
 * GridLocationRange range(0, 0, 10, 5);
 * for (GridLocation loc : range) { ... }
 *
 * or, if you have a Grid collection, its locations() method returns a GridLocationRange
 * object that you can loop over directly.
 *
 * for (GridLocation loc : grid.locations()) { ... }
 */
class GridLocationRange {
private:
    /*
     * Internal iterator over range of indexes.
     */
    class GridLocationRangeIterator : public std::iterator<std::input_iterator_tag, GridLocation> {
    private:
        const GridLocationRange* glr;
        GridLocation loc;

    public:
        GridLocationRangeIterator(const GridLocationRange* glr, bool end)
                : glr(glr) {
            if (end) {
                loc.row = glr->endRow() + 1;
                loc.col = glr->endCol() + 1;
            } else {
                loc = glr->startLocation();
            }
        }

        GridLocationRangeIterator(const GridLocationRangeIterator& itr)
                : glr(itr.glr),
                  loc(itr.loc) {
            // empty
        }

        GridLocationRangeIterator& operator ++() {
            if (glr->isRowMajor()) {
                loc.col++;
                if (loc.col > glr->endCol()) {
                    loc.col = glr->startCol();
                    loc.row++;
                }
            } else {
                loc.row++;
                if (loc.row > glr->endRow()) {
                    loc.row = glr->startRow();
                    loc.col++;
                }
            }
            if (!glr->contains(loc)) {
                loc.row = glr->endRow() + 1;
                loc.col = glr->endCol() + 1;
            }
            return *this;
        }

        GridLocationRangeIterator operator ++(int) {
            GridLocationRangeIterator copy(*this);
            operator++();
            return copy;
        }

        GridLocationRangeIterator& operator --() {
            if (glr->isRowMajor()) {
                loc.col--;
                if (loc.col < glr->startCol()) {
                    loc.col = glr->endCol();
                    loc.row--;
                }
            } else {
                loc.row--;
                if (loc.row < glr->startRow()) {
                    loc.row = glr->endRow();
                    loc.col--;
                }
            }
            return *this;
        }

        GridLocationRangeIterator operator --(int) {
            GridLocationRangeIterator copy(*this);
            operator--();
            return copy;
        }

        bool operator ==(const GridLocationRangeIterator& rhs) const {
            return loc == rhs.loc;
        }

        bool operator !=(const GridLocationRangeIterator& rhs) const {
            return !(*this == rhs);
        }

        bool operator <(const GridLocationRangeIterator& rhs) const {
            if (glr != rhs.glr) {
                error("GridLocationRange Iterator::operator <: Iterators are in different ranges");
            }
            return loc < rhs.loc;
        }

        bool operator <=(const GridLocationRangeIterator& rhs) const {
            if (glr != rhs.glr) {
                error("GridLocationRange Iterator::operator <=: Iterators are in different ranges");
            }
            return loc <= rhs.loc;
        }

        bool operator >(const GridLocationRangeIterator& rhs) const {
            if (glr != rhs.glr) {
                error("GridLocationRange Iterator::operator >: Iterators are in different ranges");
            }
            return loc > rhs.loc;
        }

        bool operator >=(const GridLocationRangeIterator& rhs) const {
            if (glr != rhs.glr) {
                error("GridLocationRange Iterator::operator >=: Iterators are in different ranges");
            }
            return loc >= rhs.loc;
        }

        const GridLocation& operator *() const {
            return loc;
        }

        const GridLocation* operator ->() const {
            return &loc;
        }
    };

    GridLocation _start;
    GridLocation _end;
    bool _isRowMajor;

public:
    /*
     * Constructs a range over the given start/end locations, inclusive.
     * The isRowMajor flag indicates whether we will loop over the range in
     * row-major order (true, default) or column-major order (false).
     */
    GridLocationRange(int startRow = 0, int startCol = 0, int endRow = 0, int endCol = 0, bool isRowMajor = true);

    /*
     * Constructs a range over the given start/end locations, inclusive.
     * The isRowMajor flag indicates whether we will loop over the range in
     * row-major order (true, default) or column-major order (false).
     */
    GridLocationRange(const GridLocation& startLoc, const GridLocation& endLoc, bool isRowMajor = true);

    /*
     * Returns an iterator over the range.
     */
    GridLocationRangeIterator begin() const;

    /*
     * Returns true if this range entirely contains the given other range.
     */
    bool contains(const GridLocation& loc) const;

    /*
     * Returns an iterator at the end of the range.
     */
    GridLocationRangeIterator end() const;

    /*
     * Returns the last column in this range, inclusive.
     */
    int endCol() const;

    /*
     * Returns the last row/column location in this range, inclusive.
     */
    const GridLocation& endLocation() const;

    /*
     * Returns the last row in this range, inclusive.
     */
    int endRow() const;

    /*
     * Returns true if this range contains no rows or columns.
     */
    bool isEmpty() const;

    /*
     * Returns true if this range should be traversed in row-major order,
     * as specified at time of construction (default true).
     */
    bool isRowMajor() const;

    /*
     * Returns the first column in this range.
     */
    int startCol() const;

    /*
     * Returns the first row/column location in this range.
     */
    const GridLocation& startLocation() const;

    /*
     * Returns the first row in this range.
     */
    int startRow() const;

    /*
     * Returns a string representation of this range,
     * such as "[r1c3 .. r4c7]".
     */
    std::string toString() const;
};

/*
 * I/O stream operators for writing location ranges in their toString format.
 */
std::ostream& operator <<(std::ostream& out, const GridLocationRange& range);

#endif // _gridlocation_h

/////////////////////// END code extracted from StanfordCPPLib/collections/gridlocation.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/grid.h ///////////////////////
/*
 * File: grid.h
 * ------------
 * This file exports the <code>Grid</code> class, which offers a
 * convenient abstraction for representing a two-dimensional array.
 *
 * @version 2018/03/12
 * - added overloads that accept GridLocation: get, inBounds, locations, set, operator []
 * @version 2018/03/10
 * - added methods front, back, clear
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2017/10/18
 * - fix compiler warnings
 * @version 2016/12/09
 * - bug fix in resize method (credit to Liu Ren)
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * - made member variables actually private (oops)
 * - added size() method
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as
 *   {{1, 2, 3}, {4, 5, 6}}
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/20
 * - minor bug fixes in member initializers
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added template hashCode function
 * @version 2014/10/10
 * - added resize(true) function with ability to retain old contents
 * - made ==, != operators const as they should be
 * - added comparison operators ==, !=
 * 2014/08/16
 * - added width, height functions; added mapAllColumnMajor
 * 2014/07/09
 * - changed checkGridIndexes range checking function into a private member
 *   function to avoid unused-function errors on some newer compilers
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _grid_h
#define _grid_h

#include <initializer_list>
#include <iostream>
#include <string>
#include <sstream>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: Grid<ValueType>
 * ----------------------
 * This class stores an indexed, two-dimensional array.  The following code,
 * for example, creates an identity matrix of size <code>n</code>, in which
 * the elements are 1.0 along the main diagonal and 0.0 everywhere else:
 *
 *<pre>
 *    Grid&lt;double&gt; createIdentityMatrix(int n) {
 *       Grid&lt;double&gt; matrix(n, n);
 *       for (int i = 0; i &lt; n; i++) {
 *          matrix[i][i] = 1.0;
 *       }
 *       return matrix;
 *    }
 *</pre>
 */

template <typename ValueType>
class Grid {
public:
    /* Forward reference */
    class GridRow;
    class GridRowConst;

    /*
     * Constructor: Grid
     * Usage: Grid<ValueType> grid;
     *        Grid<ValueType> grid(nRows, nCols);
     * ------------------------------------------
     * Initializes a new grid.  The second form of the constructor is
     * more common and creates a grid with the specified number of rows
     * and columns.  Each element of the grid is initialized to the
     * default value for the type.  The default constructor creates an
     * empty grid for which the client must call <code>resize</code> to
     * set the dimensions.
     * The three-argument constructor also accepts an initial value and
     * fills every cell of the grid with that value.
     */
    Grid();
    Grid(int nRows, int nCols);
    Grid(int nRows, int nCols, const ValueType& value);

    /*
     * This constructor uses an initializer list to set up the grid.
     * Usage: Grid<int> grid {{1, 2, 3}, {4, 5, 6}};
     */
    Grid(std::initializer_list<std::initializer_list<ValueType> > list);

    /*
     * Destructor: ~Grid
     * -----------------
     * Frees any heap storage associated with this grid.
     */
    virtual ~Grid();
    
    /*
     * Method: back
     * Usage: ValueType value = grid.back();
     * -------------------------------------
     * Returns the last value in the grid in the order established by the
     * <code>foreach</code> macro.
     * This is equivalent to grid[numRows - 1][numCols - 1].
     * If the grid is empty, generates an error.
     */
    ValueType back() const;

    /*
     * Method: clear
     * Usage: grid.clear();
     * --------------------
     * Sets every value in the grid to its element type's default value.
     */
    void clear();

    /*
     * Method: equals
     * Usage: if (grid.equals(grid2)) ...
     * ----------------------------------
     * Returns <code>true</code> if this grid contains exactly the same
     * values as the given other grid.
     * Identical in behavior to the == operator.
     */
    bool equals(const Grid<ValueType>& grid2) const;
    
    /*
     * Method: fill
     * Usage: grid.fill(value);
     * ------------------------
     * Stores the given value in every cell of this grid.
     */
    void fill(const ValueType& value);

    /*
     * Method: front
     * Usage: ValueType value = grid.front();
     * --------------------------------------
     * Returns the first value in the grid in the order established by the
     * <code>foreach</code> macro.  This is equivalent to grid[0][0].
     * If the grid is empty, generates an error.
     */
    ValueType front() const;

    /*
     * Method: get
     * Usage: ValueType value = grid.get(row, col);
     * --------------------------------------------
     * Returns the element at the specified <code>row</code>/<code>col</code>
     * position in this grid.  This method signals an error if the
     * <code>row</code> and <code>col</code> arguments are outside
     * the grid boundaries.
     */
    ValueType get(int row, int col);
    const ValueType& get(int row, int col) const;
    ValueType get(const GridLocation& loc);
    const ValueType& get(const GridLocation& loc) const;

    /*
     * Method: height
     * Usage: int nRows = grid.height();
     * ---------------------------------
     * Returns the grid's height, that is, the number of rows in the grid.
     */
    int height() const;
    
    /*
     * Method: inBounds
     * Usage: if (grid.inBounds(row, col)) ...
     * ---------------------------------------
     * Returns <code>true</code> if the specified row and column position
     * is inside the bounds of the grid.
     */
    bool inBounds(int row, int col) const;
    bool inBounds(const GridLocation& loc) const;

    /*
     * Method: isEmpty
     * Usage: if (grid.isEmpty()) ...
     * ---------------------------------------
     * Returns <code>true</code> if the grid has 0 rows and/or 0 columns.
     */
    bool isEmpty() const;

    /*
     * Method: locations
     * Usage: for (GridLocation loc : grid.locations()) ...
     * ----------------------------------------------------
     * Returns a range of (row,col) locations found in this grid.
     * This allows a nice abstraction for looping over the 2D grid range
     * of indexes using a single for loop.
     * By default the locations are arranged in row-major order,
     * but if you pass the rowMajor parameter of false, the locations will be
     * returned in column-major order instead.
     */
    GridLocationRange locations(bool rowMajor = true) const;

    /*
     * Method: mapAll
     * Usage: grid.mapAll(fn);
     * -----------------------
     * Calls the specified function on each element of the grid.  The
     * elements are processed in <b><i>row-major order,</i></b> in which
     * all the elements of row 0 are processed, followed by the elements
     * in row 1, and so on.
     */
    void mapAll(void (*fn)(ValueType value)) const;
    void mapAll(void (*fn)(const ValueType& value)) const;

    template <typename FunctorType>
    void mapAll(FunctorType fn) const;

    /*
     * Method: mapAllColumnMajor
     * Usage: grid.mapAllColumnMajor(fn);
     * ----------------------------------
     * Calls the specified function on each element of the grid.  The
     * elements are processed in <b><i>column-major order,</i></b> in which
     * all the elements of column 0 are processed, followed by the elements
     * in column 1, and so on.
     */
    void mapAllColumnMajor(void (*fn)(ValueType value)) const;
    void mapAllColumnMajor(void (*fn)(const ValueType& value)) const;

    template <typename FunctorType>
    void mapAllColumnMajor(FunctorType fn) const;

    /*
     * Method: numCols
     * Usage: int nCols = grid.numCols();
     * ----------------------------------
     * Returns the number of columns in the grid.
     * This is equal to the grid's width.
     */
    int numCols() const;

    /*
     * Method: numRows
     * Usage: int nRows = grid.numRows();
     * ----------------------------------
     * Returns the number of rows in the grid.
     * This is equal to the grid's height.
     */
    int numRows() const;

    /*
     * Method: resize
     * Usage: grid.resize(nRows, nCols);
     * ---------------------------------
     * Reinitializes the grid to have the specified number of rows
     * and columns.  If the 'retain' parameter is true,
     * the previous grid contents are retained as much as possible.
     * If 'retain' is not passed or is false, any previous grid contents
     * are discarded.
     */
    void resize(int nRows, int nCols, bool retain = false);

    /*
     * Method: set
     * Usage: grid.set(row, col, value);
     * ---------------------------------
     * Replaces the element at the specified <code>row</code>/<code>col</code>
     * location in this grid with a new value.  This method signals an error
     * if the <code>row</code> and <code>col</code> arguments are outside
     * the grid boundaries.
     */
    void set(int row, int col, const ValueType& value);
    void set(const GridLocation& loc, const ValueType& value);

    /*
     * Method: size
     * Usage: int size = grid.size();
     * ------------------------------
     * Returns the total number of elements in the grid, which is equal to the
     * number of rows times the number of columns.
     */
    int size() const;

    /*
     * Method: toString
     * Usage: string str = grid.toString();
     * ------------------------------------
     * Converts the grid to a printable string representation.
     * The string returned is a 1-dimensional representation such as:
     * "{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}"
     */
    std::string toString() const;

    /*
     * Method: toString2D
     * Usage: string str = grid.toString2D();
     * --------------------------------------
     * Converts the grid to a printable string representation.
     * The string returned is a 2-dimensional representation such as:
     * "{{1, 2, 3},\n
     *   {4, 5, 6},\n
     *   {7, 8, 9}}"
     */
    std::string toString2D(
            std::string rowStart = "{",
            std::string rowEnd = "}",
            std::string colSeparator = ", ",
            std::string rowSeparator = ",\n ") const;

    /*
     * Method: width
     * Usage: int nCols = grid.width();
     * --------------------------------
     * Returns the grid's width, that is, the number of columns in the grid.
     */
    int width() const;


    /*
     * Operator: []
     * Usage:  grid[row][col]
     * ----------------------
     * Overloads <code>[]</code> to select elements from this grid.
     * This extension enables the use of traditional array notation to
     * get or set individual elements.  This method signals an error if
     * the <code>row</code> and <code>col</code> arguments are outside
     * the grid boundaries.
     */
    GridRow operator [](int row);
    const GridRowConst operator [](int row) const;
    ValueType& operator [](const GridLocation& loc);
    const ValueType& operator [](const GridLocation& loc) const;

    /*
     * Additional Grid operations
     * --------------------------
     * In addition to the methods listed in this interface, the Grid
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * The iteration forms process the grid in row-major order.
     */
    
    /*
     * Operator: ==
     * Usage: if (grid1 == grid2) ...
     * ------------------------------
     * Compares two grids for equality.
     */
    bool operator ==(const Grid& grid2) const;

    /*
     * Operator: !=
     * Usage: if (grid1 != grid2) ...
     * ------------------------------
     * Compares two grids for inequality.
     */
    bool operator !=(const Grid& grid2) const;
    
    /*
     * Operators: <, >, <=, >=
     * Usage: if (grid1 < grid2) ...
     * -----------------------------
     * Relational operators to compare two grids.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const Grid& grid2) const;
    bool operator <=(const Grid& grid2) const;
    bool operator >(const Grid& grid2) const;
    bool operator >=(const Grid& grid2) const;

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes: Grid data structure
     * -----------------------------------------
     * The Grid is internally managed as a dynamic array of elements.
     * The array itself is one-dimensional, the logical separation into
     * rows and columns is done by arithmetic computation.  The layout
     * is in row-major order, which is to say that the entire first row
     * is laid out contiguously, followed by the entire second row,
     * and so on.
     */

private:
    /* Instance variables */
    ValueType* elements;  /* A dynamic array of the elements   */
    int nRows;            /* The number of rows in the grid    */
    int nCols;            /* The number of columns in the grid */
    unsigned int m_version = 0;  // structure version for detecting invalid iterators

    /* Private method prototypes */

    /*
     * Throws an ErrorException if the given row/col are not within the range of
     * (0,0) through (rowMax-1,colMax-1) inclusive.
     * This is a consolidated error handler for all various Grid members that
     * accept index parameters.
     * The prefix parameter represents a text string to place at the start of
     * the error message, generally to help indicate which member threw the error.
     */
    void checkIndexes(int row, int col,
                      int rowMax, int colMax,
                      std::string prefix) const;
    int gridCompare(const Grid& grid2) const;

    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods
     * in the public interface would make that interface more
     * difficult to understand for the average client.
     */

    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return grids by value
     * and assign from one grid to another.  The entire contents of
     * the grid, including all elements, are copied.  Each grid
     * element is copied from the original grid to the copy using
     * assignment (operator=).  Making copies is generally avoided
     * because of the expense and thus, grids are typically passed
     * by reference, however, when a copy is needed, these operations
     * are supported.
     */
    void deepCopy(const Grid& grid) {
        int n = grid.nRows * grid.nCols;
        elements = new ValueType[n];
        for (int i = 0; i < n; i++) {
            elements[i] = grid.elements[i];
        }
        nRows = grid.nRows;
        nCols = grid.nCols;
        m_version++;
    }

public:
    Grid& operator =(const Grid& src) {
        if (this != &src) {
            delete[] elements;
            deepCopy(src);
        }
        return *this;
    }

    Grid(const Grid& src) {
        deepCopy(src);
    }

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public std::iterator<std::input_iterator_tag, ValueType> {
    public:
        iterator(const Grid* theGp, int theIndex)
                : gp(theGp),
                  index(theIndex),
                  itr_version(theGp->version()) {
            // empty
        }

        iterator(const iterator& it)
                : gp(it.gp),
                  index(it.index),
                  itr_version(it.itr_version) {
            // empty
        }

        iterator& operator ++() {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            index++;
            return *this;
        }

        iterator operator ++(int) {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const iterator& rhs) {
            return gp == rhs.gp && index == rhs.index;
        }

        bool operator !=(const iterator& rhs) {
            return !(*this == rhs);
        }

        ValueType& operator *() {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            return gp->elements[index];
        }

        ValueType* operator ->() {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            return &gp->elements[index];
        }

        unsigned int version() const {
            return itr_version;
        }

    private:
        const Grid* gp;
        int index;
        unsigned int itr_version;
    };

    iterator begin() const {
        return iterator(this, 0);
    }

    iterator end() const {
        return iterator(this, nRows * nCols);
    }

    /*
     * Returns the internal version of this collection.
     * This is used to check for invalid iterators and issue error messages.
     */
    unsigned int version() const;

    /*
     * Private class: Grid<ValType>::GridRow
     * -------------------------------------
     * This section of the code defines a nested class within the Grid template
     * that makes it possible to use traditional subscripting on Grid values.
     */
    class GridRow {
    public:
        GridRow() : gp(nullptr), row(0) {
            /* Empty */
        }

        ValueType& operator [](int col) {
            gp->checkIndexes(row, col, gp->nRows-1, gp->nCols-1, "operator [][]");
            gp->m_version++;
            return gp->elements[(row * gp->nCols) + col];
        }

        ValueType operator [](int col) const {
            gp->checkIndexes(row, col, gp->nRows-1, gp->nCols-1, "operator [][]");
            return gp->elements[(row * gp->nCols) + col];
        }

        int size() const {
            return gp->width();
        }

    private:
        GridRow(Grid* gridRef, int index) {
            gp = gridRef;
            row = index;
        }

        Grid* gp;
        int row;
        friend class Grid;
    };
    friend class GridRow;

    class GridRowConst {
    public:
        GridRowConst() : gp(nullptr), row(0) {
            /* Empty */
        }

        const ValueType operator [](int col) const {
            gp->checkIndexes(row, col, gp->nRows-1, gp->nCols-1, "operator [][]");
            return gp->elements[(row * gp->nCols) + col];
        }

        int size() const {
            return gp->width();
        }

    private:
        GridRowConst(Grid* const gridRef, int index) : gp(gridRef), row(index) {}

        const Grid* const gp;
        const int row;
        friend class Grid;
    };
    friend class GridRowConst;
};

template <typename ValueType>
Grid<ValueType>::Grid()
        : elements(nullptr),
          nRows(0),
          nCols(0) {
    // empty
}

template <typename ValueType>
Grid<ValueType>::Grid(int numRows, int numCols)
        : elements(nullptr),
          nRows(0),
          nCols(0) {
    resize(numRows, numCols);
}

template <typename ValueType>
Grid<ValueType>::Grid(int numRows, int numCols, const ValueType& value)
        : elements(nullptr),
          nRows(0),
          nCols(0) {
    resize(numRows, numCols);
    fill(value);
}

template <typename ValueType>
Grid<ValueType>::Grid(std::initializer_list<std::initializer_list<ValueType> > list)
        : elements(nullptr),
          nRows(0),
          nCols(0) {
    // create the grid at the proper size
    nRows = list.size();
    if (list.begin() != list.end()) {
        nCols = list.begin()->size();
    }
    resize(nRows, nCols);

    // copy the data from the initializer list into the Grid
    auto rowItr = list.begin();
    for (int row = 0; row < nRows; row++) {
        if (static_cast<int>(rowItr->size()) != nCols) {
            error("Grid::constructor: initializer list is not rectangular (must have same # cols in each row)");
        }
        auto colItr = rowItr->begin();
        for (int col = 0; col < nCols; col++) {
            set(row, col, *colItr);
            colItr++;
        }
        rowItr++;
    }
}

template <typename ValueType>
Grid<ValueType>::~Grid() {
    if (elements) {
        delete[] elements;
        elements = nullptr;
    }
}

template <typename ValueType>
ValueType Grid<ValueType>::back() const {
    if (isEmpty()) {
        error("Grid::back: grid is empty");
    }
    return get(nRows - 1, nCols - 1);
}

template <typename ValueType>
void Grid<ValueType>::clear() {
    ValueType defaultValue = ValueType();
    for (int r = 0; r < nRows; r++) {
        for (int c = 0; c < nCols; c++) {
            set(r, c, defaultValue);
        }
    }
}

template <typename ValueType>
bool Grid<ValueType>::equals(const Grid<ValueType>& grid2) const {
    // optimization: if literally same grid, stop
    if (this == &grid2) {
        return true;
    }
    
    if (nRows != grid2.nRows || nCols != grid2.nCols) {
        return false;
    }
    for (int row = 0; row < nRows; row++) {
        for (int col = 0; col < nCols; col++) {
            if (get(row, col) != grid2.get(row, col)) {
                return false;
            }
        }
    }
    return true;
}

template <typename ValueType>
void Grid<ValueType>::fill(const ValueType& value) {
    for (int row = 0; row < nRows; row++) {
        for (int col = 0; col < nCols; col++) {
            set(row, col, value);
        }
    }
}

template <typename ValueType>
ValueType Grid<ValueType>::front() const {
    if (isEmpty()) {
        error("Grid::front: grid is empty");
    }
    return get(0, 0);
}

template <typename ValueType>
ValueType Grid<ValueType>::get(int row, int col) {
    checkIndexes(row, col, nRows-1, nCols-1, "get");
    return elements[(row * nCols) + col];
}

template <typename ValueType>
const ValueType& Grid<ValueType>::get(int row, int col) const {
    checkIndexes(row, col, nRows-1, nCols-1, "get");
    return elements[(row * nCols) + col];
}

template <typename ValueType>
ValueType Grid<ValueType>::get(const GridLocation& loc) {
    return get(loc.row, loc.col);
}

template <typename ValueType>
const ValueType& Grid<ValueType>::get(const GridLocation& loc) const {
    return get(loc.row, loc.col);
}

template <typename ValueType>
int Grid<ValueType>::height() const {
    return nRows;
}

template <typename ValueType>
bool Grid<ValueType>::inBounds(int row, int col) const {
    return row >= 0 && col >= 0 && row < nRows && col < nCols;
}

template <typename ValueType>
bool Grid<ValueType>::inBounds(const GridLocation& loc) const {
    return inBounds(loc.row, loc.col);
}

template <typename ValueType>
bool Grid<ValueType>::isEmpty() const {
    return nRows == 0 || nCols == 0;
}

template <typename ValueType>
GridLocationRange Grid<ValueType>::locations(bool rowMajor) const {
    return GridLocationRange(0, 0, numRows() - 1, numCols() - 1, rowMajor);
}

template <typename ValueType>
void Grid<ValueType>::mapAll(void (*fn)(ValueType value)) const {
    for (int i = 0; i < nRows; i++) {
        for (int j = 0; j < nCols; j++) {
            fn(get(i, j));
        }
    }
}

template <typename ValueType>
void Grid<ValueType>::mapAll(void (*fn)(const ValueType& value)) const {
    for (int i = 0; i < nRows; i++) {
        for (int j = 0; j < nCols; j++) {
            fn(get(i, j));
        }
    }
}

template <typename ValueType>
template <typename FunctorType>
void Grid<ValueType>::mapAll(FunctorType fn) const {
    for (int i = 0; i < nRows; i++) {
        for (int j = 0; j < nCols; j++) {
            fn(get(i, j));
        }
    }
}

template <typename ValueType>
void Grid<ValueType>::mapAllColumnMajor(void (*fn)(ValueType value)) const {
    for (int j = 0; j < nCols; j++) {
        for (int i = 0; i < nRows; i++) {
            fn(get(i, j));
        }
    }
}

template <typename ValueType>
void Grid<ValueType>::mapAllColumnMajor(void (*fn)(const ValueType& value)) const {
    for (int j = 0; j < nCols; j++) {
        for (int i = 0; i < nRows; i++) {
            fn(get(i, j));
        }
    }
}

template <typename ValueType>
template <typename FunctorType>
void Grid<ValueType>::mapAllColumnMajor(FunctorType fn) const {
    for (int j = 0; j < nCols; j++) {
        for (int i = 0; i < nRows; i++) {
            fn(get(i, j));
        }
    }
}

template <typename ValueType>
int Grid<ValueType>::numCols() const {
    return nCols;
}

template <typename ValueType>
int Grid<ValueType>::numRows() const {
    return nRows;
}

template <typename ValueType>
void Grid<ValueType>::resize(int numRows, int numCols, bool retain) {
    if (numRows < 0 || numCols < 0) {
        std::ostringstream out;
        out << "Grid::resize: Attempt to resize grid to invalid size ("
               << numRows << ", " << numCols << ")";
        error(out.str());
    }

    // optimization: don't do the resize if we are already that size
    if (numRows == this->nRows && numCols == this->nCols && retain) {
        return;
    }
    
    // save backup of old array/size
    ValueType* oldElements = this->elements;
    int oldnRows = this->nRows;
    int oldnCols = this->nCols;
    
    // create new empty array and set new size
    this->nRows = numRows;
    this->nCols = numCols;
    this->elements = new ValueType[numRows * numCols];
    
    // initialize to empty/default state
    ValueType value = ValueType();
    for (int i = 0; i < numRows * numCols; i++) {
        this->elements[i] = value;
    }
    
    // possibly retain old contents
    if (retain) {
        int minRows = oldnRows < numRows ? oldnRows : numRows;
        int minCols = oldnCols < numCols ? oldnCols : numCols;
        for (int row = 0; row < minRows; row++) {
            for (int col = 0; col < minCols; col++) {
                this->elements[(row * numCols) + col] = oldElements[(row * oldnCols) + col];
            }
        }
    }
    
    // free old array memory
    if (oldElements) {
        delete[] oldElements;
    }
    m_version++;
}

template <typename ValueType>
void Grid<ValueType>::set(int row, int col, const ValueType& value) {
    checkIndexes(row, col, nRows - 1, nCols - 1, "set");
    elements[(row * nCols) + col] = value;
    m_version++;
}

template <typename ValueType>
void Grid<ValueType>::set(const GridLocation& loc, const ValueType& value) {
    set(loc.row, loc.col, value);
}

template <typename ValueType>
int Grid<ValueType>::size() const {
    return nRows * nCols;
}

template <typename ValueType>
std::string Grid<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
unsigned int Grid<ValueType>::version() const {
    return m_version;
}

template <typename ValueType>
std::string Grid<ValueType>::toString2D(
        std::string rowStart, std::string rowEnd,
        std::string colSeparator, std::string rowSeparator) const {
    std::ostringstream os;
    os << rowStart;
    int nr = numRows();
    int nc = numCols();
    for (int i = 0; i < nr ; i++) {
        if (i > 0) {
            os << rowSeparator;
        }
        os << rowStart;
        for (int j = 0; j < nc; j++) {
            if (j > 0) {
                os << colSeparator;
            }
            writeGenericValue(os, get(i, j), /* forceQuotes */ true);
        }
        os << rowEnd;
    }
    os << rowEnd;
    return os.str();
}

template <typename ValueType>
int Grid<ValueType>::width() const {
    return nCols;
}

template <typename ValueType>
typename Grid<ValueType>::GridRow Grid<ValueType>::operator [](int row) {
    return GridRow(this, row);
}

template <typename ValueType>
ValueType& Grid<ValueType>::operator [](const GridLocation& loc) {
    checkIndexes(loc.row, loc.col, nRows-1, nCols-1, "operator []");
    return elements[(loc.row * nCols) + loc.col];
}

template <typename ValueType>
const typename Grid<ValueType>::GridRowConst
Grid<ValueType>::operator [](int row) const {
    return GridRowConst(const_cast<Grid*>(this), row);
}

template <typename ValueType>
const ValueType& Grid<ValueType>::operator [](const GridLocation& loc) const {
    checkIndexes(loc.row, loc.col, nRows-1, nCols-1, "operator []");
    return elements[(loc.row * nCols) + loc.col];
}

template <typename ValueType>
bool Grid<ValueType>::operator ==(const Grid& grid2) const {
    return equals(grid2);
}

template <typename ValueType>
bool Grid<ValueType>::operator !=(const Grid& grid2) const {
    return !equals(grid2);
}

template <typename ValueType>
bool Grid<ValueType>::operator <(const Grid& grid2) const {
    return gridCompare(grid2) < 0;
}

template <typename ValueType>
bool Grid<ValueType>::operator <=(const Grid& grid2) const {
    return gridCompare(grid2) <= 0;
}

template <typename ValueType>
bool Grid<ValueType>::operator >(const Grid& grid2) const {
    return gridCompare(grid2) > 0;
}

template <typename ValueType>
bool Grid<ValueType>::operator >=(const Grid& grid2) const {
    return gridCompare(grid2) >= 0;
}

template <typename ValueType>
void Grid<ValueType>::checkIndexes(int row, int col,
                                   int rowMax, int colMax,
                                   std::string prefix) const {
    const int rowMin = 0;
    const int colMin = 0;
    if (row < rowMin || row > rowMax || col < colMin || col > colMax) {
        std::ostringstream out;
        out << "Grid::" << prefix << ": (" << row << ", " << col << ")"
            << " is outside of valid range [";
        if (rowMin < rowMax && colMin < colMax) {
            out << "(" << rowMin << ", " << colMin <<  ")..("
                << rowMax << ", " << colMax << ")";
        } else if (rowMin == rowMax && colMin == colMax) {
            out << "(" << rowMin << ", " << colMin <<  ")";
        } // else min > max, no range, empty grid
        out << "]";
        error(out.str());
    }
}

template <typename ValueType>
int Grid<ValueType>::gridCompare(const Grid& grid2) const {
    int h1 = height();
    int w1 = width();
    int h2 = grid2.height();
    int w2 = grid2.width();
    int rows = h1 > h2 ? h1 : h2;
    int cols = w1 > w2 ? w1 : w2;
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (r >= h1) {
                return -1;
            } else if (r >= h2) {
                return 1;
            }
            
            if (c >= w1) {
                return -1;
            } else if (c >= w2) {
                return 1;
            }
            
            if (get(r, c) < grid2.get(r, c)) {
                return -1;
            } else if (grid2.get(r, c) < get(r, c)) {
                return 1;
            }
        }
    }
    return 0;
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const Grid<ValueType>& grid) {
    os << "{";
    int nRows = grid.numRows();
    int nCols = grid.numCols();
    for (int i = 0; i < nRows; i++) {
        if (i > 0) {
            os << ", ";
        }
        os << "{";
        for (int j = 0; j < nCols; j++) {
            if (j > 0) {
                os << ", ";
            }
            writeGenericValue(os, grid.get(i, j), /* forceQuotes */ true);
        }
        os << "}";
    }
    return os << "}";
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, Grid<ValueType>& grid) {
    Vector<Vector<ValueType> > vec2d;
    if (!(is >> vec2d)) {
        is.setstate(std::ios_base::failbit);
        return is;
    }

    int nRows = vec2d.size();
    int nCols = (nRows == 0) ? 0 : vec2d[0].size();
    grid.resize(nRows, nCols);
    for (int i = 0; i < nRows; i++) {
        for (int j = 0; j < nCols; j++) {
            grid[i][j] = vec2d[i][j];
        }
    }

    return is;
}

/*
 * Template hash function for grids.
 * Requires the element type in the Grid to have a hashCode function.
 */
template <typename T>
int hashCode(const Grid<T>& g) {
    return stanfordcpplib::collections::hashCodeCollection(g);
}

/*
 * Function: randomElement
 * Usage: element = randomElement(grid);
 * -------------------------------------
 * Returns a randomly chosen element of the given grid.
 * Throws an error if the grid is empty.
 */
template <typename T>
const T& randomElement(const Grid<T>& grid) {
    if (grid.isEmpty()) {
        error("randomElement: empty grid was passed");
    }

    int randomIndex = randomInteger(0, grid.size() - 1);
    int row = randomIndex / grid.numCols();
    int col = randomIndex % grid.numCols();
    return grid.get(row, col);
}

/*
 * Randomly rearranges the elements of the given grid.
 */
template <typename T>
void shuffle(Grid<T>& grid) {
    int rows = grid.numRows();
    int cols = grid.numCols();
    int length = rows * cols;
    for (int i = 0; i < length; i++) {
        int j = randomInteger(i, length - 1);
        if (i != j) {
            int r1 = i / cols;
            int c1 = i % cols;
            int r2 = j / cols;
            int c2 = j % cols;
            T temp = grid[r1][c1];
            grid[r1][c1] = grid[r2][c2];
            grid[r2][c2] = temp;
        }
    }
}

#endif // _grid_h

/////////////////////// END code extracted from StanfordCPPLib/collections/grid.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/lexicon.h ///////////////////////
/*
 * File: lexicon.h
 * ---------------
 * This file exports the <code>Lexicon</code> class, which is a
 * compact structure for storing a list of words.
 *
 * @author Marty Stepp
 * @version 2018/03/10
 * - added methods front, back
 * @version 2016/12/09
 * - added iterator version checking support (implicitly via Set)
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/12
 * - added methods addAll, containsAll, removeAll, retainAll,
 *   operators +, +=, -, -=, *, *= to better match Set/HashSet
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as {"a", "b", "c"}
 * @version 2014/11/13
 * - added comparison operators <, >= etc.
 * - added hashCode function
 * @version 2014/10/10
 * - added equals method, comparison operators ==, !=
 * - fixed inclusion of foreach macro to avoid errors
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _lexicon_h
#define _lexicon_h

#include <initializer_list>
#include <iterator>
#include <set>
#include <string>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * This class is used to represent a <b><i>lexicon,</i></b> or word list.
 * The main difference between a lexicon and a dictionary is that
 * a lexicon does not provide any mechanism for storing definitions;
 * the lexicon contains only words, with no associated information.
 * It is therefore similar to a set of strings, but with a more
 * space-efficient internal representation.  The <code>Lexicon</code>
 * class supports efficient lookup operations for words and prefixes.
 *
 * <p>As an example of the use of the <code>Lexicon</code> class, the
 * following program lists all the two-letter words in the lexicon
 * stored in <code>EnglishWords.dat</code>:
 *
 *<pre>
 *    int main() {
 *       Lexicon english("EnglishWords.dat");
 *       for (string word : english) {
 *          if (word.length() == 2) {
 *             cout << word << endl;
 *          }
 *       }
 *       return 0;
 *    }
 *</pre>
 */

class Lexicon {
public:
    /*
     * Constructor: Lexicon
     * Usage: Lexicon lex;
     *        Lexicon lex(filename);
     * -----------------------------
     * Initializes a new lexicon.  The default constructor creates an empty
     * lexicon.  The second form reads in the contents of the lexicon from
     * the specified data file.  The data file must be in one of two formats:
     * (1) a space-efficient precompiled binary format or (2) a text file
     * containing one word per line.  The Stanford library distribution
     * includes a binary lexicon file named <code>English.dat</code>
     * containing a list of words in English.  The standard code pattern
     * to initialize that lexicon looks like this:
     *
     *<pre>
     *    Lexicon english("English.dat");
     *</pre>
     */
    Lexicon();
    Lexicon(std::istream& input);
    Lexicon(const std::string& filename);

    /*
     * This constructor uses an initializer list to set up the lexicon.
     * Usage: Lexicon lex {1, 2, 3};
     */
    Lexicon(std::initializer_list<std::string> list);

    /*
     * Destructor: ~Lexicon
     * --------------------
     * The destructor deallocates any storage associated with the lexicon.
     */
    virtual ~Lexicon();

    /**
     * Adds the specified word to the lexicon, if not already present.
     * The word is converted to lowercase before adding it to the lexicon.
     * If the word contains any non-alphabetic characters (including whitespace),
     * it will not be added. The empty string cannot be added to a lexicon.
     * Returns true if the word was added successfully to the lexicon.
     */
    bool add(const std::string& word);

    /**
     * Adds all elements of the given other lexicon to this lexicon.
     * Returns a reference to this lexicon.
     * Identical in behavior to the += operator.
     */
    Lexicon& addAll(const Lexicon& lex);

    /**
     * Adds all elements of the given initializer list to this lexicon.
     * Returns a reference to this lexicon.
     * Identical in behavior to the += operator.
     */
    Lexicon& addAll(std::initializer_list<std::string> list);

    /**
     * Reads the given input stream and adds all of its words to the lexicon.
     * Each word from the stream is converted to lowercase before adding it.
     */
    void addWordsFromFile(std::istream& input);
    
    /**
     * Reads the file and adds all of its words to the lexicon.
     * Each word from the file is converted to lowercase before adding it.
     */
    void addWordsFromFile(const std::string& filename);

    /**
     * Returns the last value in the lexicon in alphabetical order.
     * If the set is empty, generates an error.
     */
    std::string back() const;

    /**
     * Removes all words from the lexicon.
     */
    void clear();

    /**
     * Returns <code>true</code> if <code>word</code> is contained in the
     * lexicon.  In the <code>Lexicon</code> class, the case of letters is
     * ignored, so "Zoo" is the same as "ZOO" or "zoo".
     * The empty string cannot be contained in a lexicon, nor can any word
     * containing any non-alphabetic characters such as punctuation or whitespace.
     */
    bool contains(const std::string& word) const;

    /**
     * Returns <code>true</code> if every value from the given other lexicon
     * is also found in this lexicon.
     * Equivalent in behavior to isSupersetOf.
     */
    bool containsAll(const Lexicon& set2) const;

    /**
     * Returns <code>true</code> if every value from the given initializer list
     * is also found in this lexicon.
     * Equivalent in behavior to isSupersetOf.
     */
    bool containsAll(std::initializer_list<std::string> list) const;

    /**
     * Returns true if any words in the lexicon begin with <code>prefix</code>.
     * Like <code>containsWord</code>, this method ignores the case of letters
     * so that "MO" is a prefix of "monkey" or "Monday".
     * The empty string is a prefix of every string, so this method returns
     * true when passed the empty string.
     */
    bool containsPrefix(const std::string& prefix) const;

    /**
     * Compares two lexicons for equality.
     */
    bool equals(const Lexicon& lex2) const;

    /**
     * Returns the first value in the lexicon in alphabetical order.
     * If the set is empty, <code>first</code> generates an error.
     * Equivalent to first.
     */
    std::string first() const;

    /**
     * Returns the first value in the lexicon in alphabetical order.
     * If the set is empty, generates an error.
     * Equivalent to first.
     */
    std::string front() const;

    /**
     * Adds an element to this lexicon, if it was not already there.  This
     * method is exported for compatibility with the STL <code>set</code> class.
     */
    void insert(const std::string& word);

    /**
     * Returns <code>true</code> if the lexicon contains no words.
     */
    bool isEmpty() const;

    /**
     * Returns whether every word of this lexicon is contained in the given set.
     */
    bool isSubsetOf(const Lexicon& lex2) const;

    /**
     * Returns whether every word of this lexicon is contained in the given
     * initializer list.
     */
    bool isSubsetOf(std::initializer_list<std::string> list) const;

    /**
     * Returns whether every word of the given lexicon is contained in this lexicon.
     * Equivalent in behavior to containsAll.
     */
    bool isSupersetOf(const Lexicon& lex2) const;

    /**
     * Returns whether every word of the given list is contained in this lexicon.
     * Equivalent in behavior to containsAll.
     */
    bool isSupersetOf(std::initializer_list<std::string> list) const;

    /**
     * Calls the specified function on each word in the lexicon.
     */
    void mapAll(void (*fn)(std::string)) const;

    /**
     * Calls the specified function on each word in the lexicon.
     */
    void mapAll(void (*fn)(const std::string&)) const;

    /**
     * Calls the specified function on each word in the lexicon.
     */
    template <typename FunctorType>
    void mapAll(FunctorType fn) const;

    /**
     * Removes the specified word from the lexicon, if it was present.
     * Returns true if the word was previously contained in the lexicon;
     * in other words, if a word was removed.
     * The empty string cannot be contained in a lexicon, so passing the
     * empty string to this method returns false.
     */
    bool remove(const std::string& word);

    /**
     * Removes all elements of the given other lexicon from this lexicon.
     * Returns a reference to this lexicon.
     * Identical in behavior to the -= operator.
     */
    Lexicon& removeAll(const Lexicon& lex);

    /**
     * Removes all elements of the given other list from this lexicon.
     * Returns a reference to this lexicon.
     * Identical in behavior to the -= operator.
     */
    Lexicon& removeAll(std::initializer_list<std::string> list);

    /**
     * Removes all words from the lexicon that begin with the given prefix.
     * Returns true if the prefix was previously contained in the lexicon;
     * in other words, if any words were removed.
     * If the empty string is passed, since all words begin with the empty
     * string, all words will be removed and this method will
     * return true if the lexicon was non-empty prior to the call.
     */
    bool removePrefix(const std::string& prefix);

    /**
     * Removes all elements from this lexicon that are not contained in the given
     * other lexicon.
     * Returns a reference to this lexicon.
     * Identical in behavior to the *= operator.
     */
    Lexicon& retainAll(const Lexicon& lex);

    /**
     * Removes all elements from this lexicon that are not contained in the given
     * initializer list.
     * Returns a reference to this lexicon.
     * Identical in behavior to the *= operator.
     */
    Lexicon& retainAll(std::initializer_list<std::string> list);

    /**
     * Returns the number of words contained in the lexicon.
     */
    int size() const;

    /**
     * Converts the lexicon to a printable string representation
     * such as <code>{"a", "b", "c"}</code>.
     * Note that this can be an expensive operation if the lexicon contains
     * a large number of words.
     */
    std::string toString() const;

    /**
     * Returns true if two lexicons have the same elements.
     */
    bool operator ==(const Lexicon& lex2) const;

    /**
     * Returns true if two lexicons do not have the same elements.
     */
    bool operator !=(const Lexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons.
     */
    bool operator <(const Lexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons.
     */
    bool operator <=(const Lexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons.
     */
    bool operator >(const Lexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons.
     */
    bool operator >=(const Lexicon& lex2) const;

    /**
     * Returns the union of lexicons <code>lex1</code> and <code>lex2</code>,
     * which is the set of words that appear in at least one of the two.
     */
    Lexicon operator +(const Lexicon& lex2) const;

    /**
     * Returns the union of this lexicon and the words in the given list,
     * which is the set of words that appear in at least one of the two.
     */
    Lexicon operator +(std::initializer_list<std::string> list) const;

    /**
     * Returns the union of this lexicon and the given word.
     */
    Lexicon operator +(const std::string& word) const;

    /**
     * Returns the intersection of two lexicons,
     * which is the set of all words that appear in both.
     */
    Lexicon operator *(const Lexicon& lex2) const;

    /**
     * Returns the intersection of this lexicons and the given list,
     * which is the set of all words that appear in both.
     */
    Lexicon operator *(std::initializer_list<std::string> list) const;

    /**
     * Returns the difference of two lexicons,
     * which is all of the words that appear in <code>lex1</code> but
     * not <code>lex2</code>.
     * You can also pass an initializer list such as {"a", "b", "c"}.
     * The right hand set can be replaced by a single word, in
     * which case the operator returns a new lexicon formed by removing that word.
     */
    Lexicon operator -(const Lexicon& lex2) const;

    /**
     * Returns the difference of two lexicons,
     * which is all of the words that appear in this lexicon but not in
     * the given initializer list.
     */
    Lexicon operator -(std::initializer_list<std::string> list) const;

    /**
     * Returns a new lexicon formed by removing the given word from this lexicon.
     */
    Lexicon operator -(const std::string& word) const;

    /**
     * Adds all of the words from the given lexicon to this lexicon.
     */
    Lexicon& operator +=(const Lexicon& lex2);

    /**
     * Adds all of the words from the given list to this lexicon.
     */
    Lexicon& operator +=(std::initializer_list<std::string> list);

    /**
     * Adds the specified word to this lexicon.
     */
    Lexicon& operator +=(const std::string& word);

    /**
     * Removes any elements from this lexicon that are not present in
     * <code>lex2</code>.
     */
    Lexicon& operator *=(const Lexicon& lex2);

    /**
     * Removes any elements from this lexicon that are not present in
     * the given initializer list.
     */
    Lexicon& operator *=(std::initializer_list<std::string> list);

    /**
     * Removes all elements in the given lexicon from this lexicon.
     */
    Lexicon& operator -=(const Lexicon& lex2);

    /**
     * Removes all elements in the given list from this lexicon.
     */
    Lexicon& operator -=(std::initializer_list<std::string> list);

    /**
     * Removes the given word from this lexicon.
     */
    Lexicon& operator -=(const std::string& value);

    /**
     * Allows you to add multiple elements to a lexicon.
     * @example lex += "she", "sells", "sea", "shells";
     */
    Lexicon& operator ,(const std::string& word);

    /*
     * Additional Lexicon operations
     * -----------------------------
     * In addition to the methods listed in this interface, the Lexicon
     * class supports the following operations:
     *
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * All iteration is guaranteed to proceed in alphabetical order.  All
     * words in the lexicon are stored in lowercase.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    struct TrieNode {
    public:
        TrieNode() {
            m_isWord = false;
            for (int i = 0; i < 26; i++) {
                m_children[i] = nullptr;
            }
        }

        // pre: letter is between 'a' and 'z' in lowercase
        inline TrieNode*& child(char letter) {
            return m_children[letter - 'a'];
        }

        inline int childCount() const {
            int count = 0;
            for (int i = 0; i < 26; i++) {
                if (m_children[i] != nullptr) {
                    count++;
                }
            }
            return count;
        }

        inline bool isLeaf() const {
            return childCount() == 0;
        }

        inline bool isWord() const {
            return m_isWord;
        }

        inline void setWord(bool value) {
            m_isWord = value;
        }

    private:
        /* instance variables */
        bool m_isWord;
        TrieNode* m_children[26];   // 0=a, 1=b, 2=c, ..., 25=z
    };

    /*
     * private helper functions, including
     * recursive helpers to implement public add/contains/remove
     */
    bool addHelper(TrieNode*& node, const std::string& word, const std::string& originalWord);
    bool containsHelper(TrieNode* node, const std::string& word, bool isPrefix) const;
    void deepCopy(const Lexicon& src);
    void deleteTree(TrieNode* node);
    bool isDAWGFile(std::istream& input) const;
    bool isDAWGFile(const std::string& filename) const;
    void readBinaryFile(std::istream& input);
    void readBinaryFile(const std::string& filename);
    bool removeHelper(TrieNode*& node, const std::string& word, const std::string& originalWord, bool isPrefix);
    void removeSubtreeHelper(TrieNode*& node, const std::string& originalWord);
    
    friend std::ostream& operator <<(std::ostream& os, const Lexicon& lex);
    friend std::istream& operator >>(std::istream& is, Lexicon& lex);

    /* instance variables */
    TrieNode* m_root;
    int m_size;
    bool m_removeFlag;             // flag to differentiate += and -= when used with ,
    Set<std::string> m_allWords;   // secondary structure of all words for foreach;
                                   // basically a cop-out so I can loop over words

public:
    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return lexicons by value
     * and assign from one lexicon to another.  The entire contents of
     * the lexicon, including all words, are copied.  Making copies is
     * generally avoided because of the expense and thus, lexicons are
     * typically passed by reference.  When a copy is needed, these
     * operations are supported.
     */
    Lexicon(const Lexicon& src);
    Lexicon& operator =(const Lexicon& src);

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public Set<std::string>::iterator {
    public:
        iterator() : Set<std::string>::iterator() {}
        iterator(const iterator& it) : Set<std::string>::iterator(it) {}
        iterator(const Set<std::string>::iterator& it) : Set<std::string>::iterator(it) {}
    };

    /**
     * Returns an iterator positioned at the first word in the lexicon.
     */
    iterator begin() const {
        return iterator(m_allWords.begin());
    }

    /**
     * Returns an iterator positioned at the last word in the lexicon.
     */
    iterator end() const {
        return iterator(m_allWords.end());
    }
};

template <typename FunctorType>
void Lexicon::mapAll(FunctorType fn) const {
    for (std::string word : *this) {
        fn(word);
    }
}

/**
 * Hashing function for lexicons.
 */
int hashCode(const Lexicon& l);

/**
 * Prints the lexicon to the given output stream.
 */
std::ostream& operator <<(std::ostream& os, const Lexicon& lex);

/**
 * Reads the contents of a lexicon from the given input stream.
 */
std::istream& operator >>(std::istream& is, Lexicon& lex);

#endif // _lexicon_h

/////////////////////// END code extracted from StanfordCPPLib/collections/lexicon.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/linkedlist.h ///////////////////////
/*
 * File: linkedlist.h
 * ------------------
 * This file exports the <code>LinkedList</code> class, which provides an
 * implementation of a doubly-linked list of objects and provides a
 * public interface similar to that of the <code>Vector</code> class.
 *
 * @version 2018/01/07
 * - added removeFront, removeBack
 * @version 2017/11/15
 * - added contains, indexOf, lastIndexOf, removeValue, reverse, shuffle, sort
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/10
 * - added support for std initializer_list usage, such as {1, 2, 3}
 *   in constructor, addAll, +, +=
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added template hashCode function
 * @version 2014/10/19
 * - added subList method
 * @version 2014/10/10
 * - removed usage of __foreach macro
 * 2014/07/10
 *  - fixed compiler errors/bugs in initial implementation:
 *    back(), front() members, etc.
 *  - changed checkLinkedListIndex into a member function to avoid warnings
 * @since 2014/07/10
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _linkedlist_h
#define _linkedlist_h

#include <algorithm>
#include <initializer_list>
#include <iostream>
#include <iterator>
#include <list>
#include <sstream>
#include <string>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: LinkedList<ValueType>
 * ----------------------------
 * This class stores an ordered list of values similar to an array.
 * It supports traditional array selection using square brackets, but
 * also supports inserting and deleting elements.  It is similar in
 * function to the STL <code>list</code> type.
 */
template <typename ValueType>
class LinkedList {
public:
    /*
     * Constructor: LinkedList
     * Usage: LinkedList<ValueType> list;
     * ----------------------------------
     * Initializes a new LinkedList.  The default constructor creates an
     * empty LinkedList.
     */
    LinkedList();
    /* implicit */ LinkedList(const std::list<ValueType>& v);

    /*
     * This constructor uses an initializer list to set up the linked list.
     * Usage: LinkedList<int> list {1, 2, 3};
     */
    LinkedList(std::initializer_list<ValueType> list);

    /*
     * Destructor: ~LinkedList
     * -------------------
     * Frees any heap storage allocated by this LinkedList.
     */
    virtual ~LinkedList();
    
    /*
     * Method: add
     * Usage: list.add(value);
     * ----------------------
     * Adds a new value to the end of this LinkedList.  To ensure compatibility
     * with the <code>LinkedList</code> class in the Standard Template Library,
     * this method is also called <code>push_back</code>.
     */
    void add(ValueType value);
    
    /*
     * Method: addAll
     * Usage: list.addAll(l2);
     * -----------------------
     * Adds all elements of the given other linked list to this list.
     * Returns a reference to this list.
     * Identical in behavior to the += operator.
     * You may also pass an initializer list such as {1, 2, 3}.
     */
    LinkedList<ValueType>& addAll(const LinkedList<ValueType>& list);
    LinkedList<ValueType>& addAll(std::initializer_list<ValueType> list);

    /*
     * Method: back
     * Usage: ValueType val = list.back();
     * -----------------------------------
     * Returns the element at the back (index size-1) of this LinkedList.
     * This method signals an error if the list is empty.
     */
    ValueType& back();
    const ValueType& back() const;

    /*
     * Method: clear
     * Usage: list.clear();
     * --------------------
     * Removes all elements from this LinkedList.
     */
    void clear();
    
    /*
     * Method: contains
     * Usage: if (list.contains(value)) ...
     * ------------------------------------
     * Returns true if the list contains the given value.
     * The ValueType must have an == operator to use this method.
     */
    bool contains(const ValueType& value) const;

    /*
     * Method: equals
     * Usage: if (list.equals(l2)) ...
     * -------------------------------
     * Returns <code>true</code> if this linked list contains exactly the same
     * values as the given other list.
     * Identical in behavior to the == operator.
     */
    bool equals(const LinkedList<ValueType>& l2) const;
    
    /*
     * Method: front
     * Usage: ValueType val = list.front();
     * ------------------------------------
     * Returns the element at the front (index 0) of this LinkedList.
     * This method signals an error if the list is empty.
     */
    ValueType& front();
    const ValueType& front() const;

    /*
     * Method: get
     * Usage: ValueType val = list.get(index);
     * ---------------------------------------
     * Returns the element at the specified index in this LinkedList.  This
     * method signals an error if the index is not in the list range.
     *
     * The client should be mindful that unlike with a vector, this operation
     * is O(N) for linked lists because it must traverse the list to reach
     * the given index.
     */
    const ValueType& get(int index) const;

    /*
     * Method: indexOf
     * Usage: int index = list.indexOf(value);
     * ---------------------------------------
     * Returns the index of the first occurrence of the given value.
     * If the value is not found in the vector, returns -1.
     * The ValueType must have an == operator to use this method.
     */
    int indexOf(const ValueType& value) const;

    /*
     * Method: insert
     * Usage: list.insert(0, value);
     * -----------------------------
     * Inserts the element into this LinkedList before the specified index.
     * This method signals an error if the index is outside the range from 0
     * up to and including the length of the LinkedList.
     */
    void insert(int index, ValueType value);

    /*
     * Method: isEmpty
     * Usage: if (list.isEmpty()) ...
     * ------------------------------
     * Returns <code>true</code> if this LinkedList contains no elements.
     */
    bool isEmpty() const;

    /*
     * Method: lastIndexOf
     * Usage: int index = list.lastIndexOf(value);
     * -------------------------------------------
     * Returns the index of the last occurrence of the given value.
     * If the value is not found in the vector, returns -1.
     * The ValueType must have an == operator to use this method.
     */
    int lastIndexOf(const ValueType& value) const;

    /*
     * Method: mapAll
     * Usage: list.mapAll(fn);
     * ----------------------
     * Calls the specified function on each element of the LinkedList in
     * ascending index order.
     */
    void mapAll(void (*fn)(ValueType)) const;
    void mapAll(void (*fn)(const ValueType &)) const;

    template <typename FunctorType>
    void mapAll(FunctorType fn) const;
    
    /*
     * Method: pop_back
     * Usage: ValueType back = list.pop_back();
     * ------------------------------------------
     * Removes and returns the last value of this LinkedList.
     * Throws an error if the list is empty.
     */
    ValueType pop_back();

    /*
     * Method: pop_front
     * Usage: ValueType front = list.pop_front();
     * ------------------------------------------
     * Removes and returns the first value of this LinkedList.
     * Throws an error if the list is empty.
     */
    ValueType pop_front();
    
    /*
     * Method: push_back
     * Usage: list.push_back(value);
     * -----------------------------
     * Adds a new value to the end of this LinkedList.
     * Same behavior as the <code>add</code> method.
     */
    void push_back(const ValueType& value);

    /*
     * Method: push_front
     * Usage: list.push_front(value);
     * ------------------------------
     * Adds a new value to the front of this LinkedList.
     */
    void push_front(const ValueType& value);
    
    /*
     * Method: remove
     * Usage: list.remove(index);
     * -------------------------
     * Removes the element at the specified index from this LinkedList.
     * This method signals an error if the index is outside the list range.
     */
    void remove(int index);

    /*
     * Method: removeFirst
     * Usage: ValueType val = list.removeFirst();
     * ------------------------------------------
     * Removes and returns the element at index 0 in this list.
     * This method signals an error if list is empty.
     */
    ValueType removeFront();

    /*
     * Method: removeLast
     * Usage: ValueType val = list.removeLast();
     * -----------------------------------------
     * Removes and returns the element at index (size - 1) in this list.
     * This method signals an error if list is empty.
     */
    ValueType removeBack();

    /*
     * Method: removeValue
     * Usage: list.removeValue(value);
     * -------------------------------
     * Removes the first occurrence of the element value from this list.
     * All subsequent elements are shifted one position to the left.
     * If the vector does not contain the given value, has no effect.
     * The ValueType must have an == operator to use this method.
     */
    void removeValue(const ValueType& value);

    /*
     * Method: reverse
     * Usage: list.reverse();
     * ----------------------
     * Reverses the order of the elements in this list.
     * For example, if the list stores {1, 3, 4, 9}, changes it to store {9, 4, 3, 1}.
     */
    void reverse();

    /*
     * Method: set
     * Usage: list.set(index, value);
     * ------------------------------
     * Replaces the element at the specified index in this LinkedList with
     * a new value.  The previous value at that index is overwritten.
     * This method signals an error if the index is not in the list range.
     *
     * The client should be mindful that unlike with a vector, this operation
     * is O(N) for linked lists because it must traverse the list to reach
     * the given index.
     */
    void set(int index, const ValueType& value);

    /*
     * Method: shuffle
     * Usage: list.shuffle();
     * ----------------------
     * Rearranges the order of the elements in this list into a random order.
     */
    void shuffle();

    /*
     * Method: size
     * Usage: int nElems = list.size();
     * --------------------------------
     * Returns the number of elements in this LinkedList.
     */
    int size() const;

    /*
     * Method: sort
     * Usage: list.sort();
     * -------------------
     * Rearranges the order of the elements in this list into sorted order.
     * For example, if the list stores {9, 1, 4, 3}, changes it to store {1, 3, 4, 9}.
     * The ValueType must have an operator < to call this method.
     */
    void sort();

    /*
     * Method: subList
     * Usage: LinkedList<ValueType> sub = list.subList(start, length);
     * ---------------------------------------------------------------
     * Returns a new list containing the given subset range of elements
     * from this list. The new list is a deep copy, not linked to this one.
     * Throws an error if the range (start .. start + length) is not contained
     * within the bounds of this list, or if length is negative.
     */
    LinkedList<ValueType> subList(int start, int length) const;
    
    /*
     * Method: toString
     * Usage: string str = list.toString();
     * ------------------------------------
     * Converts the LinkedList to a printable string representation.
     */
    std::string toString() const;

    /*
     * Operator: []
     * Usage: list[index]
     * -----------------
     * Overloads <code>[]</code> to select elements from this LinkedList.
     * This extension enables the use of traditional array notation to
     * get or set individual elements.  This method signals an error if
     * the index is outside the list range.  The file supports two
     * versions of this operator, one for <code>const</code> LinkedLists and
     * one for mutable LinkedLists.
     *
     * The client should be mindful that this operation is O(N) for linked
     * lists because it must traverse the list to reach the given index.
     */
    ValueType& operator [](int index);
    const ValueType& operator [](int index) const;

    /*
     * Operator: +
     * Usage: v1 + l2
     * --------------
     * Concatenates two LinkedLists, or concatenates this linked list with an
     * initializer list such as {1, 2, 3}.
     */
    LinkedList operator +(const LinkedList& l2) const;
    LinkedList operator +(std::initializer_list<ValueType> list) const;

    /*
     * Operator: +=
     * Usage: l1 += l2;
     *        l1 += value;
     * -------------------
     * Adds all of the elements from <code>l2</code> (or the single
     * specified value) to <code>l1</code>.  As a convenience, the
     * <code>LinkedList</code> package also overloads the comma operator so
     * that it is possible to initialize a LinkedList like this:
     *
     *<pre>
     *    LinkedList&lt;int&gt; digits;
     *    digits += 0, 1, 2, 3, 4, 5, 6, 7, 8, 9;
     *</pre>
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    LinkedList& operator +=(const LinkedList& l2);
    LinkedList& operator +=(std::initializer_list<ValueType> list);
    LinkedList& operator +=(const ValueType& value);

    /*
     * Comparing LinkedLists for equality.
     */
    bool operator ==(const LinkedList& list2) const;
    bool operator !=(const LinkedList& list2) const;


    /*
     * Operators: <, >, <=, >=
     * Usage: if (list1 == list2) ...
     * ...
     * -------------------------------
     * Relational operators to compare two lists.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const LinkedList& list2) const;
    bool operator <=(const LinkedList& list2) const;
    bool operator >(const LinkedList& list2) const;
    bool operator >=(const LinkedList& list2) const;

    /*
     * Additional LinkedList operations
     * --------------------------------
     * In addition to the methods listed in this interface, the LinkedList
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement or STL iterators
     *
     * The iteration forms process the LinkedList in index order.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    /*
     * Implementation notes: LinkedList data structure
     * -------------------------------------------
     * The elements of the LinkedList are stored in a dynamic array of
     * the specified element type.  If the space in the array is ever
     * exhausted, the implementation doubles the array capacity.
     */

    /* Instance variables */
    std::list<ValueType> m_elements;   // STL linked list as backing storage
    unsigned int m_version = 0;   // structure version for detecting invalid iterators

    /* Private methods */

    /*
     * Throws an ErrorException if the given index is not within the range of
     * [min..max] inclusive.
     * This is a consolidated error handler for all various LinkedList members that
     * accept index parameters.
     * The prefix parameter represents a text string to place at the start of
     * the error message, generally to help indicate which member threw the error.
     */
    void checkIndex(int index, int min, int max, std::string prefix) const;

    void deepCopy(const LinkedList& src);

    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods
     * in the public interface would make that interface more
     * difficult to understand for the average client.
     */

public:
    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a deep copy,
     * making it possible to pass or return LinkedLists by value and assign
     * from one LinkedList to another.
     */
    LinkedList(const LinkedList& src);
    LinkedList& operator =(const LinkedList& src);

    /*
     * Operator: ,
     * -----------
     * Adds an element to the LinkedList passed as the left-hand operatand.
     * This form makes it easier to initialize LinkedLists in old versions of C++.
     */
    LinkedList& operator ,(const ValueType& value);

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class linkedlist_iterator : public std::list<ValueType>::iterator {
    public:
        linkedlist_iterator()
                : std::list<ValueType>::iterator(),
                  llp(nullptr),
                  itr_version(0) {
            // empty
        }

        linkedlist_iterator(const linkedlist_iterator& it)
                : std::list<ValueType>::iterator(it),
                  llp(it.llp),
                  itr_version(it.itr_version) {
            // empty
        }

        linkedlist_iterator(LinkedList* llp, const typename std::list<ValueType>::iterator& it)
                : std::list<ValueType>::iterator(it),
                  llp(llp),
                  itr_version(llp->version()) {
            // empty
        }

        ValueType& operator *() {
            if (llp) {
                stanfordcpplib::collections::checkVersion(*llp, *this);
            }
            return std::list<ValueType>::iterator::operator *();   // call super
        }

        ValueType* operator ->() {
            if (llp) {
                stanfordcpplib::collections::checkVersion(*llp, *this);
            }
            return std::list<ValueType>::iterator::operator ->();   // call super
        }

        unsigned int version() const {
            return itr_version;
        }

    private:
        LinkedList* llp;
        unsigned int itr_version;
    };

    class const_linkedlist_iterator : public std::list<ValueType>::const_iterator {
    public:
        const_linkedlist_iterator()
                : std::list<ValueType>::const_iterator(),
                  llp(nullptr),
                  itr_version(0) {
            // empty
        }

        const_linkedlist_iterator(const const_linkedlist_iterator& it)
                : std::list<ValueType>::const_iterator(it),
                  llp(it.llp),
                  itr_version(it.itr_version) {
            // empty
        }

        const_linkedlist_iterator(const LinkedList* llp, const typename std::list<ValueType>::const_iterator& it)
                : std::list<ValueType>::const_iterator(it),
                  llp(llp),
                  itr_version(llp->version()) {
            // empty
        }

    private:
        const LinkedList* llp;
        unsigned int itr_version;
    };

    /*
     * Returns an iterator positioned at the first element of the list.
     */
    linkedlist_iterator begin() {
        return linkedlist_iterator(this, m_elements.begin());
    }

    /*
     * Returns an iterator positioned at the first element of the list.
     */
    const_linkedlist_iterator begin() const {
        auto itr = m_elements.begin();
        return const_linkedlist_iterator(this, itr);
    }
    
    /*
     * Returns an iterator positioned at the last element of the list.
     */
    linkedlist_iterator end() {
        auto itr = m_elements.end();
        return linkedlist_iterator(this, itr);
    }
    
    /*
     * Returns an iterator positioned at the last element of the list.
     */
    const_linkedlist_iterator end() const {
        auto itr = m_elements.end();
        return const_linkedlist_iterator(this, itr);
    }

    /*
     * Returns the internal version of this collection.
     * This is used to check for invalid iterators and issue error messages.
     */
    unsigned int version() const;
};

/* Implementation section */

/*
 * Implementation notes: LinkedList constructor and destructor
 * -------------------------------------------------------
 * The constructor allocates storage for the dynamic array
 * and initializes the other fields of the object.  The
 * destructor frees the memory used for the array.
 */
template <typename ValueType>
LinkedList<ValueType>::LinkedList() {
    // empty
}

template <typename ValueType>
LinkedList<ValueType>::LinkedList(const std::list<ValueType>& v)
        : m_elements(v) {
    // empty
}

template <typename ValueType>
LinkedList<ValueType>::LinkedList(std::initializer_list<ValueType> list) {
    addAll(list);
}

template <typename ValueType>
LinkedList<ValueType>::~LinkedList() {
    // empty
}

template <typename ValueType>
void LinkedList<ValueType>::add(ValueType value) {
    m_elements.push_back(value);
    m_version++;
}

template <typename ValueType>
LinkedList<ValueType>&
LinkedList<ValueType>::addAll(const LinkedList<ValueType>& list) {
    for (const ValueType& value : list) {
        add(value);
    }
    m_version++;
}

template <typename ValueType>
LinkedList<ValueType>& LinkedList<ValueType>::addAll(std::initializer_list<ValueType> list) {
    for (const ValueType& value : list) {
        add(value);
    }
    m_version++;
    return *this;
}

template <typename ValueType>
ValueType& LinkedList<ValueType>::back() {
    if (isEmpty()) {
        error("LinkedList::back: list is empty");
    }
    return m_elements.back();
}

template <typename ValueType>
const ValueType& LinkedList<ValueType>::back() const {
    if (isEmpty()) {
        error("LinkedList::back: list is empty");
    }
    return m_elements.back();
}

template <typename ValueType>
void LinkedList<ValueType>::clear() {
    m_elements.clear();
    m_version++;
}

template <typename ValueType>
bool LinkedList<ValueType>::contains(const ValueType& value) const {
    return indexOf(value) >= 0;
}

template <typename ValueType>
bool LinkedList<ValueType>::equals(const LinkedList<ValueType>& list2) const {
    return m_elements == list2.m_elements;
}

template <typename ValueType>
ValueType& LinkedList<ValueType>::front() {
    if (isEmpty()) {
        error("LinkedList::front: list is empty");
    }
    return m_elements.front();
}

template <typename ValueType>
const ValueType& LinkedList<ValueType>::front() const {
    if (isEmpty()) {
        error("LinkedList::front: list is empty");
    }
    return m_elements.front();
}

template <typename ValueType>
const ValueType & LinkedList<ValueType>::get(int index) const {
    checkIndex(index, 0, size()-1, "get");
    auto itr = m_elements.begin();
    for (int i = 0; i < index; i++) {
        ++itr;
    }
    return *itr;
}

template <typename ValueType>
int LinkedList<ValueType>::indexOf(const ValueType& value) const {
    // loop using iterator to avoid O(N^2) runtime
    int i = 0;
    for (const ValueType& element : *this) {
        if (element == value) {
            return i;
        }
        i++;
    }
    return -1;
}

template <typename ValueType>
void LinkedList<ValueType>::insert(int index, ValueType value) {
    checkIndex(index, 0, size(), "insert");
    auto itr = m_elements.begin();
    std::advance(itr, index);
    m_elements.insert(itr, value);
    m_version++;
}

template <typename ValueType>
bool LinkedList<ValueType>::isEmpty() const {
    return m_elements.empty();
}

template <typename ValueType>
int LinkedList<ValueType>::lastIndexOf(const ValueType& value) const {
    // loop using iterator to avoid O(N^2) runtime
    int i = size();
    auto begin = this->begin();
    auto itr = this->end();
    while (itr != begin) {
        itr--;
        i--;
        if (*itr == value) {
            return i;
        }
    }
    return -1;
}

/*
 * Implementation notes: mapAll
 * ----------------------------
 * The various versions of the mapAll function apply the function or
 * function object to each element in ascending index order.
 */
template <typename ValueType>
void LinkedList<ValueType>::mapAll(void (*fn)(ValueType)) const {
    for (ValueType element : *this) {
        fn(element);
    }
}

template <typename ValueType>
void LinkedList<ValueType>::mapAll(void (*fn)(const ValueType &)) const {
    for (ValueType element : *this) {
        fn(element);
    }
}

template <typename ValueType>
template <typename FunctorType>
void LinkedList<ValueType>::mapAll(FunctorType fn) const {
    for (ValueType element : *this) {
        fn(element);
    }
}

template <typename ValueType>
ValueType LinkedList<ValueType>::pop_back() {
    if (isEmpty()) {
        error("LinkedList::pop_back: list is empty");
    }
    ValueType back = m_elements.back();
    m_elements.pop_back();
    m_version++;
    return back;
}

template <typename ValueType>
ValueType LinkedList<ValueType>::pop_front() {
    if (isEmpty()) {
        error("LinkedList::pop_front: list is empty");
    }
    ValueType front = m_elements.front();
    m_elements.pop_front();
    m_version++;
    return front;
}

template <typename ValueType>
void LinkedList<ValueType>::push_back(const ValueType& value) {
    m_elements.push_back(value);
    m_version++;
}

template <typename ValueType>
void LinkedList<ValueType>::push_front(const ValueType& value) {
    m_elements.push_front(value);
    m_version++;
}

template <typename ValueType>
void LinkedList<ValueType>::remove(int index) {
    checkIndex(index, 0, size()-1, "remove");
    auto itr = m_elements.begin();
    advance(itr, index);
    m_elements.erase(itr);
    m_version++;
}

template <typename ValueType>
ValueType LinkedList<ValueType>::removeBack() {
    return pop_back();
}

template <typename ValueType>
ValueType LinkedList<ValueType>::removeFront() {
    return pop_front();
}

template <typename ValueType>
void LinkedList<ValueType>::removeValue(const ValueType& value) {
    // loop using iterator to avoid O(N^2) runtime
    auto itr = this->begin();
    auto end = this->end();
    while (itr != end) {
        if (*itr == value) {
            m_elements.erase(itr);
            break;
        }
        itr++;
    }
    m_version++;
}

template <typename ValueType>
void LinkedList<ValueType>::reverse() {
    m_elements.reverse();
    m_version++;
}

template <typename ValueType>
void LinkedList<ValueType>::set(int index, const ValueType & value) {
    checkIndex(index, 0, size()-1, "set");
    m_elements[index] = value;
    m_version++;
}

template <typename ValueType>
void LinkedList<ValueType>::shuffle() {
    // actually shuffle a vector to avoid O(N^2) runtime
    // at the cost of O(N) extra memory usage
    Vector<ValueType> vec;
    for (ValueType element : *this) {
        vec.add(element);
    }
    for (int i = 0, length = vec.size(); i < length; i++) {
        int j = randomInteger(i, length - 1);
        if (i != j) {
            std::swap(vec[i], vec[j]);
        }
    }

    clear();
    for (const ValueType& element : vec) {
        add(element);
    }
}

template <typename ValueType>
int LinkedList<ValueType>::size() const {
    return m_elements.size();
}


template <typename ValueType>
void LinkedList<ValueType>::sort() {
    // actually sort a vector to avoid O(N^2) runtime
    // at the cost of O(N) extra memory usage
    Vector<ValueType> vec;
    for (ValueType element : *this) {
        vec.add(element);
    }
    std::sort(vec.begin(), vec.end());

    clear();
    for (const ValueType& element : vec) {
        add(element);
    }
}

template <typename ValueType>
LinkedList<ValueType> LinkedList<ValueType>::subList(int start, int length) const {
    checkIndex(start, 0, size(), "subList");
    checkIndex(start + length, 0, size(), "subList");
    if (length < 0) {
        error("LinkedList::subList: length cannot be negative");
    }
    LinkedList<ValueType> result;
    auto itr = begin();
    for (int i = 0; i < start; i++) {
        ++itr;
    }
    for (int i = 0; i < length; i++) {
        result.add(*itr);
        ++itr;
    }
    return result;
}

template <typename ValueType>
std::string LinkedList<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
unsigned int LinkedList<ValueType>::version() const {
    return m_version;
}

/*
 * Implementation notes: LinkedList selection
 * ------------------------------------------
 * The following code implements traditional array selection using
 * square brackets for the index.
 */
template <typename ValueType>
ValueType& LinkedList<ValueType>::operator [](int index) {
    checkIndex(index, 0, size()-1, "operator []");
    auto itr = begin();
    advance(itr, index);
    return *itr;
}
template <typename ValueType>
const ValueType& LinkedList<ValueType>::operator [](int index) const {
    checkIndex(index, 0, size()-1, "operator []");
    auto itr = begin();
    advance(itr, index);
    return *itr;
}

template <typename ValueType>
LinkedList<ValueType>
LinkedList<ValueType>::operator +(const LinkedList& list2) const {
    LinkedList<ValueType> list = *this;
    return list.addAll(list2);
}

template <typename ValueType>
LinkedList<ValueType> LinkedList<ValueType>::operator +(std::initializer_list<ValueType> list) const {
    LinkedList<ValueType> result = *this;
    return result.addAll(list);
}

template <typename ValueType>
LinkedList<ValueType>&
LinkedList<ValueType>::operator +=(const LinkedList& list2) {
    return addAll(list2);
}

template <typename ValueType>
LinkedList<ValueType>& LinkedList<ValueType>::operator +=(std::initializer_list<ValueType> list) {
    return addAll(list);
}

template <typename ValueType>
LinkedList<ValueType>&
LinkedList<ValueType>::operator +=(const ValueType& value) {
    add(value);
    return *this;
}

/*
 * Implementation notes: relational operators
 * These operators just forward to the underlying STL list.
 */
template <typename ValueType>
bool LinkedList<ValueType>::operator ==(const LinkedList& list2) const {
    return m_elements == list2.m_elements;
}

template <typename ValueType>
bool LinkedList<ValueType>::operator !=(const LinkedList& list2) const {
    return m_elements != list2.m_elements;
}

template <typename ValueType>
bool LinkedList<ValueType>::operator <(const LinkedList& list2) const {
    return m_elements < list2.m_elements;
}

template <typename ValueType>
bool LinkedList<ValueType>::operator <=(const LinkedList& list2) const {
    return m_elements <= list2.m_elements;
}

template <typename ValueType>
bool LinkedList<ValueType>::operator >(const LinkedList& list2) const {
    return m_elements > list2.m_elements;
}

template <typename ValueType>
bool LinkedList<ValueType>::operator >=(const LinkedList& list2) const {
    return this->m_elements >= list2.m_elements;
}

/*
 * Implementation notes: copy constructor and assignment operator
 * --------------------------------------------------------------
 * The constructor and assignment operators follow a standard paradigm,
 * as described in the associated textbook.
 */
template <typename ValueType>
LinkedList<ValueType>::LinkedList(const LinkedList& src) {
    deepCopy(src);
}

template <typename ValueType>
LinkedList<ValueType>&
LinkedList<ValueType>::operator =(const LinkedList& src) {
    if (this != &src) {
        deepCopy(src);
    }
    return *this;
}

template <typename ValueType>
void LinkedList<ValueType>::checkIndex(int index, int min, int max, std::string prefix) const {
    if (index < min || index > max) {
        std::ostringstream out;
        out << "LinkedList::" << prefix << ": index of " << index
            << " is outside of valid range [";
        if (min < max) {
            out << min << ".." << max;
        } else if (min == max) {
            out << min;
        } // else min > max, no range, empty LinkedList
        out << "]";
        error(out.str());
    }
}

template <typename ValueType>
void LinkedList<ValueType>::deepCopy(const LinkedList& src) {
    m_elements = src.m_elements;
    m_version++;
}

/*
 * Implementation notes: The , operator
 * ------------------------------------
 * The comma operator works adding the right operand to the LinkedList and
 * then returning the LinkedList by reference so that it is set for the next
 * value in the chain.
 */
template <typename ValueType>
LinkedList<ValueType>&
LinkedList<ValueType>::operator ,(const ValueType& value) {
    add(value);
    return *this;
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const LinkedList<ValueType>& list) {
    return stanfordcpplib::collections::writeCollection(os, list);
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, LinkedList<ValueType>& list) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, list, element, /* descriptor */ "LinkedList::operator >>");
}

/*
 * Template hash function for linked lists.
 * Requires the element type in the LinkedList to have a hashCode function.
 */
template <typename T>
int hashCode(const LinkedList<T>& list) {
    return stanfordcpplib::collections::hashCodeCollection(list);
}

/*
 * Function: randomElement
 * Usage: element = randomElement(list);
 * -------------------------------------
 * Returns a randomly chosen element of the given list.
 * Throws an error if the list is empty.
 */
template <typename T>
const T& randomElement(const LinkedList<T>& list) {
    return stanfordcpplib::collections::randomElementIndexed(list);
}

/*
 * Randomly rearranges the elements of the given list.
 * Because it is slow to arbitrarily access/modify indexes in a linked list,
 * this function uses an auxiliary Vector to assist in its implementation,
 * although doing so increases the memory consumption of the algorithm.
 */
template <typename T>
void shuffle(LinkedList<T>& list) {
    list.shuffle();
}

#endif // _linkedlist_h

/////////////////////// END code extracted from StanfordCPPLib/collections/linkedlist.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/priorityqueue.h ///////////////////////
/*
 * File: priorityqueue.h
 * ---------------------
 * This file exports the <code>PriorityQueue</code> class, a
 * collection in which values are processed in priority order.
 * 
 * @version 2016/11/07
 * - small const-correctness bug fix in front() / back() (courtesy Truman Cranor)
 * @version 2016/10/14
 * - modified floating-point equality tests to use floatingPointEqual function
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/09/22
 * - renamed from pqueue.h to priorityqueue.h (old name left as an alias)
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as
 *   {{1.0, "a"}, {2.0, "b"}, {3.0, "c"}}
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2015/06/22
 * - added optional compiler flag PQUEUE_PRINT_IN_HEAP_ORDER to indicate
 *   that PQ should be printed in heap-internal order rather than sorted order
 * - added optional compiler flag PQUEUE_ALLOW_HEAP_ACCESS and corresponding
 *   semi-private methods to access value/priority at a given index
 *   (wanted internally for some testing and for practice exam problems;
 *    not meant to be called explicitly by students or most clients)
 * @version 2014/12/04
 * - moved comparison operators <, >=, etc. behind a (default-disabled)
 *   compiler flag because implementation is inefficient
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added add() method as synonym for enqueue()
 * - added remove() method as synonym for dequeue()
 * - added template hashCode function
 * @version 2014/10/20
 * - added equals method, ==, != operators
 * @version 2014/10/10
 * - removed usage of __foreach macro
 * 2014/02/01
 * - added changePriority member to raise a given value's priority
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _priorityqueue_h
#define _priorityqueue_h

#include <cmath>
#include <initializer_list>
#include <utility>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: PriorityQueue<ValueType>
 * -------------------------------
 * This class models a structure called a <b><i>priority&nbsp;queue</i></b>
 * in which values are processed in order of priority.  As in conventional
 * English usage, lower priority numbers correspond to higher effective
 * priorities, so that a priority 1 item takes precedence over a
 * priority 2 item.
 */

template <typename ValueType>
class PriorityQueue {
public:
    /*
     * Constructor: PriorityQueue
     * Usage: PriorityQueue<ValueType> pq;
     * -----------------------------------
     * Initializes a new priority queue, which is initially empty.
     */
    PriorityQueue();

    /*
     * Constructor: PriorityQueue
     * Usage: PriorityQueue<ValueType> pq {{1.0, "a"}, {2.0, "b"}, {3.0, "c"}};
     * -------------------------------------------------------------------------
     * Initializes a new priority that stores the given pairs.
     * Note that the pairs are stored in priority order and not
     * necessarily the order in which they are written in the initializer list.
     */
    PriorityQueue(std::initializer_list<std::pair<double, ValueType> > list);

    /*
     * Destructor: ~PriorityQueue
     * --------------------------
     * Frees any heap storage associated with this priority queue.
     */
    virtual ~PriorityQueue();
    
    /*
     * Method: add
     * Usage: pq.add(value, priority);
     * -------------------------------
     * A synonym for the enqueue method.
     */
    void add(const ValueType& value, double priority);
    
    /*
     * Method: back
     * Usage: ValueType last = pq.back();
     * ----------------------------------
     * Returns the last value in the queue by reference.
     */
    ValueType& back();
    
    /*
     * Method: changePriority
     * Usage: pq.changePriority(value, newPriority);
     * ---------------------------------------------
     * Adjusts <code>value</code> in the queue to now have the specified new priority,
     * which must be at least as urgent (lower number) than that value's previous
     * priority in the queue.
     * Throws an error if the element value is not present in the queue, or if the
     * new priority passed is not at least as urgent as its current priority.
     */
    void changePriority(ValueType value, double newPriority);

    /*
     * Method: clear
     * Usage: pq.clear();
     * ------------------
     * Removes all elements from the priority queue.
     */
    void clear();
    
    /*
     * Method: dequeue
     * Usage: ValueType first = pq.dequeue();
     * --------------------------------------
     * Removes and returns the highest priority value.  If multiple
     * entries in the queue have the same priority, those values are
     * dequeued in the same order in which they were enqueued.
     */
    ValueType dequeue();

    /*
     * Method: enqueue
     * Usage: pq.enqueue(value, priority);
     * -----------------------------------
     * Adds <code>value</code> to the queue with the specified priority.
     * Lower priority numbers correspond to higher priorities, which
     * means that all priority 1 elements are dequeued before any
     * priority 2 elements.
     */
    void enqueue(const ValueType& value, double priority);
    
    /*
     * Method: equals
     * Usage: if (pq.equals(pq2)) ...
     * ------------------------------
     * Compares two priority queues for equality.
     * Returns <code>true</code> if this queue contains exactly the same
     * values and priorities as the given other queue.
     * Identical in behavior to the == operator.
     */
    bool equals(const PriorityQueue<ValueType>& pq2) const;
    
    /*
     * Method: front
     * Usage: ValueType first = pq.front();
     * ------------------------------------
     * Returns the first value in the queue by reference.
     */
    ValueType& front();

    /*
     * Method: isEmpty
     * Usage: if (pq.isEmpty()) ...
     * ----------------------------
     * Returns <code>true</code> if the priority queue contains no elements.
     */
    bool isEmpty() const;
    
    /*
     * Method: peek
     * Usage: ValueType first = pq.peek();
     * -----------------------------------
     * Returns the value of highest priority in the queue, without
     * removing it.
     */
    ValueType peek() const;

    /*
     * Method: peekPriority
     * Usage: double priority = pq.peekPriority();
     * -------------------------------------------
     * Returns the priority of the first element in the queue, without
     * removing it.
     */
    double peekPriority() const;

    /*
     * Method: remove
     * Usage: ValueType first = pq.remove();
     * --------------------------------------
     * A synonym for the dequeue method.
     */
    ValueType remove();

    /*
     * Method: size
     * Usage: int n = pq.size();
     * -------------------------
     * Returns the number of values in the priority queue.
     */
    int size() const;

    /*
     * Method: toString
     * Usage: string str = pq.toString();
     * ----------------------------------
     * Converts the queue to a printable string representation.
     */
    std::string toString() const;
    
    /*
     * Operator: <<
     * Prints the priority queue to the given output stream.
     */
    template <typename T>
    friend std::ostream& operator <<(std::ostream& os, const PriorityQueue<T>& pq);
    
    /*
     * Operators: ==, !=
     * Usage: if (pq1 == pq2) ...
     * --------------------------
     * Relational operators to compare two queues to see if they have the same elements.
     * The ==, != operators require that the ValueType has a == operator
     * so that the elements can be tested for equality.
     */
    bool operator ==(const PriorityQueue& pq2) const;
    bool operator !=(const PriorityQueue& pq2) const;

#ifdef PQUEUE_COMPARISON_OPERATORS_ENABLED
    /*
     * Operators: <, <=, >, >=
     * Usage: if (pq1 < pq2) ...
     * -------------------------
     * Relational operators to compare two queues.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const PriorityQueue& pq2) const;
    bool operator <=(const PriorityQueue& pq2) const;
    bool operator >(const PriorityQueue& pq2) const;
    bool operator >=(const PriorityQueue& pq2) const;
#endif // PQUEUE_COMPARISON_OPERATORS_ENABLED

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes: PriorityQueue data structure
     * --------------------------------------------------
     * The PriorityQueue class is implemented using a data structure called
     * a heap.
     */
private:
    /* Type used for each heap entry */
    struct HeapEntry {
        ValueType value;
        double priority;
        long sequence;
    };

    /* Instance variables */
    Vector<HeapEntry> heap;
    long enqueueCount;
    int backIndex;
    int count;
    int capacity;

    /* Private function prototypes */
    const HeapEntry& heapGet(int index) const;
#ifdef PQUEUE_COMPARISON_OPERATORS_ENABLED
    int pqCompare(const PriorityQueue& other) const;
#endif // PQUEUE_COMPARISON_OPERATORS_ENABLED
    bool takesPriority(int i1, int i2);
    void swapHeapEntries(int i1, int i2);

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class pq_iterator : public std::iterator<std::input_iterator_tag, ValueType> {
    public:
        pq_iterator() {
            // empty
        }

        pq_iterator(const PriorityQueue& pq, bool end) {
            m_pq = &pq;
            m_index = end ? m_pq->count : 0;
        }

        pq_iterator(const pq_iterator& it)
                : m_pq(it.m_pq), m_index(it.m_index) {
            // empty
        }

        pq_iterator& operator ++() {
            // find 'next' element: one that is minimally higher pri/seq from last one
            // (this is O(N) and inefficient, but we want to avoid making a deep copy)
            if (m_index == m_pq->count) {
                error("PriorityQueue::iterator::operator ++: Cannot call on an end() iterator");
            }
            double pri = m_pq->heapGet(m_index).priority;
            int seq = m_pq->heapGet(m_index).sequence;
            
            // best new element/index we have seen so far (initially none)
            int newIndex = m_pq->count;
            double newPri;
            int newSeq;
            
            for (int i = 0; i < m_pq->count; i++) {
                if (i == m_index) {
                    continue;
                }
                double ipri = m_pq->heapGet(i).priority;
                int iseq = m_pq->heapGet(i).sequence;
                if (ipri < pri || (floatingPointEqual(ipri, pri) && iseq < seq)) {
                    continue;
                } else if (newIndex == m_pq->count
                           || ipri < newPri
                           || (floatingPointEqual(ipri, newPri) && iseq < newSeq)) {
                    newPri = ipri;
                    newSeq = iseq;
                    newIndex = i;
                }
            }
            
            // if no next element is found, newIndex will be count (end)
            m_index = newIndex;
            return *this;
        }

        pq_iterator operator ++(int) {
            pq_iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const pq_iterator& rhs) {
            return m_pq == rhs.m_pq && m_index == rhs.m_index;
        }

        bool operator !=(const pq_iterator& rhs) {
            return !(*this == rhs);
        }

        ValueType operator *() {
            if (m_index == m_pq->count) {
                error("PriorityQueue::iterator::operator *: Cannot call on an end() iterator");
            }
            return m_pq->heapGet(m_index).value;
        }

        ValueType* operator ->() {
            if (m_index == m_pq->count) {
                error("PriorityQueue::iterator::operator ->: Cannot call on an end() iterator");
            }
            return &m_pq->heapGet(m_index).value;
        }

        friend class PriorityQueue;
        // friend struct HeapEntry;
        
    private:
        const PriorityQueue* m_pq;
        int m_index;
    };
    
public:
    /* private implentation section */

    pq_iterator begin() const {
        return pq_iterator(*this, /* end */ false);
    }

    pq_iterator end() const {
        return pq_iterator(*this, /* end */ true);
    }

    template <typename Collection>
    friend int stanfordcpplib::collections::compare(const Collection& pq1, const Collection& pq2);

#ifdef PQUEUE_ALLOW_HEAP_ACCESS
    const ValueType& __getValueFromHeap(int index) const;
    double __getPriorityFromHeap(int index) const;
#endif // PQUEUE_ALLOW_HEAP_ACCESS
};

template <typename ValueType>
PriorityQueue<ValueType>::PriorityQueue() {
    clear();
}

template <typename ValueType>
PriorityQueue<ValueType>::PriorityQueue(
        std::initializer_list<std::pair<double, ValueType> > list) {
    clear();
    for (std::pair<double, ValueType> pair : list) {
        enqueue(pair.second, pair.first);
    }
}

/*
 * Implementation notes: ~PriorityQueue destructor
 * -----------------------------------------------
 * All of the dynamic memory is allocated in the Vector class,
 * so no work is required at this level.
 */
template <typename ValueType>
PriorityQueue<ValueType>::~PriorityQueue() {
    /* Empty */
}

template <typename ValueType>
void PriorityQueue<ValueType>::add(const ValueType& value, double priority) {
    enqueue(value, priority);
}

template <typename ValueType>
ValueType & PriorityQueue<ValueType>::back() {
    if (count == 0) {
        error("PriorityQueue::back: Attempting to read back of an empty queue");
    }
    return heap[backIndex].value;
}

/*
 * changePriority function added by Marty Stepp.
 * Parts of this implementation are adapted from TrailblazerPQueue.h,
 * which was written by Keith Schwarz.
 */
template <typename ValueType>
void PriorityQueue<ValueType>::changePriority(ValueType value, double newPriority) {
    if (std::isnan(newPriority)) {
        error("PriorityQueue::changePriority: Attempted to use NaN as a priority.");
    }
    if (floatingPointEqual(newPriority, -0.0)) {
        newPriority = 0.0;
    }

    // find the element in the pqueue; must use a simple iteration over elements
    for (int i = 0; i < count; i++) {
        if (heap[i].value == value) {
            if (heap[i].priority < newPriority) {
                error("PriorityQueue::changePriority: new priority cannot be less urgent than current priority.");
            }
            heap[i].priority = newPriority;

            // after changing the priority, must percolate up to proper level
            // to maintain heap ordering
            while (i > 0) {
                int parent = (i - 1) / 2;
                if (takesPriority(parent, i)) {
                    break;
                }
                swapHeapEntries(parent, i);
                i = parent;
            }

            return;
        }
    }

    // if we get here, the element was not ever found
    error("PriorityQueue::changePriority: Element value not found.");
}

template <typename ValueType>
void PriorityQueue<ValueType>::clear() {
    heap.clear();
    count = 0;
    enqueueCount = 0;   // BUGFIX 2014/10/10: was previously using garbage unassigned value
}

/*
 * Implementation notes: dequeue, peek, peekPriority
 * -------------------------------------------------
 * These methods must check for an empty queue and report an error
 * if there is no first element.
 */
template <typename ValueType>
ValueType PriorityQueue<ValueType>::dequeue() {
    if (count == 0) {
        error("PriorityQueue::dequeue: Attempting to dequeue an empty queue");
    }
    count--;
    bool wasBack = (backIndex == count);
    ValueType value = heap[0].value;
    swapHeapEntries(0, count);
    int index = 0;
    while (true) {
        int left = 2 * index + 1;
        int right = 2 * index + 2;
        if (left >= count) {
            break;
        }
        int child = left;
        if (right < count && takesPriority(right, left)) {
            child = right;
        }
        if (takesPriority(index, child)) {
            break;
        }
        swapHeapEntries(index, child);
        index = child;
    }
    if (wasBack) {
        backIndex = index;
    }
    return value;
}

template <typename ValueType>
void PriorityQueue<ValueType>::enqueue(const ValueType& value, double priority) {
    if (std::isnan(priority)) {
        error("PriorityQueue::enqueue: Attempted to use NaN as a priority.");
    }
    if (floatingPointEqual(priority, -0.0)) {
        priority = 0.0;
    }

    if (count == heap.size()) {
        heap.add(HeapEntry());
    }
    int index = count++;
    heap[index].value = value;
    heap[index].priority = priority;
    heap[index].sequence = enqueueCount++;
    if (index == 0 || takesPriority(backIndex, index)) {
        backIndex = index;
    }
    while (index > 0) {
        int parent = (index - 1) / 2;
        if (takesPriority(parent, index)) {
            break;
        }
        swapHeapEntries(parent, index);
        index = parent;
    }
}

template <typename ValueType>
bool PriorityQueue<ValueType>::equals(const PriorityQueue<ValueType>& pq2) const {
    // optimization: if literally same pq, stop
    if (this == &pq2) {
        return true;
    }
    if (size() != pq2.size()) {
        return false;
    }
    PriorityQueue<ValueType> backup1 = *this;
    PriorityQueue<ValueType> backup2 = pq2;
    while (!backup1.isEmpty() && !backup2.isEmpty()) {
        if (!floatingPointEqual(backup1.peekPriority(), backup2.peekPriority())) {
            return false;
        }
        if (backup1.dequeue() != backup2.dequeue()) {
            return false;
        }
    }
    return backup1.isEmpty() == backup2.isEmpty();
}

template <typename ValueType>
ValueType & PriorityQueue<ValueType>::front() {
    if (count == 0) {
        error("PriorityQueue::front: Attempting to read front of an empty queue");
    }
    return heap[0].value;
}

template <typename ValueType>
bool PriorityQueue<ValueType>::isEmpty() const {
    return count == 0;
}

template <typename ValueType>
ValueType PriorityQueue<ValueType>::peek() const {
    if (count == 0) {
        error("PriorityQueue::peek: Attempting to peek at an empty queue");
    }
    return heap.get(0).value;
}

template <typename ValueType>
double PriorityQueue<ValueType>::peekPriority() const {
    if (count == 0) {
        error("PriorityQueue::peekPriority: Attempting to peek at an empty queue");
    }
    return heap.get(0).priority;
}

template <typename ValueType>
ValueType PriorityQueue<ValueType>::remove() {
    return dequeue();
}

template <typename ValueType>
int PriorityQueue<ValueType>::size() const {
    return count;
}

template <typename ValueType>
std::string PriorityQueue<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
const typename PriorityQueue<ValueType>::HeapEntry&
PriorityQueue<ValueType>::heapGet(int index) const {
    return heap[index];
}

#ifdef PQUEUE_COMPARISON_OPERATORS_ENABLED
/*
 * Implementation note: Due to the complexity and unpredictable heap ordering of the elements,
 * this function sadly makes a deep copy of both PQs for comparing.
 * Therefore it is recommended not to use PQs in a context where <, <=, etc. are being
 * called on them frequently.
 */
template <typename ValueType>
int PriorityQueue<ValueType>::pqCompare(const PriorityQueue& pq2) const {
    if (this == &pq2) {
        return true;
    }
    PriorityQueue<ValueType> backup1 = *this;
    PriorityQueue<ValueType> backup2 = pq2;
    while (!backup1.isEmpty() && !backup2.isEmpty()) {
        if (backup1.peek() < backup2.peek()) {
            return -1;
        } else if (backup2.peek() < backup1.peek()) {
            return 1;
        }
        
        double pri1 = backup1.peekPriority();
        double pri2 = backup2.peekPriority();
        if (pri1 < pri2) {
            return -1;
        } else if (pri2 < pri1) {
            return 1;
        }
        
        backup1.dequeue();
        backup2.dequeue();
    }
    if (backup1.size() < backup2.size()) {
        return -1;
    } else if (backup2.size() < backup1.size()) {
        return 1;
    } else {
        return 0;
    }
}
#endif // PQUEUE_COMPARISON_OPERATORS_ENABLED

template <typename ValueType>
void PriorityQueue<ValueType>::swapHeapEntries(int i1, int i2) {
    HeapEntry entry = heap[i1];
    heap[i1] = heap[i2];
    heap[i2] = entry;
}

template <typename ValueType>
bool PriorityQueue<ValueType>::takesPriority(int i1, int i2) {
    if (heap[i1].priority < heap[i2].priority) {
        return true;
    }
    if (heap[i1].priority > heap[i2].priority) {
        return false;
    }
    return (heap[i1].sequence < heap[i2].sequence);
}

template <typename ValueType>
bool PriorityQueue<ValueType>::operator ==(const PriorityQueue& pq2) const {
    return equals(pq2);
}

template <typename ValueType>
bool PriorityQueue<ValueType>::operator !=(const PriorityQueue& pq2) const {
    return !equals(pq2);
}

#ifdef PQUEUE_COMPARISON_OPERATORS_ENABLED
template <typename ValueType>
bool PriorityQueue<ValueType>::operator <(const PriorityQueue& pq2) const {
    return pqCompare(pq2) < 0;
}

template <typename ValueType>
bool PriorityQueue<ValueType>::operator <=(const PriorityQueue& pq2) const {
    return pqCompare(pq2) <= 0;
}

template <typename ValueType>
bool PriorityQueue<ValueType>::operator >(const PriorityQueue& pq2) const {
    return pqCompare(pq2) > 0;
}

template <typename ValueType>
bool PriorityQueue<ValueType>::operator >=(const PriorityQueue& pq2) const {
    return pqCompare(pq2) >= 0;
}
#endif // PQUEUE_COMPARISON_OPERATORS_ENABLED

/*
 * Template hash function for priority queues.
 * Requires the element type in the priority queue to have a hashCode function.
 */
template <typename T>
int hashCode(const PriorityQueue<T>& pq) {
    // (slow, memory-inefficient) implementation: copy pq, dequeue all, and hash together
    PriorityQueue<T> backup = pq;
    int code = hashSeed();
    while (!backup.isEmpty()) {
        code = hashMultiplier() * code + hashCode(backup.peek());
        code = hashMultiplier() * code + hashCode(backup.peekPriority());
        backup.dequeue();
    }
    return int(code & hashMask());
}

#ifdef PQUEUE_ALLOW_HEAP_ACCESS
template <typename ValueType>
const ValueType& PriorityQueue<ValueType>::__getValueFromHeap(int index) const {
    return heap[index].value;
}

template <typename ValueType>
double PriorityQueue<ValueType>::__getPriorityFromHeap(int index) const {
    return heap[index].priority;
}
#endif // PQUEUE_ALLOW_HEAP_ACCESS

template <typename ValueType>
std::ostream& operator <<(std::ostream& os,
                          const PriorityQueue<ValueType>& pq) {
    os << "{";

#ifdef PQUEUE_PRINT_IN_HEAP_ORDER
    // faster implementation: print in heap order
    // (only downside: doesn't print in 'sorted' priority order,
    //  which might confuse student client)
    for (int i = 0, len = pq.size(); i < len; i++) {
        if (i > 0) {
            os << ", ";
        }
        os << pq.heap[i].priority << ":";
        writeGenericValue(os, pq.heap[i].value, /* forceQuotes */ true);
    }
#else
    // (default) slow, memory-inefficient implementation: copy pq and print
    PriorityQueue<ValueType> copy = pq;
    for (int i = 0, len = pq.size(); i < len; i++) {
        if (i > 0) {
            os << ", ";
        }
        os << copy.peekPriority() << ":";
        writeGenericValue(os, copy.dequeue(), /* forceQuotes */ true);
    }
#endif
    return os << "}";
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, PriorityQueue<ValueType>& pq) {
    char ch = '\0';
    is >> ch;
    if (ch != '{') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("PriorityQueue::operator >>: Missing {");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }
    pq.clear();
    is >> ch;
    if (ch != '}') {
        is.unget();
        while (true) {
            double priority = 0.0;
            is >> priority >> ch;
            if (ch != ':') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error("PriorityQueue::operator >>: Missing colon after priority");
#endif
                is.setstate(std::ios_base::failbit);
                return is;
            }
            ValueType value;
            if (!readGenericValue(is, value)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error("PriorityQueue::operator >>: parse error");
#endif
                return is;
            }
            pq.enqueue(value, priority);
            is >> ch;
            if (ch == '}') {
                break;
            }
            if (ch != ',') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(std::string("PriorityQueue::operator >>: Unexpected character ") + ch);
#endif
                is.setstate(std::ios_base::failbit);
                return is;
            }
        }
    }
    return is;
}

#endif // _priorityqueue_h

/////////////////////// END code extracted from StanfordCPPLib/collections/priorityqueue.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/pqueue.h ///////////////////////
/*
 * This is an alias for priorityqueue.h left in for backward compatibility.
 * See priorityqueue.h for the implementation of the PriorityQueue class.
 *
 * @author Marty Stepp
 * @version 2016/09/22
 * - initial version
 */

#ifndef _pqueue_h
#define _pqueue_h

#endif // _pqueue_h

/////////////////////// END code extracted from StanfordCPPLib/collections/pqueue.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/sparsegrid.h ///////////////////////
/*
 * File: sparsegrid.h
 * ------------------
 * This file exports the <code>SparseGrid</code> class, which offers a
 * convenient abstraction for representing a two-dimensional array.
 * Unlike Grid, SparseGrid is optimized for grids in which most of the cells
 * are empty.  It uses far less memory in such cases than a Grid does.
 * If the grid is expected to be mostly full of meaningful data,
 * Grid is recommended for use over SparseGrid.
 * 
 * @author Marty Stepp
 * @version 2018/03/12
 * - added overloads that accept GridLocation: get, inBounds, isSet, locations,
 *   set, unset, operator []
 * @version 2018/03/10
 * - added methods front, back, clear
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2016/10/22
 * - bug fix for size method
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * - added size() method
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as
 *   {{1, 2, 3}, {4, 5, 6}}
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added template hashCode function
 * @version 2014/10/20
 * - added width(), height() methods to be consistent with Grid
 * @version 2014/10/10
 * - removed usage of __foreach macro
 * - made ==, != operators const as they should be
 * - added resize(true) function with ability to retain old contents
 * @since 2014/07/09
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _sparsegrid_h
#define _sparsegrid_h

#include <initializer_list>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: SparseGrid<ValueType>
 * ----------------------------
 * This class stores an indexed, two-dimensional array.
 */

template <typename ValueType>
class SparseGrid {
public:
    /* Forward reference */
    class SparseGridRow;
    class SparseGridRowConst;

    /*
     * Constructor: SparseGrid
     * Usage: SparseGrid<ValueType> grid;
     *        SparseGrid<ValueType> grid(nRows, nCols);
     * ------------------------------------------------
     * Initializes a new grid.  The second form of the constructor is
     * more common and creates a grid with the specified number of rows
     * and columns.  Each element of the grid is initialized to the
     * default value for the type.  The default constructor creates an
     * empty grid for which the client must call <code>resize</code> to
     * set the dimensions.
     * The three-argument constructor also accepts an initial value and
     * fills every cell of the grid with that value.
     */
    SparseGrid();
    SparseGrid(int nRows, int nCols);
    SparseGrid(int nRows, int nCols, const ValueType& value);

    /*
     * This constructor uses an initializer list to set up the grid.
     * Usage: SparseGrid<int> grid {{1, 2, 3}, {4, 5, 6}};
     */
    SparseGrid(std::initializer_list<std::initializer_list<ValueType> > list);

    /*
     * Destructor: ~SparseGrid
     * -----------------------
     * Frees any heap storage associated with this grid.
     */
    virtual ~SparseGrid();

    /*
     * Method: back
     * Usage: ValueType value = grid.back();
     * -------------------------------------
     * Returns the last value in the grid in the order established by the
     * <code>foreach</code> macro.  This is the highest row/col value that has
     * been explicitly set.
     * If the grid is empty, generates an error.
     */
    ValueType back() const;

    /*
     * Method: clear
     * Usage: grid.clear();
     * --------------------
     * Sets every value in the grid to its element type's default value.
     */
    void clear();

    /*
     * Method: equals
     * Usage: if (grid.equals(grid2)) ...
     * ----------------------------------
     * Returns <code>true</code> if this grid contains exactly the same
     * values as the given other grid.
     * Identical in behavior to the == operator.
     */
    bool equals(const SparseGrid<ValueType>& grid) const;

    /*
     * Method: fill
     * Usage: grid.fill(value);
     * ------------------------
     * Stores the given value in every cell of this grid.
     */
    void fill(const ValueType& value);

    /*
     * Method: front
     * Usage: ValueType value = grid.front();
     * --------------------------------------
     * Returns the first value in the grid in the order established by the
     * <code>foreach</code> macro.  Typically this is equivalent to grid[0][0].
     * If the grid is empty, generates an error.
     */
    ValueType front() const;

    /*
     * Method: get
     * Usage: ValueType value = grid.get(row, col);
     * --------------------------------------------
     * Returns the element at the specified <code>row</code>/<code>col</code>
     * position in this grid.
     *
     * If no data was set at the given row/column position, this method returns
     * a default value for the grid's value type.
     *
     * This method signals an error if the <code>row</code> and <code>col</code>
     * arguments are outside the grid boundaries.
     */
    ValueType get(int row, int col);
    const ValueType& get(int row, int col) const;
    ValueType get(const GridLocation& loc);
    const ValueType& get(const GridLocation& loc) const;

    /*
     * Method: height
     * Usage: int nRows = grid.height();
     * ---------------------------------
     * Returns the grid's height, that is, the number of rows in the grid.
     */
    int height() const;
    
    /*
     * Method: inBounds
     * Usage: if (grid.inBounds(row, col)) ...
     * ---------------------------------------
     * Returns <code>true</code> if the specified row and column position
     * is inside the bounds of the grid.
     */
    bool inBounds(int row, int col) const;
    bool inBounds(const GridLocation& loc) const;

    /*
     * Method: isEmpty
     * Usage: if (grid.isEmpty()) ...
     * ---------------------------------------
     * Returns <code>true</code> if the specified grid has 0 rows and/or columns,
     * or if none of the individual cell values has been set yet.
     */
    bool isEmpty() const;

    /*
     * Method: isSet
     * Usage: if (grid.isSet(row, col)) ...
     * ---------------------------------------
     * Returns <code>true</code> if the specified row and column position
     * stores meaningful data; in other words, if it has had a value set
     * there by a previous call to fill, set, [], etc.
     */
    bool isSet(int row, int col) const;
    bool isSet(const GridLocation& loc) const;

    /*
     * Method: locations
     * Usage: for (GridLocation loc : grid.locations()) ...
     * ----------------------------------------------------
     * Returns a range of (row,col) locations found in this grid.
     * This allows a nice abstraction for looping over the 2D grid range
     * of indexes using a single for loop.
     * By default the locations are arranged in row-major order,
     * but if you pass the rowMajor parameter of false, the locations will be
     * returned in column-major order instead.
     */
    GridLocationRange locations(bool rowMajor = true) const;

    /*
     * Method: mapAll
     * Usage: grid.mapAll(fn);
     * -----------------------
     * Calls the specified function on each element of the grid.  The
     * elements are processed in <b><i>row-major order,</i></b> in which
     * all the elements of row 0 are processed, followed by the elements
     * in row 1, and so on.
     */
    void mapAll(void (*fn)(ValueType value)) const;
    void mapAll(void (*fn)(const ValueType& value)) const;

    template <typename FunctorType>
    void mapAll(FunctorType fn) const;

    /*
     * Method: numCols
     * Usage: int nCols = grid.numCols();
     * ----------------------------------
     * Returns the number of columns in the grid.
     */
    int numCols() const;

    /*
     * Method: numRows
     * Usage: int nRows = grid.numRows();
     * ----------------------------------
     * Returns the number of rows in the grid.
     */
    int numRows() const;

    /*
     * Method: resize
     * Usage: grid.resize(nRows, nCols);
     * ---------------------------------
     * Reinitializes the grid to have the specified number of rows
     * and columns.  If the 'retain' parameter is true,
     * the previous grid contents are retained as much as possible.
     * If 'retain' is not passed or is false, any previous grid contents
     * are discarded.
     */
    void resize(int nRows, int nCols, bool retain = false);

    /*
     * Method: set
     * Usage: grid.set(row, col, value);
     * ---------------------------------
     * Replaces the element at the specified <code>row</code>/<code>col</code>
     * location in this grid with a new value.  This method signals an error
     * if the <code>row</code> and <code>col</code> arguments are outside
     * the grid boundaries.
     */
    void set(int row, int col, const ValueType& value);
    void set(const GridLocation& loc, const ValueType& value);

    /*
     * Method: size
     * Usage: int size = grid.size();
     * ------------------------------
     * Returns the total number of elements that have been set in the grid.
     * Note that this may not be equal to the number of rows times the number of
     * columns, because not every index may have been set.
     */
    int size() const;

    /*
     * Method: toString
     * Usage: string str = grid.toString();
     * ------------------------------------
     * Converts the grid to a printable string representation.
     * Unlike the representation of a Grid, this one displays only the
     * cells in which data has been explicitly set, such as:
     * "{0:{2:88}, 1:{3:42}}, 3 x 4"
     */
    std::string toString() const;

    /*
     * Method: toString2D
     * Usage: string str = grid.toString2D();
     * --------------------------------------
     * Converts the grid to a printable string representation.
     * The string returned is a 2-dimensional representation such as:
     * "{{1, 2, 3},\n
     *   {4, 5, 6},\n
     *   {7, 8, 9}}"
     */
    std::string toString2D(
            std::string rowStart = "{",
            std::string rowEnd = "}",
            std::string colSeparator = ", ",
            std::string rowSeparator = ",\n ") const;

    /*
     * Method: unset
     * Usage: grid.unset(row, col, value);
     * -----------------------------------
     * Replaces the element at the specified <code>row</code>/<code>col</code>
     * location in this grid with an empty default value.
     * If the element at the specified row and column was not set, has no effect.
     * This method signals an error if the <code>row</code> and <code>col</code>
     * arguments are outside the grid boundaries.
     */
    void unset(int row, int col);
    void unset(const GridLocation& loc);

    /*
     * Method: width
     * Usage: int nCols = grid.width();
     * --------------------------------
     * Returns the grid's width, that is, the number of columns in the grid.
     */
    int width() const;

    /*
     * Operator: []
     * Usage:  grid[row][col]
     * ----------------------
     * Overloads <code>[]</code> to select elements from this grid.
     * This extension enables the use of traditional array notation to
     * get or set individual elements.
     *
     * If no data was set at the given row/column position, this method returns
     * a default value for the grid's value type.
     *
     * This method signals an error if the <code>row</code> and <code>col</code>
     * arguments are outside the grid boundaries.
     */
    SparseGridRow operator [](int row);
    const SparseGridRowConst operator [](int row) const;
    ValueType& operator [](const GridLocation& loc);
    const ValueType& operator [](const GridLocation& loc) const;

    /*
     * Additional SparseGrid operations
     * --------------------------
     * In addition to the methods listed in this interface, the SparseGrid
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * The iteration forms process the grid in row-major order.
     */

    /*
     * Operator: ==
     * Usage: if (grid1 == grid2) ...
     * ------------------------------
     * Compares two grids for equality.
     */
    bool operator ==(const SparseGrid& grid2) const;

    /*
     * Operator: !=
     * Usage: if (grid1 != grid2) ...
     * ------------------------------
     * Compares two grids for inequality.
     */
    bool operator !=(const SparseGrid& grid2) const;

    /*
     * Operators: <, >, <=, >=
     * Usage: if (grid1 < grid2) ...
     * -----------------------------
     * Relational operators to compare two grids.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const SparseGrid& grid2) const;
    bool operator <=(const SparseGrid& grid2) const;
    bool operator >(const SparseGrid& grid2) const;
    bool operator >=(const SparseGrid& grid2) const;

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes: SparseGrid data structure
     * -----------------------------------------------
     * The SparseGrid is internally managed as a dynamic array of elements.
     * The array itself is one-dimensional, the logical separation into
     * rows and columns is done by arithmetic computation.  The layout
     * is in row-major order, which is to say that the entire first row
     * is laid out contiguously, followed by the entire second row,
     * and so on.
     */

private:
    /* Instance variables */
    Map<int, Map<int, ValueType> > elements;  // 2D map of the elements
    int nRows;            // The number of rows in the grid
    int nCols;            // The number of columns in the grid
    unsigned int m_version = 0;  // structure version for detecting invalid iterators

    /* Private method prototypes */

    /*
     * Throws an ErrorException if the given row/col are not within the range of
     * (0,0) through (rowMax-1,colMax-1) inclusive.
     * This is a consolidated error handler for all various SparseGrid members that
     * accept index parameters.
     * The prefix parameter represents a text string to place at the start of
     * the error message, generally to help indicate which member threw the error.
     */
    void checkIndexes(int row, int col,
                      int rowMax, int colMax,
                      std::string prefix) const;
    int gridCompare(const SparseGrid& grid2) const;

    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods
     * in the public interface would make that interface more
     * difficult to understand for the average client.
     */

    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return grids by value
     * and assign from one grid to another.  The entire contents of
     * the grid, including all elements, are copied.  Each grid
     * element is copied from the original grid to the copy using
     * assignment (operator=).  Making copies is generally avoided
     * because of the expense and thus, grids are typically passed
     * by reference, however, when a copy is needed, these operations
     * are supported.
     */
    void deepCopy(const SparseGrid& grid) {
        elements = grid.elements;
        nRows = grid.nRows;
        nCols = grid.nCols;
    }

    template <typename T>
    friend const T& randomElement(const SparseGrid<T>& grid);

    template <typename T>
    friend std::ostream& operator <<(std::ostream& os, const SparseGrid<T>& grid);

    template <typename T>
    friend std::istream& operator >>(std::istream& is, SparseGrid<T>& grid);

public:
    SparseGrid& operator =(const SparseGrid& src) {
        if (this != &src) {
            deepCopy(src);
        }
        return *this;
    }

    SparseGrid(const SparseGrid& src) {
        deepCopy(src);
    }

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public std::iterator<std::input_iterator_tag, ValueType> {
    public:
        iterator(const SparseGrid* gp, int index)
                : gp(gp),
                  index(index),
                  itr_version(gp->version()) {
            // empty
        }

        iterator(const iterator& it)
                : gp(it.gp),
                  index(it.index),
                  itr_version(it.itr_version) {
            // empty
        }

        iterator& operator ++() {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            index++;
            return *this;
        }

        iterator operator ++(int) {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const iterator& rhs) {
            return gp == rhs.gp && index == rhs.index;
        }

        bool operator !=(const iterator& rhs) {
            return !(*this == rhs);
        }

        ValueType operator *() {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            int row = index / gp->nCols;
            int col = index % gp->nCols;
            return gp->elements[row][col];
        }

        ValueType* operator ->() {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            int row = index / gp->nCols;
            int col = index % gp->nCols;
            return &gp->elements[row][col];
        }

        unsigned int version() const {
            return itr_version;
        }

    private:
        const SparseGrid* gp;
        int index;
        unsigned int itr_version;
    };

    iterator begin() const {
        return iterator(this, 0);
    }

    iterator end() const {
        return iterator(this, nRows * nCols);
    }

    /*
     * Returns the internal version of this collection.
     * This is used to check for invalid iterators and issue error messages.
     */
    unsigned int version() const;

    /*
     * Private class: SparseGrid<ValType>::SparseGridRow
     * -------------------------------------
     * This section of the code defines a nested class within the SparseGrid template
     * that makes it possible to use traditional subscripting on SparseGrid values.
     */
    class SparseGridRow {
    public:
        SparseGridRow() {
            /* Empty */
        }

        ValueType& operator [](int col) {
            gp->checkIndexes(row, col, gp->nRows-1, gp->nCols-1, "operator [][]");
            return gp->elements[row][col];
        }

        const ValueType& operator [](int col) const {
            gp->checkIndexes(row, col, gp->nRows-1, gp->nCols-1, "operator [][]");
            return gp->elements[row][col];
        }

    private:
        SparseGridRow(SparseGrid* gridRef, int index) {
            gp = gridRef;
            row = index;
        }

        SparseGrid* gp;
        int row;
        friend class SparseGrid;
    };
    friend class SparseGridRow;

    class SparseGridRowConst {
    public:
        SparseGridRowConst() {
            /* Empty */
        }

        const ValueType operator [](int col) const {
            gp->checkIndexes(row, col, gp->nRows-1, gp->nCols-1, "operator [][]");
            return gp->elements[row][col];
        }

    private:
        SparseGridRowConst(SparseGrid* const gridRef, int index) : gp(gridRef), row(index) {
            // empty
        }

        const SparseGrid* const gp;
        const int row;
        friend class SparseGrid;
    };
    friend class SparseGridRowConst;
};

template <typename ValueType>
SparseGrid<ValueType>::SparseGrid()
        : nRows(0),
          nCols(0) {
    // empty
}

template <typename ValueType>
SparseGrid<ValueType>::SparseGrid(int nRows, int nCols) {
    resize(nRows, nCols);
}

template <typename ValueType>
SparseGrid<ValueType>::SparseGrid(int nRows, int nCols, const ValueType& value) {
    resize(nRows, nCols);
    fill(value);
}

template <typename ValueType>
SparseGrid<ValueType>::SparseGrid(std::initializer_list<std::initializer_list<ValueType> > list)
        : nRows(0),
          nCols(0) {
    // create the grid at the proper size
    nRows = list.size();
    if (list.begin() != list.end()) {
        nCols = list.begin()->size();
    }
    resize(nRows, nCols);

    // copy the data from the initializer list into the Grid
    auto rowItr = list.begin();
    for (int row = 0; row < nRows; row++) {
        if ((int) rowItr->size() != nCols) {
            error("SparseGrid::constructor: initializer list is not rectangular (must have same # cols in each row)");
        }
        auto colItr = rowItr->begin();
        for (int col = 0; col < nCols; col++) {
            set(row, col, *colItr);
            colItr++;
        }
        rowItr++;
    }
}


template <typename ValueType>
SparseGrid<ValueType>::~SparseGrid() {
    // empty
}

template <typename ValueType>
ValueType SparseGrid<ValueType>::back() const {
    if (isEmpty()) {
        error("SparseGrid::back: grid is empty");
    }
    int lastRow = elements.back();
    int lastCol = elements[lastRow].back();
    return elements[lastRow][lastCol];
}

template <typename ValueType>
void SparseGrid<ValueType>::clear() {
    elements.clear();
}

template <typename ValueType>
bool SparseGrid<ValueType>::equals(const SparseGrid<ValueType>& grid2) const {
    // optimization: if literally same grid, stop
    if (this == &grid2) {
        return true;
    }
    if (nRows != grid2.nRows || nCols != grid2.nCols) {
        return false;
    }
    for (int row = 0; row < nRows; row++) {
        for (int col = 0; col < nCols; col++) {
            if (isSet(row, col)) {
                // I have data there; he must, too, and it must be the same data
                if (!grid2.isSet(row, col) || get(row, col) != grid2.get(row, col)) {
                    return false;
                }
            } else {
                // I don't have data there; he must also not have it there
                if (grid2.isSet(row, col)) {
                    return false;
                }
            }
        }
    }
    return true;
}

template <typename ValueType>
void SparseGrid<ValueType>::fill(const ValueType& value) {
    for (int row = 0; row < nRows; row++) {
        for (int col = 0; col < nCols; col++) {
            set(row, col, value);
        }
    }
}

template <typename ValueType>
ValueType SparseGrid<ValueType>::front() const {
    if (isEmpty()) {
        error("SparseGrid::front: grid is empty");
    }
    return *begin();
}

template <typename ValueType>
ValueType SparseGrid<ValueType>::get(int row, int col) {
    checkIndexes(row, col, nRows-1, nCols-1, "get");
    return elements[row][col];
}

template <typename ValueType>
const ValueType& SparseGrid<ValueType>::get(int row, int col) const {
    checkIndexes(row, col, nRows-1, nCols-1, "get");
    return elements[row][col];
}

template <typename ValueType>
ValueType SparseGrid<ValueType>::get(const GridLocation& loc) {
    return get(loc.row, loc.col);
}

template <typename ValueType>
const ValueType& SparseGrid<ValueType>::get(const GridLocation& loc) const {
    return get(loc.row, loc.col);
}

template <typename ValueType>
int SparseGrid<ValueType>::height() const {
    return nRows;
}

template <typename ValueType>
bool SparseGrid<ValueType>::inBounds(int row, int col) const {
    return row >= 0 && col >= 0 && row < nRows && col < nCols;
}

template <typename ValueType>
bool SparseGrid<ValueType>::inBounds(const GridLocation& loc) const {
    return inBounds(loc.row, loc.col);
}

template <typename ValueType>
bool SparseGrid<ValueType>::isEmpty() const {
    return elements.isEmpty();
}

template <typename ValueType>
bool SparseGrid<ValueType>::isSet(int row, int col) const {
    return inBounds(row, col) && elements.containsKey(row) &&
            elements[row].containsKey(col);
}

template <typename ValueType>
bool SparseGrid<ValueType>::isSet(const GridLocation& loc) const {
    return isSet(loc.row, loc.col);
}

template <typename ValueType>
GridLocationRange SparseGrid<ValueType>::locations(bool rowMajor) const {
    return GridLocationRange(0, 0, numRows() - 1, numCols() - 1, rowMajor);
}

template <typename ValueType>
void SparseGrid<ValueType>::mapAll(void (*fn)(ValueType value)) const {
    for (int row = 0; row < nRows; row++) {
        for (int col = 0; col < nCols; col++) {
            if (isSet(row, col)) {
                fn(get(row, col));
            }
        }
    }
}

template <typename ValueType>
void SparseGrid<ValueType>::mapAll(void (*fn)(const ValueType& value)) const {
    for (int row = 0; row < nRows; row++) {
        for (int col = 0; col < nCols; col++) {
            if (isSet(row, col)) {
                fn(get(row, col));
            }
        }
    }
}

template <typename ValueType>
template <typename FunctorType>
void SparseGrid<ValueType>::mapAll(FunctorType fn) const {
    for (int row = 0; row < nRows; row++) {
        for (int col = 0; col < nCols; col++) {
            if (isSet(row, col)) {
                fn(get(row, col));
            }
        }
    }
}

template <typename ValueType>
int SparseGrid<ValueType>::numCols() const {
    return nCols;
}

template <typename ValueType>
int SparseGrid<ValueType>::numRows() const {
    return nRows;
}

template <typename ValueType>
void SparseGrid<ValueType>::resize(int nRows, int nCols, bool retain) {
    if (nRows < 0 || nCols < 0) {
        std::ostringstream out;
        out << "SparseGrid::resize: Attempt to resize grid to invalid size ("
               << nRows << ", " << nCols << ")";
        error(out.str());
    }
    int oldnRows = this->nRows;
    int oldnCols = this->nCols;
    this->nRows = nRows;
    this->nCols = nCols;
    
    if (retain) {
        // if resizing to a smaller size, must evict any row/col entries
        // that exceed the new grid's bounds
        if (nRows < oldnRows || nCols < oldnCols) {
            Map<int, Map<int, ValueType> > newElements;
            for (int row : elements) {
                if (row >= nRows) {
                    break;   // don't add any entries beyond this row
                }
                for (int col : elements[row]) {
                    if (col >= nCols) {
                        break;   // don't add any entries beyond this row
                    }
                    newElements[row][col] = elements[row][col];
                }
            }
            elements = newElements;
        }
    } else {
        elements.clear();
    }
    m_version++;
}

template <typename ValueType>
void SparseGrid<ValueType>::set(int row, int col, const ValueType& value) {
    checkIndexes(row, col, nRows-1, nCols-1, "set");
    elements[row][col] = value;
    m_version++;
}

template <typename ValueType>
void SparseGrid<ValueType>::set(const GridLocation& loc, const ValueType& value) {
    set(loc.row, loc.col, value);
}

template <typename ValueType>
int SparseGrid<ValueType>::size() const {
    int count = 0;
    for (int row : elements) {
        count += elements[row].size();
    }
    return count;
}

template <typename ValueType>
std::string SparseGrid<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
std::string SparseGrid<ValueType>::toString2D(
        std::string rowStart, std::string rowEnd,
        std::string colSeparator, std::string rowSeparator) const {
    std::ostringstream os;
    os << rowStart;
    int nRows = numRows();
    int nCols = numCols();
    for (int i = 0; i < nRows; i++) {
        if (!elements.containsKey(i) || elements[i].isEmpty()) {
            continue;
        }
        if (i > 0) {
            os << rowSeparator;
        }
        os << rowStart;
        for (int j = 0; j < nCols; j++) {
            if (j > 0) {
                os << colSeparator;
            }
            if (isSet(i, j)) {
                writeGenericValue(os, get(i, j), true);
            }
        }
        os << rowEnd;
    }
    os << rowEnd;
    return os.str();
}

template <typename ValueType>
void SparseGrid<ValueType>::unset(int row, int col) {
    checkIndexes(row, col, nRows-1, nCols-1, "unset");
    if (elements.containsKey(row)) {
        elements[row].remove(col);
        if (elements[row].isEmpty()) {
            elements.remove(row);
        }
    }
    m_version++;
}

template <typename ValueType>
void SparseGrid<ValueType>::unset(const GridLocation& loc) {
    unset(loc.row, loc.col);
}

template <typename ValueType>
unsigned int SparseGrid<ValueType>::version() const {
    return m_version;
}

template <typename ValueType>
int SparseGrid<ValueType>::width() const {
    return nCols;
}

template <typename ValueType>
void SparseGrid<ValueType>::checkIndexes(int row, int col,
                                         int rowMax, int colMax,
                                         std::string prefix) const {
    const int rowMin = 0;
    const int colMin = 0;
    if (row < rowMin || row > rowMax || col < colMin || col > colMax) {
        std::ostringstream out;
        out << "SparseGrid::" << prefix << ": (" << row << ", " << col << ")"
            << " is outside of valid range [";
        if (rowMin < rowMax && colMin < colMax) {
            out << "(" << rowMin << ", " << colMin <<  ")..("
                << rowMax << ", " << colMax << ")";
        } else if (rowMin == rowMax && colMin == colMax) {
            out << "(" << rowMin << ", " << colMin <<  ")";
        } // else min > max, no range, empty grid
        out << "]";
        error(out.str());
    }
}

template <typename ValueType>
int SparseGrid<ValueType>::gridCompare(const SparseGrid& grid2) const {
    int h1 = height();
    int w1 = width();
    int h2 = grid2.height();
    int w2 = grid2.width();
    int rows = h1 > h2 ? h1 : h2;
    int cols = w1 > w2 ? w1 : w2;
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (r >= h1) {
                return -1;
            } else if (r >= h2) {
                return 1;
            }
            
            if (c >= w1) {
                return -1;
            } else if (c >= w2) {
                return 1;
            }
            
            if (!isSet(r, c) && grid2.isSet(r, c)) {
                return -1;
            } else if (isSet(r, c) && !grid2.isSet(r, c)) {
                return 1;
            }
            
            if (get(r, c) < grid2.get(r, c)) {
                return -1;
            } else if (grid2.get(r, c) < get(r, c)) {
                return 1;
            }
        }
    }
    return 0;
}

template <typename ValueType>
typename SparseGrid<ValueType>::SparseGridRow SparseGrid<ValueType>::operator [](int row) {
    return SparseGridRow(this, row);
}

template <typename ValueType>
const typename SparseGrid<ValueType>::SparseGridRowConst
SparseGrid<ValueType>::operator [](int row) const {
    return SparseGridRowConst(const_cast<SparseGrid*>(this), row);
}

template <typename ValueType>
ValueType& SparseGrid<ValueType>::operator [](const GridLocation& loc) {
    checkIndexes(loc.row, loc.col, nRows-1, nCols-1, "operator []");
    return elements[loc.row][loc.col];
}

template <typename ValueType>
const ValueType& SparseGrid<ValueType>::operator [](const GridLocation& loc) const {
    checkIndexes(loc.row, loc.col, nRows-1, nCols-1, "operator []");
    return elements[loc.row][loc.col];
}

template <typename ValueType>
bool SparseGrid<ValueType>::operator ==(const SparseGrid& grid2) const {
    return equals(grid2);
}

template <typename ValueType>
bool SparseGrid<ValueType>::operator !=(const SparseGrid& grid2) const {
    return !equals(grid2);
}

template <typename ValueType>
bool SparseGrid<ValueType>::operator <(const SparseGrid& grid2) const {
    return gridCompare(grid2) < 0;
}

template <typename ValueType>
bool SparseGrid<ValueType>::operator <=(const SparseGrid& grid2) const {
    return gridCompare(grid2) <= 0;
}

template <typename ValueType>
bool SparseGrid<ValueType>::operator >(const SparseGrid& grid2) const {
    return gridCompare(grid2) > 0;
}

template <typename ValueType>
bool SparseGrid<ValueType>::operator >=(const SparseGrid& grid2) const {
    return gridCompare(grid2) >= 0;
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const SparseGrid<ValueType>& grid) {
    os << grid.elements << ", " << grid.nRows << " x " << grid.nCols;
    return os;
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, SparseGrid<ValueType>& grid) {
    // "{...}, 4 x 3"

    // read "{...}" (map of elements)
    if (!(is >> grid.elements)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("SparseGrid::operator >>: Invalid elements");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }

    // throw away ', ' token
    std::string comma;
    if (!(is >> comma)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("SparseGrid::operator >>: Invalid format");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }

    if (!(is >> grid.nRows)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("SparseGrid::operator >>: Invalid number of rows");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }

    std::string x;
    is >> x;       // throw away 'x' token

    if (!(is >> grid.nCols)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("SparseGrid::operator >>: Invalid number of rows");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }
    return is;
}

/*
 * Template hash function for sparse grids.
 * Requires the element type in the SparseGrid to have a hashCode function.
 */
template <typename T>
int hashCode(const SparseGrid<T>& grid) {
    return stanfordcpplib::collections::hashCodeCollection(grid);
}

/*
 * Function: randomElement
 * Usage: element = randomElement(grid);
 * -------------------------------------
 * Returns a randomly chosen element of the given grid.
 * Throws an error if the grid is empty.
 */
template <typename T>
const T& randomElement(const SparseGrid<T>& grid) {
    if (grid.isEmpty()) {
        error("randomElement: empty sparse grid was passed");
    }
    
    // pick a non-empty row, then pick a random element from it
    // TODO: fix, this is NOT evenly distributed when rows/cols are unequal in size
    int row = randomKey(grid.elements);
    int col = randomKey(grid.elements[row]);
    return grid.get(row, col);
}

#endif // _sparsegrid_h

/////////////////////// END code extracted from StanfordCPPLib/collections/sparsegrid.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/dawglexicon.h ///////////////////////
/*
 * File: dawglexicon.h
 * -------------------
 * This file exports the <code>DawgLexicon</code> class, which is a
 * compact structure for storing a list of words.
 * 
 * @version 2018/03/10
 * - added method front
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2017/10/18
 * - fix compiler warnings
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/11
 * - added methods addAll, containsAll,
 *   operators +, +=, *, *= to better match Set/HashSet
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as {"a", "b", "c"}
 * @version 2016/08/04
 * - added operator >>
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added hashCode function
 * @version 2014/10/10
 * - added equals method
 * - added comparison operators ==, !=
 * - added toStlSet method
 * - fixed inclusion of foreach macro to avoid errors
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _dawglexicon_h
#define _dawglexicon_h

#include <initializer_list>
#include <set>
#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE
#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * This class is used to represent a <b><i>lexicon,</i></b> or word list.
 * The main difference between a lexicon and a dictionary is that
 * a lexicon does not provide any mechanism for storing definitions;
 * the lexicon contains only words, with no associated information.
 * It is therefore similar to a set of strings, but with a more
 * space-efficient internal representation.  The <code>DawgLexicon</code>
 * class supports efficient lookup operations for words and prefixes.
 *
 * Currently the recommended implementation of a lexicon is the
 * <code>Lexicon</code> class, which supports more operations than this one.
 */

#include <cctype>

class DawgLexicon {
public:
    /**
     * Initializes a new empty lexicon.
     */
    DawgLexicon();

    /**
     * Initializes a new lexicon, reading in the contents of the lexicon from
     * the specified data file.
     *
     * The data file must be in one of two formats:
     * (1) a space-efficient precompiled binary format or
     * (2) a text file containing one word per line.
     *
     * The Stanford library distribution includes a binary lexicon file named
     * <code>English.dat</code> containing a list of words in English.  The
     * standard code pattern to initialize that lexicon looks like this:
     *
     *<pre>
     * DawgLexicon english("English.dat");
     *</pre>
     */
    DawgLexicon(std::istream& input);

    /**
     * Initializes a new lexicon, reading in the contents of the lexicon from
     * the specified data file.
     *
     * The data file must be in one of two formats:
     * (1) a space-efficient precompiled binary format (e.g. English.dat) or
     * (2) a text file containing one word per line.
     *
     * @example DawgLexicon english("English.dat");
     */
    DawgLexicon(const std::string& filename);

    /**
     * This constructor uses an initializer list to set up the lexicon.
     * @example DawgLexicon lex {1, 2, 3};
     */
    DawgLexicon(std::initializer_list<std::string> list);

    /**
     * The destructor deallocates any storage associated with the lexicon.
     */
    virtual ~DawgLexicon();
    
    /**
     * Adds the specified word to the lexicon.
     */
    void add(const std::string& word);

    /**
     * Adds all elements of the given other lexicon to this lexicon.
     * Identical in behavior to the += operator.
     */
    DawgLexicon& addAll(const DawgLexicon& lex);

    /**
     * Adds all elements of the given list to this lexicon.
     * Identical in behavior to the += operator.
     */
    DawgLexicon& addAll(std::initializer_list<std::string> list);

    /**
     * Reads the input stream and adds all of its words to the lexicon.
     */
    void addWordsFromFile(std::istream& input);
    
    /**
     * Reads the file and adds all of its words to the lexicon.
     */
    void addWordsFromFile(const std::string& filename);
    
    /**
     * Removes all words from the lexicon.
     */
    void clear();
    
    /**
     * Returns <code>true</code> if <code>word</code> is contained in the
     * lexicon.  In the <code>DawgLexicon</code> class, the case of letters is
     * ignored, so "Zoo" is the same as "ZOO" or "zoo".
     */
    bool contains(const std::string& word) const;

    /**
     * Returns <code>true</code> if every value from the given other lexicon
     * is also found in this lexicon.
     * Equivalent in behavior to isSupersetOf.
     */
    bool containsAll(const DawgLexicon& set2) const;

    /**
     * Returns <code>true</code> if every value from the given list
     * is also found in this lexicon.
     * Equivalent in behavior to isSupersetOf.
     */
    bool containsAll(std::initializer_list<std::string> list) const;

    /**
     * Returns true if any words in the lexicon begin with <code>prefix</code>.
     * Like <code>containsWord</code>, this method ignores the case of letters
     * so that "MO" is a prefix of "monkey" or "Monday".
     */
    bool containsPrefix(const std::string& prefix) const;
    
    /**
     * Compares two lexicons for equality.
     * Returns <code>true</code> if this lexicon contains exactly the same
     * values as the given other lexicon.
     * Identical in behavior to the == operator.
     */
    bool equals(const DawgLexicon& lex2) const;

    /**
     * Returns the first element in alphabetical order from this lexicon (without removing it).
     * This method signals an error if lexicon is empty.
     */
    std::string front() const;

    /**
     * Adds an element to this lexicon, if it was not already there.  This
     * method is exported for compatibility with the STL <code>set</code> class.
     */
    void insert(const std::string& word);

    /**
     * Returns <code>true</code> if the lexicon contains no words.
     */
    bool isEmpty() const;

    /**
     * Returns <code>true</code> if every word of this lexicon is contained in
     * the given other lexicon.
     */
    bool isSubsetOf(const DawgLexicon& lex2) const;

    /**
     * Returns <code>true</code> if every word of this lexicon is contained in
     * the given list.
     */
    bool isSubsetOf(std::initializer_list<std::string> list) const;

    /**
     * Returns <code>true</code> if every word of this lexicon is contained in
     * the given other lexicon.
     * Equivalent in behavior to containsAll.
     */
    bool isSupersetOf(const DawgLexicon& lex2) const;

    /**
     * Returns <code>true</code> if every word of this lexicon is contained in
     * the given list.
     * Equivalent in behavior to containsAll.
     */
    bool isSupersetOf(std::initializer_list<std::string> list) const;

    /**
     * Calls the specified function on each word in the lexicon.
     */
    void mapAll(void (*fn)(std::string)) const;

    /**
     * Calls the specified function on each word in the lexicon.
     */
    void mapAll(void (*fn)(const std::string&)) const;

    /**
     * Calls the specified function on each word in the lexicon.
     */
    template <typename FunctorType>
    void mapAll(FunctorType fn) const;

    // implementation note: DawgLexicon does not support removal,
    // so there are no methods remove(), removeAll, retainAll, etc.
    // nor operators -, -=, *=

    /**
     * Returns the number of words contained in the lexicon.
     */
    int size() const;

    /**
     * Converts the lexicon to a printable string representation such as
     * {"a", "b", "c"}.
     * Note that this can be an expensive operation if the lexicon contains
     * a large number of words.
     */
    std::string toString() const;
    
    /**
     * Returns true if the two lexicons have the same elements.
     */
    bool operator ==(const DawgLexicon& lex2) const;

    /**
     * Returns true if the two lexicons do not have the same elements.
     */
    bool operator !=(const DawgLexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons for ordering.
     */
    bool operator <(const DawgLexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons for ordering.
     */
    bool operator <=(const DawgLexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons for ordering.
     */
    bool operator >(const DawgLexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons for ordering.
     */
    bool operator >=(const DawgLexicon& lex2) const;

    /**
     * Returns the union of this lexicon and the given other lexicon,
     * which is the set of words that appear in at least one of the two.
     */
    DawgLexicon operator +(const DawgLexicon& lex2) const;

    /**
     * Returns the union of this lexicon and the given list,
     * which is the set of words that appear in at least one of the two.
     */
    DawgLexicon operator +(std::initializer_list<std::string> list) const;

    /**
     * Returns the union of this lexicon and the given word.
     */
    DawgLexicon operator +(const std::string& word) const;

    /**
     * Adds all of the words from the given lexicon to this one.
     */
    DawgLexicon& operator +=(const DawgLexicon& lex2);

    /**
     * Adds all of the words from the given list to this lexicon.
     */
    DawgLexicon& operator +=(std::initializer_list<std::string> list);

    /**
     * Adds the given word to this lexicon.
     */
    DawgLexicon& operator +=(const std::string& word);

    /**
     * Allows you to add multiple elements to a lexicon.
     * @example lex += "she", "sells", "sea", "shells";
     */
    DawgLexicon& operator ,(const std::string& word);

    // Implementation note: DawgLexicon does not support -, -=, *, and *=
    // operators like the standard Lexicon.  Because of its binary internal
    // format, it is non-trivial to support removal from a DawgLexicon.

    /*
     * Additional DawgLexicon operations
     * ---------------------------------
     * In addition to the methods listed in this interface, the DawgLexicon
     * class supports the following operations:
     *
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * All iteration is guaranteed to proceed in alphabetical order.  All
     * words in the lexicon are stored in lowercase.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
#ifdef _WIN32
#define LITTLE_ENDIAN 1
#define BYTE_ORDER LITTLE_ENDIAN
#endif

#pragma pack(1)
    struct Edge {
#if defined(BYTE_ORDER) && BYTE_ORDER == LITTLE_ENDIAN
        unsigned long letter:5;
        unsigned long lastEdge:1;
        unsigned long accept:1;
        unsigned long unused:1;
        unsigned long children:24;
#else
        unsigned long children:24;
        unsigned long unused:1;
        unsigned long accept:1;
        unsigned long lastEdge:1;
        unsigned long letter:5;
#endif
    };
#pragma pack()
    Edge* edges;
    Edge* start;
    int numEdges;
    int numDawgWords;
    Set<std::string> otherWords;

public:
    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return lexicons by value
     * and assign from one lexicon to another.  The entire contents of
     * the lexicon, including all words, are copied.  Making copies is
     * generally avoided because of the expense and thus, lexicons are
     * typically passed by reference.  When a copy is needed, these
     * operations are supported.
     */
    DawgLexicon(const DawgLexicon& src);
    DawgLexicon& operator =(const DawgLexicon& src);

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public std::iterator<std::input_iterator_tag, std::string> {
    private:
        const DawgLexicon* lp;
        int index;
        std::string currentDawgPrefix;
        std::string currentSetWord;
        std::string tmpWord;
        Edge* edgePtr;
        Stack<Edge*> stack;
        Set<std::string>::iterator setIterator;
        Set<std::string>::iterator setEnd;

        void advanceToNextWordInDawg();
        void advanceToNextWordInSet();
        void advanceToNextEdge();

    public:
        iterator() : lp(nullptr), index(0), edgePtr(nullptr) {
            /* empty */
        }

        iterator(const DawgLexicon* theLP, bool endFlag) {
            this->lp = theLP;
            if (endFlag) {
                index = lp->size();
            } else {
                index = 0;
                edgePtr = nullptr;
                setIterator = lp->otherWords.begin();
                setEnd = lp->otherWords.end();
                currentDawgPrefix = "";
                currentSetWord = "";
                advanceToNextWordInDawg();
                advanceToNextWordInSet();
            }
        }

        iterator(const iterator& it) {
            lp = it.lp;
            index = it.index;
            currentDawgPrefix = it.currentDawgPrefix;
            currentSetWord = it.currentSetWord;
            edgePtr = it.edgePtr;
            stack = it.stack;
            setIterator = it.setIterator;
        }

        iterator& operator ++() {
            if (!edgePtr) {
                advanceToNextWordInSet();
            } else {
                if (currentSetWord == "" || currentDawgPrefix < currentSetWord) {
                    advanceToNextWordInDawg();
                } else {
                    advanceToNextWordInSet();
                }
            }
            index++;
            return *this;
        }

        iterator operator ++(int) {
            iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const iterator& rhs) {
            return lp == rhs.lp && index == rhs.index;
        }

        bool operator !=(const iterator& rhs) {
            return !(*this == rhs);
        }

        std::string operator *() {
            if (!edgePtr) {
                return currentSetWord;
            }
            if (currentSetWord == "" || currentDawgPrefix < currentSetWord) {
                return currentDawgPrefix + lp->ordToChar(edgePtr->letter);
            } else {
                return currentSetWord;
            }
        }

        std::string* operator ->() {
            if (!edgePtr) {
                return &currentSetWord;
            }
            if (currentSetWord == "" || currentDawgPrefix < currentSetWord) {
                tmpWord = currentDawgPrefix + lp->ordToChar(edgePtr->letter);
                return &tmpWord;
            } else {
                return &currentSetWord;
            }
        }
    };

    /**
     * Returns an iterator positioned at the first word in the lexicon.
     */
    iterator begin() const {
        return iterator(this, /* end */ false);
    }

    /**
     * Returns an iterator positioned at the last word in the lexicon.
     */
    iterator end() const {
        return iterator(this, /* end */ true);
    }

private:
    Edge* findEdgeForChar(Edge* children, char ch) const;
    Edge* traceToLastEdge(const std::string& s) const;
    void readBinaryFile(std::istream& input);
    void readBinaryFile(const std::string& filename);
    void deepCopy(const DawgLexicon& src);
    int countDawgWords(Edge* start) const;

    unsigned int charToOrd(char ch) const {
        return ((unsigned int)(tolower(ch) - 'a' + 1));
    }

    char ordToChar(unsigned int ord) const {
        return ((char)(ord - 1 + 'a'));
    }
};

template <typename FunctorType>
void DawgLexicon::mapAll(FunctorType fn) const {
    for (std::string word : *this) {
        fn(word);
    }
}

/**
 * Hashing function for lexicons.
 */
int hashCode(const DawgLexicon& lex);

/**
 * Prints the lexicon to the given output stream.
 */
std::ostream& operator <<(std::ostream& os, const DawgLexicon& lex);

/**
 * Reads the contents of a lexicon from the given input stream.
 */
std::istream& operator >>(std::istream& is, DawgLexicon& lex);

#endif // _dawglexicon_h

/////////////////////// END code extracted from StanfordCPPLib/collections/dawglexicon.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/linkedhashmap.h ///////////////////////
/*
 * File: linkedhashmap.h
 * ---------------------
 * This file exports the <code>LinkedHashMap</code> class, which stores
 * a set of <i>key</i>-<i>value</i> pairs.
 * Identical to a HashMap except that upon iteration using a for-each loop
 * or << / toString call, it will emit its key/value pairs in the order they
 * were originally inserted.  This is provided at a runtime and memory
 * cost due to needing to store an extra copy of the keys.
 * 
 * @author Marty Stepp
 * @version 2018/03/10
 * - added methods front, back
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/09/22
 * - added support for std initializer_list usage, such as
 *   {{"a", 1}, {"b", 2}, {"c", 3}} in constructor, putAll, removeAll, retainAll,
 *   operators +, +=, -, -=, *, *=
 * - added addAll method
 * - added operators <, <=, >, >=
 * @version 2016/08/12
 * - bug fix in operator >>
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/10/26
 * - initial version
 * @since 2015/10/26
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _linkedhashmap_h
#define _linkedhashmap_h

#include <initializer_list>
#include <iterator>
#include <string>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: LinkedHashMap<KeyType,ValueType>
 * ---------------------------------------
 * 
 */
template <typename KeyType, typename ValueType>
class LinkedHashMap {
public:
    /*
     * Constructor: LinkedHashMap
     * Usage: LinkedHashMap<KeyType, ValueType> map;
     * ---------------------------------------------
     * Initializes a new empty map that associates keys and values of
     * the specified types.  The type used for the key must define
     * the <code>==</code> operator, and there must be a free function
     * with the following signature:
     *
     *<pre>
     *    int hashCode(KeyType key);
     *</pre>
     *
     * that returns a positive integer determined by the key.  This interface
     * exports <code>hashCode</code> functions for <code>string</code> and
     * the C++ primitive types.
     */
    LinkedHashMap();

    /*
     * Constructor: LinkedHashMap
     * Usage: LinkedHashMap<ValueType> map {{"a", 1}, {"b", 2}, {"c", 3}};
     * -------------------------------------------------------------------
     * Initializes a new map that stores the given pairs.
     * Note that the pairs are stored in unpredictable order internally and not
     * necessarily the order in which they are written in the initializer list.
     */
    LinkedHashMap(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Destructor: ~LinkedHashMap
     * --------------------
     * Frees any heap storage associated with this map.
     */
    virtual ~LinkedHashMap();

    /*
     * Method: add
     * Usage: map.add(key, value);
     * ---------------------------
     * Associates <code>key</code> with <code>value</code> in this map.
     * A synonym for the put method.
     */
    void add(const KeyType& key, const ValueType& value);

    /*
     * Method: addAll
     * Usage: map.addAll(map2);
     * ------------------------
     * Adds all key/value pairs from the given map to this map.
     * If both maps contain a pair for the same key, the one from map2 will
     * replace the one from this map.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     * Identical in behavior to putAll.
     */
    LinkedHashMap& addAll(const LinkedHashMap& map2);
    LinkedHashMap& addAll(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Method: back
     * Usage: KeyType value = map.back();
     * ------------------------------------
     * Returns the last key in the map in the order established by the
     * <code>foreach</code> macro.  If the map is empty, generates an error.
     */
    KeyType back() const;

    /*
     * Method: clear
     * Usage: map.clear();
     * -------------------
     * Removes all entries from this map.
     */
    void clear();

    /*
     * Method: containsKey
     * Usage: if (map.containsKey(key)) ...
     * ------------------------------------
     * Returns <code>true</code> if there is an entry for <code>key</code>
     * in this map.
     */
    bool containsKey(const KeyType& key) const;

    /*
     * Method: equals
     * Usage: if (map.equals(map2)) ...
     * --------------------------------
     * Returns <code>true</code> if the two maps contain exactly the same
     * key/value pairs, and <code>false</code> otherwise.
     */
    bool equals(const LinkedHashMap& map2) const;

    /*
     * Method: front
     * Usage: KeyType value = map.front();
     * -------------------------------------
     * Returns the first key in the map in the order established by the
     * <code>foreach</code> macro.  If the map is empty, generates an error.
     */
    KeyType front() const;

    /*
     * Method: get
     * Usage: ValueType value = map.get(key);
     * --------------------------------------
     * Returns the value associated with <code>key</code> in this map.
     * If <code>key</code> is not found, <code>get</code> returns the
     * default value for <code>ValueType</code>.
     */
    ValueType get(const KeyType& key) const;

    /*
     * Method: isEmpty
     * Usage: if (map.isEmpty()) ...
     * -----------------------------
     * Returns <code>true</code> if this map contains no entries.
     */
    bool isEmpty() const;
    
    /*
     * Method: keys
     * Usage: Vector<KeyType> keys = map.keys();
     * -----------------------------------------
     * Returns a collection containing all keys in this map.
     * This implementation already retains an internal copy of the keys,
     * so it is efficient to call this function even on large maps.
     */
    const Vector<KeyType>& keys() const;

    /*
     * Method: mapAll
     * Usage: map.mapAll(fn);
     * ----------------------
     * Iterates through the map entries and calls <code>fn(key, value)</code>
     * for each one.  The keys are processed in an undetermined order.
     */
    void mapAll(void (*fn)(KeyType, ValueType)) const;
    void mapAll(void (*fn)(const KeyType&, const ValueType&)) const;
    
    template <typename FunctorType>
    void mapAll(FunctorType fn) const;

    /*
     * Method: put
     * Usage: map.put(key, value);
     * ---------------------------
     * Associates <code>key</code> with <code>value</code> in this map.
     * Any previous value associated with <code>key</code> is replaced
     * by the new value.
     */
    void put(const KeyType& key, const ValueType& value);

    /*
     * Method: putAll
     * Usage: map.putAll(map2);
     * ---------------------------
     * Adds all key/value pairs from the given map to this map.
     * If both maps contain a pair for the same key, the one from map2 will
     * replace the one from this map.
     * Returns a reference to this map.
     */
    LinkedHashMap& putAll(const LinkedHashMap& map2);
    LinkedHashMap& putAll(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Method: remove
     * Usage: map.remove(key);
     * -----------------------
     * Removes any entry for <code>key</code> from this map.
     * If the given key is not found, has no effect.
     */
    void remove(const KeyType& key);

    /*
     * Method: removeAll
     * Usage: map.removeAll(map2);
     * ---------------------------
     * Removes all key/value pairs from this map that are contained in the given map.
     * If both maps contain the same key but it maps to different values, that
     * mapping will not be removed.
     * Returns a reference to this map.
     */
    LinkedHashMap& removeAll(const LinkedHashMap& map2);
    LinkedHashMap& removeAll(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Method: retainAll
     * Usage: map.retainAll(map2);
     * ---------------------------
     * Removes all key/value pairs from this map that are not contained in the given map.
     * If both maps contain the same key but it maps to different values, that
     * mapping will be removed.
     * Returns a reference to this map.
     */
    LinkedHashMap& retainAll(const LinkedHashMap& map2);
    LinkedHashMap& retainAll(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Method: size
     * Usage: int nEntries = map.size();
     * ---------------------------------
     * Returns the number of entries in this map.
     */
    int size() const;

    /*
     * Method: toString
     * Usage: string str = map.toString();
     * -----------------------------------
     * Converts the map to a printable string representation.
     */
    std::string toString() const;

    /*
     * Method: values
     * Usage: Vector<ValueType> values = map.values();
     * -----------------------------------------------
     * Returns a collection containing all values in this map.
     * Note that this implementation makes a deep copy of the values,
     * so it is inefficient to call on large maps.
     */
    Vector<ValueType> values() const;

    /*
     * Operator: []
     * Usage: map[key]
     * ---------------
     * Selects the value associated with <code>key</code>.  This syntax
     * makes it easy to think of a map as an "associative array"
     * indexed by the key type.  If <code>key</code> is already present
     * in the map, this function returns a reference to its associated
     * value.  If key is not present in the map, a new entry is created
     * whose value is set to the default for the value type.
     */
    // ValueType& operator [](const KeyType& key);
    ValueType operator [](const KeyType& key) const;

    /*
     * Operator: ==
     * Usage: if (map1 == map2) ...
     * ----------------------------
     * Compares two maps for equality.
     */
    bool operator ==(const LinkedHashMap& map2) const;

    /*
     * Operator: !=
     * Usage: if (map1 != map2) ...
     * ----------------------------
     * Compares two maps for inequality.
     */
    bool operator !=(const LinkedHashMap& map2) const;

    /*
     * Operators: <, <=, >, >=
     * Usage: if (map1 < map2) ...
     * ---------------------------
     * Relational operators to compare two maps.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const LinkedHashMap& map2) const;
    bool operator <=(const LinkedHashMap& map2) const;
    bool operator >(const LinkedHashMap& map2) const;
    bool operator >=(const LinkedHashMap& map2) const;

    /*
     * Operator: +
     * Usage: map1 + map2
     * ------------------
     * Returns the union of the two maps, equivalent to a copy of the first map
     * with addAll called on it passing the second map as a parameter.
     * If the two maps both contain a mapping for the same key, the mapping
     * from the second map is favored.
     */
    LinkedHashMap operator +(const LinkedHashMap& map2) const;
    LinkedHashMap operator +(std::initializer_list<std::pair<KeyType, ValueType> > list) const;

    /*
     * Operator: +=
     * Usage: map1 += map2;
     * --------------------
     * Adds all key/value pairs from the given map to this map.
     * Equivalent to calling addAll(map2).
     */
    LinkedHashMap& operator +=(const LinkedHashMap& map2);
    LinkedHashMap& operator +=(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Operator: -
     * Usage: map1 - map2
     * ------------------
     * Returns the difference of the two maps, equivalent to a copy of the first map
     * with removeAll called on it passing the second map as a parameter.
     */
    LinkedHashMap operator -(const LinkedHashMap& map2) const;
    LinkedHashMap operator -(std::initializer_list<std::pair<KeyType, ValueType> > list) const;

    /*
     * Operator: -=
     * Usage: map1 -= map2;
     * --------------------
     * Removes all key/value pairs from the given map to this map.
     * Equivalent to calling removeAll(map2).
     */
    LinkedHashMap& operator -=(const LinkedHashMap& map2);
    LinkedHashMap& operator -=(std::initializer_list<std::pair<KeyType, ValueType> > list);

    /*
     * Operator: *
     * Usage: map1 * map2
     * ------------------
     * Returns the intersection of the two maps, equivalent to a copy of the first map
     * with retainAll called on it passing the second map as a parameter.
     */
    LinkedHashMap operator *(const LinkedHashMap& map2) const;
    LinkedHashMap operator *(std::initializer_list<std::pair<KeyType, ValueType> > list) const;

    /*
     * Operator: *=
     * Usage: map1 *= map2;
     * ---------------------
     * Removes all key/value pairs that are not found in the given map from this map.
     * Equivalent to calling retainAll(map2).
     */
    LinkedHashMap& operator *=(const LinkedHashMap& map2);
    LinkedHashMap& operator *=(std::initializer_list<std::pair<KeyType, ValueType> > list);

    template <typename K, typename V>
    friend std::ostream& operator <<(std::ostream& os, const LinkedHashMap<K, V>& map);
    
    /*
     * Additional LinkedHashMap operations
     * -----------------------------------
     * In addition to the methods listed in this interface, the HashMap
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * During iteration, the LinkedHashMap class returns its keys in the
     * order they were added.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes:
     * ---------------------
     * The LinkedHashMap class is represented using a hash map along with a
     * Vector to remember the order of insertion.
    */
private:
    HashMap<KeyType, ValueType> innerMap;
    Vector<KeyType> keyVector;

public:
    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods
     * in the public interface would make that interface more
     * difficult to understand for the average client.
     */

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public Vector<KeyType>::iterator {
    public:
        iterator() : Vector<KeyType>::iterator() {}
        iterator(const iterator& it) : Vector<KeyType>::iterator(it) {}
        iterator(const typename Vector<KeyType>::iterator& it) : Vector<KeyType>::iterator(it) {}
    };

    /*
     * Returns an iterator positioned at the first key of the map.
     */
    iterator begin() const {
        return iterator(keyVector.begin());
    }

    /*
     * Returns an iterator positioned at the last key of the map.
     */
    iterator end() const {
        return iterator(keyVector.end());
    }
};

/*
 * Implementation notes: LinkedHashMap class
 * -----------------------------------------
 * ...
 */
template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>::LinkedHashMap() {
    // empty
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>::LinkedHashMap(std::initializer_list<std::pair<KeyType, ValueType> > list) {
    putAll(list);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>::~LinkedHashMap() {
    // empty
}

template <typename KeyType, typename ValueType>
void LinkedHashMap<KeyType, ValueType>::add(const KeyType& key, const ValueType& value) {
    put(key, value);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::addAll(const LinkedHashMap& map2) {
    return putAll(map2);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::addAll(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    return putAll(list);
}

template <typename KeyType, typename ValueType>
KeyType LinkedHashMap<KeyType, ValueType>::back() const {
    if (isEmpty()) {
        error("LinkedHashMap::back: map is empty");
    }
    return keyVector.back();
}

template <typename KeyType, typename ValueType>
void LinkedHashMap<KeyType, ValueType>::clear() {
    innerMap.clear();
    keyVector.clear();
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::containsKey(const KeyType& key) const {
    return innerMap.containsKey(key);
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::equals(const LinkedHashMap<KeyType, ValueType>& map2) const {
    return stanfordcpplib::collections::equalsMap(*this, map2);
}

template <typename KeyType, typename ValueType>
KeyType LinkedHashMap<KeyType, ValueType>::front() const {
    if (isEmpty()) {
        error("LinkedHashMap::front: map is empty");
    }
    return keyVector.front();
}

template <typename KeyType, typename ValueType>
ValueType LinkedHashMap<KeyType, ValueType>::get(const KeyType& key) const {
    return innerMap.get(key);
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::isEmpty() const {
    return innerMap.isEmpty();
}

template <typename KeyType, typename ValueType>
const Vector<KeyType>& LinkedHashMap<KeyType, ValueType>::keys() const {
    return keyVector;
}

template <typename KeyType, typename ValueType>
void LinkedHashMap<KeyType, ValueType>::mapAll(void (*fn)(KeyType, ValueType)) const {
    innerMap.mapAll(fn);
}

template <typename KeyType, typename ValueType>
void LinkedHashMap<KeyType, ValueType>::mapAll(void (*fn)(const KeyType&,
                                                   const ValueType&)) const {
    innerMap.mapAll(fn);
}

template <typename KeyType, typename ValueType>
template <typename FunctorType>
void LinkedHashMap<KeyType, ValueType>::mapAll(FunctorType fn) const {
    innerMap.mapAll(fn);
}

template <typename KeyType, typename ValueType>
void LinkedHashMap<KeyType, ValueType>::put(const KeyType& key, const ValueType& value) {
    innerMap.put(key, value);
    keyVector.add(key);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::putAll(const LinkedHashMap& map2) {
    for (const KeyType& key : map2) {
        put(key, map2.get(key));
    }
    return *this;
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::putAll(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    for (const std::pair<KeyType, ValueType>& pair : list) {
        put(pair.first, pair.second);
    }
    return *this;
}

template <typename KeyType, typename ValueType>
void LinkedHashMap<KeyType, ValueType>::remove(const KeyType& key) {
    innerMap.remove(key);
    for (int i = 0, sz = keyVector.size(); i < sz; i++) {
        if (keyVector[i] == key) {
            keyVector.remove(i);
            break;
        }
    }
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::removeAll(const LinkedHashMap& map2) {
    for (const KeyType& key : map2) {
        if (containsKey(key) && get(key) == map2.get(key)) {
            remove(key);
        }
    }
    return *this;
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::removeAll(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    for (const std::pair<KeyType, ValueType>& pair : list) {
        if (containsKey(pair.first) && get(pair.first) == pair.second) {
            remove(pair.first);
        }
    }
    return *this;
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::retainAll(const LinkedHashMap& map2) {
    Vector<KeyType> toRemove;
    for (const KeyType& key : *this) {
        if (!map2.containsKey(key) || get(key) != map2.get(key)) {
            toRemove.add(key);
        }
    }
    for (const KeyType& key : toRemove) {
        remove(key);
    }
    return *this;
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::retainAll(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    LinkedHashMap<KeyType, ValueType> map2(list);
    retainAll(map2);
    return *this;
}

template <typename KeyType, typename ValueType>
int LinkedHashMap<KeyType, ValueType>::size() const {
    return innerMap.size();
}

template <typename KeyType, typename ValueType>
std::string LinkedHashMap<KeyType, ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename KeyType, typename ValueType>
Vector<ValueType> LinkedHashMap<KeyType, ValueType>::values() const {
    Vector<ValueType> values;
    for (const KeyType& key : *this) {
        values.add(get(key));
    }
    return values;
}

template <typename KeyType, typename ValueType>
ValueType LinkedHashMap<KeyType, ValueType>::operator [](const KeyType& key) const {
    return innerMap[key];
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType> LinkedHashMap<KeyType, ValueType>::operator +(const LinkedHashMap& map2) const {
    LinkedHashMap<KeyType, ValueType> result = *this;
    return result.putAll(map2);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType> LinkedHashMap<KeyType, ValueType>::operator +(
        std::initializer_list<std::pair<KeyType, ValueType> > list) const {
    LinkedHashMap<KeyType, ValueType> result = *this;
    return result.putAll(list);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::operator +=(const LinkedHashMap& map2) {
    return putAll(map2);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::operator +=(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    return putAll(list);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType> LinkedHashMap<KeyType, ValueType>::operator -(const LinkedHashMap& map2) const {
    LinkedHashMap<KeyType, ValueType> result = *this;
    return result.removeAll(map2);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType> LinkedHashMap<KeyType, ValueType>::operator -(
        std::initializer_list<std::pair<KeyType, ValueType> > list) const {
    LinkedHashMap<KeyType, ValueType> result = *this;
    return result.removeAll(list);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::operator -=(const LinkedHashMap& map2) {
    return removeAll(map2);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::operator -=(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    return removeAll(list);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType> LinkedHashMap<KeyType, ValueType>::operator *(const LinkedHashMap& map2) const {
    LinkedHashMap<KeyType, ValueType> result = *this;
    return result.retainAll(map2);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType> LinkedHashMap<KeyType, ValueType>::operator *(
        std::initializer_list<std::pair<KeyType, ValueType> > list) const {
    LinkedHashMap<KeyType, ValueType> result = *this;
    return result.retainAll(list);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::operator *=(const LinkedHashMap& map2) {
    return retainAll(map2);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::operator *=(
        std::initializer_list<std::pair<KeyType, ValueType> > list) {
    return retainAll(list);
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::operator ==(const LinkedHashMap& map2) const {
    return equals(map2);
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::operator !=(const LinkedHashMap& map2) const {
    return !equals(map2);
}

// Implementation note:
// The definitions of <, <=, >, and >= are a bit unintuitive here.
// Because Maps are considered to be "equal" if they have the same key/value pairs,
// regardless of order, the equals() method and == / != operators ignore order.
//
// Similarly, if you ask whether a map is <= or >= to another, this includes
// the notion of equality, so it should return true if the maps contain the same
// pairs, regardless of order.
//
// If you ask whether a map is < or > to another, it is assumed that you don't
// want this to return true if they are "equal", so we must check for non-equality
// before checking the K/V pairs pairwise.
//
// This issue is unique to LinkedHashMap because Map sorts into a predictable sorted order
// and HashMap opts not to implement <, <=, >, or >= due to its unpredictable hash order.

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::operator <(const LinkedHashMap& map2) const {
    return !equals(map2) && stanfordcpplib::collections::compareMaps(*this, map2) < 0;
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::operator <=(const LinkedHashMap& map2) const {
    return equals(map2) || stanfordcpplib::collections::compareMaps(*this, map2) <= 0;
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::operator >(const LinkedHashMap& map2) const {
    return !equals(map2) && stanfordcpplib::collections::compareMaps(*this, map2) > 0;
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::operator >=(const LinkedHashMap& map2) const {
    return equals(map2) || stanfordcpplib::collections::compareMaps(*this, map2) >= 0;
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename KeyType, typename ValueType>
std::ostream& operator <<(std::ostream& os,
                          const LinkedHashMap<KeyType, ValueType>& map) {
    return stanfordcpplib::collections::writeMap(os, map);
}

template <typename KeyType, typename ValueType>
std::istream& operator >>(std::istream& is,
                          LinkedHashMap<KeyType, ValueType>& map) {
    KeyType key;
    ValueType value;
    return stanfordcpplib::collections::readMap(is, map, key, value, /* descriptor */ std::string("LinkedHashMap::operator >>"));
}

/*
 * Template hash function for hash maps.
 * Requires the key and value types in the LinkedHashMap to have a hashCode function.
 */
template <typename K, typename V>
int hashCode(const LinkedHashMap<K, V>& map) {
    return stanfordcpplib::collections::hashCodeMap(map, /* orderMatters */ false);
}

/*
 * Function: randomKey
 * Usage: element = randomKey(map);
 * --------------------------------
 * Returns a randomly chosen key of the given map.
 * Throws an error if the map is empty.
 */
template <typename K, typename V>
const K& randomKey(const LinkedHashMap<K, V>& map) {
    if (map.isEmpty()) {
        error("randomKey: empty map was passed");
    }
    int index = randomInteger(0, map.size() - 1);
    int i = 0;
    for (const K& key : map) {
        if (i == index) {
            return key;
        }
        i++;
    }
    
    // this code will never be reached
    static Vector<K> v = map.keys();
    return v[0];
}

#endif // _linkedhashmap_h

/////////////////////// END code extracted from StanfordCPPLib/collections/linkedhashmap.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/linkedhashset.h ///////////////////////
/*
 * File: linkedhashset.h
 * ---------------------
 * This file exports the <code>LinkedHashSet</code> class, which
 * implements an efficient abstraction for storing sets of values.
 * 
 * @author Marty Stepp
 * @version 2018/03/10
 * - added methods front, back
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/09/22
 * - added containsAll, isSupersetOf methods
 * - added support for std initializer_list usage, such as {1, 2, 3}
 *   in constructor, addAll, containsAll, isSubsetOf, isSupersetOf, removeAll,
 *   retainAll, and operators +, +=, -, -=, *, *=
 * - bug fix in hashCode function
 * - added operators <, <=, >, >=
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/10/26
 * - initial version
 * @since 2015/10/26
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _linkedhashset_h
#define _linkedhashset_h

#include <initializer_list>
#include <iostream>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: LinkedHashSet<ValueType>
 * -------------------------------
 * Identical to a HashSet except that upon iteration using a for-each loop
 * or << / toString call, it will emit its elements in the order they were
 * originally inserted.  This is provided at a runtime and memory
 * cost due to needing to store an extra copy of the elements.
 */
template <typename ValueType>
class LinkedHashSet {
public:
    /*
     * Constructor: LinkedHashSet
     * Usage: LinkedHashSet<ValueType> set;
     * ------------------------------------
     * Initializes an empty set of the specified element type.
     */
    LinkedHashSet();

    /*
     * Constructor: LinkedHashSet
     * Usage: LinkedHashSet<ValueType> set {1, 2, 3};
     * ----------------------------------------------
     * Initializes a new set that stores the given elements.
     * Note that the elements are stored in unpredictable order internally and not
     * necessarily the order in which they are written in the initializer list.
     */
    LinkedHashSet(std::initializer_list<ValueType> list);

    /*
     * Destructor: ~LinkedHashSet
     * --------------------------
     * Frees any heap storage associated with this set.
     */
    virtual ~LinkedHashSet();

    /*
     * Method: add
     * Usage: set.add(value);
     * ----------------------
     * Adds an element to this set, if it was not already there.  For
     * compatibility with the STL <code>set</code> class, this method
     * is also exported as <code>insert</code>.
     */
    void add(const ValueType& value);
    
    /*
     * Method: addAll
     * Usage: set.addAll(set2);
     * ------------------------
     * Adds all elements of the given other set to this set.
     * Returns a reference to this set.
     * Identical in behavior to the += operator.
     */
    LinkedHashSet<ValueType>& addAll(const LinkedHashSet<ValueType>& set);
    LinkedHashSet<ValueType>& addAll(std::initializer_list<ValueType> list);

    /*
     * Method: back
     * Usage: ValueType value = set.back();
     * ------------------------------------
     * Returns the last value in the set in the order established by the
     * <code>foreach</code> macro.  If the set is empty, generates an error.
     */
    ValueType back() const;

    /*
     * Method: clear
     * Usage: set.clear();
     * -------------------
     * Removes all elements from this set.
     */
    void clear();
    
    /*
     * Method: contains
     * Usage: if (set.contains(value)) ...
     * -----------------------------------
     * Returns <code>true</code> if the specified value is in this set.
     */
    bool contains(const ValueType& value) const;

    /*
     * Method: containsAll
     * Usage: if (set.containsAll(set2)) ...
     * -------------------------------------
     * Returns <code>true</code> if every value from the given other set
     * is also found in this set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Equivalent in behavior to isSupersetOf.
     */
    bool containsAll(const LinkedHashSet<ValueType>& set2) const;
    bool containsAll(std::initializer_list<ValueType> list) const;

    /*
     * Method: equals
     * Usage: if (set.equals(set2)) ...
     * --------------------------------
     * Returns <code>true</code> if this set contains exactly the same values
     * as the given other set.
     * Identical in behavior to the == operator.
     */
    bool equals(const LinkedHashSet<ValueType>& set2) const;
    
    /*
     * Method: first
     * Usage: ValueType value = set.first();
     * -------------------------------------
     * Returns the first value in the set in the order established by the
     * <code>foreach</code> macro.  If the set is empty, <code>first</code>
     * generates an error.
     */
    ValueType first() const;

    /*
     * Method: front
     * Usage: ValueType value = set.front();
     * -------------------------------------
     * Returns the first value in the set in the order established by the
     * <code>foreach</code> macro.  If the set is empty, generates an error.
     * Equivalent to first.
     */
    ValueType front() const;

    /*
     * Method: insert
     * Usage: set.insert(value);
     * -------------------------
     * Adds an element to this set, if it was not already there.  This
     * method is exported for compatibility with the STL <code>set</code> class.
     */
    void insert(const ValueType& value);

    /*
     * Method: isEmpty
     * Usage: if (set.isEmpty()) ...
     * -----------------------------
     * Returns <code>true</code> if this set contains no elements.
     */
    bool isEmpty() const;
    
    /*
     * Method: isSubsetOf
     * Usage: if (set.isSubsetOf(set2)) ...
     * ------------------------------------
     * Implements the subset relation on sets.  It returns
     * <code>true</code> if every element of this set is
     * contained in <code>set2</code>.
     */
    bool isSubsetOf(const LinkedHashSet& set2) const;
    bool isSubsetOf(std::initializer_list<ValueType> list) const;

    /*
     * Method: isSupersetOf
     * Usage: if (set.isSupersetOf(set2)) ...
     * --------------------------------------
     * Implements the superset relation on sets.  It returns
     * <code>true</code> if every element of this set is
     * contained in <code>set2</code>.
     * Note that this will be true if the sets are equal.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Equivalent in behavior to containsAll.
     */
    bool isSupersetOf(const LinkedHashSet& set2) const;
    bool isSupersetOf(std::initializer_list<ValueType> list) const;

    /*
     * Method: mapAll
     * Usage: set.mapAll(fn);
     * ----------------------
     * Iterates through the elements of the set and calls <code>fn(value)</code>
     * for each one.  The values are processed in ascending order, as defined
     * by the comparison function.
     */
    void mapAll(void (*fn)(ValueType)) const;
    void mapAll(void (*fn)(const ValueType&)) const;

    template <typename FunctorType>
    void mapAll(FunctorType fn) const;
    
    /*
     * Method: remove
     * Usage: set.remove(value);
     * -------------------------
     * Removes an element from this set.  If the value was not
     * contained in the set, no error is generated and the set
     * remains unchanged.
     */
    void remove(const ValueType& value);
    
    /*
     * Method: removeAll
     * Usage: set.removeAll(set2);
     * ---------------------------
     * Removes all elements of the given other set from this set.
     * Returns a reference to this set.
     * Identical in behavior to the -= operator.
     */
    LinkedHashSet<ValueType>& removeAll(const LinkedHashSet<ValueType>& set);
    LinkedHashSet<ValueType>& removeAll(std::initializer_list<ValueType> list);

    /*
     * Method: retainAll
     * Usage: set.retainAll(set2);
     * ----------------------
     * Removes all elements from this set that are not contained in the given
     * other set. Returns a reference to this set.
     * Identical in behavior to the *= operator.
     */
    LinkedHashSet<ValueType>& retainAll(const LinkedHashSet<ValueType>& set);
    LinkedHashSet<ValueType>& retainAll(std::initializer_list<ValueType> list);

    /*
     * Method: size
     * Usage: count = set.size();
     * --------------------------
     * Returns the number of elements in this set.
     */
    int size() const;
    
    /*
     * Method: toString
     * Usage: string str = set.toString();
     * -----------------------------------
     * Converts the set to a printable string representation.
     */
    std::string toString() const;

    /*
     * Operator: ==
     * Usage: set1 == set2
     * -------------------
     * Returns <code>true</code> if <code>set1</code> and <code>set2</code>
     * contain the same elements.
     */
    bool operator ==(const LinkedHashSet& set2) const;

    /*
     * Operator: !=
     * Usage: set1 != set2
     * -------------------
     * Returns <code>true</code> if <code>set1</code> and <code>set2</code>
     * are different.
     */
    bool operator !=(const LinkedHashSet& set2) const;

    /*
     * Operators: <, >, <=, >=
     * Usage: if (set1 <= set2) ...
     * ...
     * ----------------------------
     * Relational operators to compare two sets.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const LinkedHashSet& set2) const;
    bool operator <=(const LinkedHashSet& set2) const;
    bool operator >(const LinkedHashSet& set2) const;
    bool operator >=(const LinkedHashSet& set2) const;

    /*
     * Operator: +
     * Usage: set1 + set2
     *        set1 + element
     * ---------------------
     * Returns the union of sets <code>set1</code> and <code>set2</code>, which
     * is the set of elements that appear in at least one of the two sets.  The
     * right hand set can be replaced by an element of the value type, in which
     * case the operator returns a new set formed by adding that element.
     */
    LinkedHashSet operator +(const LinkedHashSet& set2) const;
    LinkedHashSet operator +(std::initializer_list<ValueType> list) const;
    LinkedHashSet operator +(const ValueType& element) const;

    /*
     * Operator: *
     * Usage: set1 * set2
     * ------------------
     * Returns the intersection of sets <code>set1</code> and <code>set2</code>,
     * which is the set of all elements that appear in both.
     */
    LinkedHashSet operator *(const LinkedHashSet& set2) const;
    LinkedHashSet operator *(std::initializer_list<ValueType> list) const;

    /*
     * Operator: -
     * Usage: set1 - set2
     *        set1 - element
     * ---------------------
     * Returns the difference of sets <code>set1</code> and <code>set2</code>,
     * which is all of the elements that appear in <code>set1</code> but
     * not <code>set2</code>.  The right hand set can be replaced by an
     * element of the value type, in which case the operator returns a new
     * set formed by removing that element.
     */
    LinkedHashSet operator -(const LinkedHashSet& set2) const;
    LinkedHashSet operator -(std::initializer_list<ValueType> list) const;
    LinkedHashSet operator -(const ValueType& element) const;

    /*
     * Operator: +=
     * Usage: set1 += set2;
     *        set1 += value;
     * ---------------------
     * Adds all of the elements from <code>set2</code> (or the single
     * specified value) to <code>set1</code>.  As a convenience, the
     * <code>LinkedHashSet</code> package also overloads the comma operator so
     * that it is possible to initialize a set like this:
     *
     *<pre>
     *    LinkedHashSet&lt;int&lt; digits;
     *    digits += 0, 1, 2, 3, 4, 5, 6, 7, 8, 9;
     *</pre>
     */
    LinkedHashSet& operator +=(const LinkedHashSet& set2);
    LinkedHashSet& operator +=(std::initializer_list<ValueType> list);
    LinkedHashSet& operator +=(const ValueType& value);

    /*
     * Operator: *=
     * Usage: set1 *= set2;
     * --------------------
     * Removes any elements from <code>set1</code> that are not present in
     * <code>set2</code>.
     */
    LinkedHashSet& operator *=(const LinkedHashSet& set2);
    LinkedHashSet& operator *=(std::initializer_list<ValueType> list);

    /*
     * Operator: -=
     * Usage: set1 -= set2;
     *        set1 -= value;
     * ---------------------
     * Removes the elements from <code>set2</code> (or the single
     * specified value) from <code>set1</code>.  As a convenience, the
     * <code>LinkedHashSet</code> package also overloads the comma operator so
     * that it is possible to remove multiple elements from a set
     * like this:
     *
     *<pre>
     *    digits -= 0, 2, 4, 6, 8;
     *</pre>
     *
     * which removes the values 0, 2, 4, 6, and 8 from the set
     * <code>digits</code>.
     */
    LinkedHashSet& operator -=(const LinkedHashSet& set2);
    LinkedHashSet& operator -=(std::initializer_list<ValueType> list);
    LinkedHashSet& operator -=(const ValueType& value);

    /*
     * Additional LinkedHashSet operations
     * -----------------------------------
     * In addition to the methods listed in this interface, the LinkedHashSet
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * The iteration forms process the LinkedHashSet in the order of insertion.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    LinkedHashMap<ValueType, bool> map;  /* Map used to store the element     */
    bool removeFlag;                     /* Flag to differentiate += and -=   */

public:
    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support the comma operator, deep copying, and iteration.
     * Including these methods in the public interface would make
     * that interface more difficult to understand for the average client.
     */
    LinkedHashSet& operator ,(const ValueType& value) {
        if (this->removeFlag) {
            this->remove(value);
        } else {
            this->add(value);
        }
        return *this;
    }

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public std::iterator<std::input_iterator_tag,ValueType> {
    private:
        typename LinkedHashMap<ValueType,bool>::iterator mapit;

    public:
        iterator() {
            /* Empty */
        }

        iterator(typename LinkedHashMap<ValueType, bool>::iterator it) : mapit(it) {
            /* Empty */
        }

        iterator(const iterator& it) {
            mapit = it.mapit;
        }

        iterator& operator ++() {
            ++mapit;
            return *this;
        }

        iterator operator ++(int) {
            iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const iterator& rhs) {
            return mapit == rhs.mapit;
        }

        bool operator !=(const iterator& rhs) {
            return !(*this == rhs);
        }

        ValueType& operator *() {
            return *mapit;
        }

        ValueType* operator ->() {
            return mapit;
        }
    };

    iterator begin() const {
        return iterator(map.begin());
    }

    iterator end() const {
        return iterator(map.end());
    }
};

template <typename ValueType>
LinkedHashSet<ValueType>::LinkedHashSet() : removeFlag(false) {
    /* Empty */
}

template <typename ValueType>
LinkedHashSet<ValueType>::LinkedHashSet(std::initializer_list<ValueType> list)
        : removeFlag(false) {
    addAll(list);
}

template <typename ValueType>
LinkedHashSet<ValueType>::~LinkedHashSet() {
    /* Empty */
}

template <typename ValueType>
void LinkedHashSet<ValueType>::add(const ValueType& value) {
    map.put(value, true);
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::addAll(const LinkedHashSet& set2) {
    for (ValueType value : set2) {
        this->add(value);
    }
    return *this;
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::addAll(std::initializer_list<ValueType> list) {
    for (const ValueType& value : list) {
        this->add(value);
    }
    return *this;
}

template <typename ValueType>
ValueType LinkedHashSet<ValueType>::back() const {
    if (isEmpty()) {
        error("LinkedHashSet::back: set is empty");
    }
    return map.back();
}

template <typename ValueType>
void LinkedHashSet<ValueType>::clear() {
    map.clear();
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::contains(const ValueType& value) const {
    return map.containsKey(value);
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::containsAll(const LinkedHashSet<ValueType>& set2) const {
    for (const ValueType& value : set2) {
        if (!contains(value)) {
            return false;
        }
    }
    return true;
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::containsAll(std::initializer_list<ValueType> list) const {
    for (const ValueType& value : list) {
        if (!contains(value)) {
            return false;
        }
    }
    return true;
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::equals(const LinkedHashSet<ValueType>& set2) const {
    // optimization: if literally same set, stop
    if (this == &set2) {
        return true;
    }

    if (size() != set2.size()) {
        return false;
    }

    return isSubsetOf(set2) && set2.isSubsetOf(*this);
}

template <typename ValueType>
ValueType LinkedHashSet<ValueType>::first() const {
    if (isEmpty()) {
        error("LinkedHashSet::first: set is empty");
    }
    return *begin();
}

template <typename ValueType>
ValueType LinkedHashSet<ValueType>::front() const {
    if (isEmpty()) {
        error("LinkedHashSet::front: set is empty");
    }
    return map.front();
}

template <typename ValueType>
void LinkedHashSet<ValueType>::insert(const ValueType& value) {
    map.put(value, true);
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::isEmpty() const {
    return map.isEmpty();
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::isSubsetOf(const LinkedHashSet& set2) const {
    iterator it = begin();
    iterator end = this->end();
    while (it != end) {
        if (!set2.map.containsKey(*it)) {
            return false;
        }
        ++it;
    }
    return true;
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::isSubsetOf(std::initializer_list<ValueType> list) const {
    LinkedHashSet<ValueType> set2(list);
    return isSubsetOf(set2);
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::isSupersetOf(const LinkedHashSet& set2) const {
    return containsAll(set2);
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::isSupersetOf(std::initializer_list<ValueType> list) const {
    return containsAll(list);
}

template <typename ValueType>
void LinkedHashSet<ValueType>::mapAll(void (*fn)(ValueType)) const {
    map.mapAll(fn);
}

template <typename ValueType>
void LinkedHashSet<ValueType>::mapAll(void (*fn)(const ValueType&)) const {
    map.mapAll(fn);
}

template <typename ValueType>
template <typename FunctorType>
void LinkedHashSet<ValueType>::mapAll(FunctorType fn) const {
    map.mapAll(fn);
}

template <typename ValueType>
void LinkedHashSet<ValueType>::remove(const ValueType& value) {
    map.remove(value);
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::removeAll(const LinkedHashSet& set2) {
    Vector<ValueType> toRemove;
    for (const ValueType& value : *this) {
        if (set2.map.containsKey(value)) {
            toRemove.add(value);
        }
    }
    for (const ValueType& value : toRemove) {
        remove(value);
    }
    return *this;
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::removeAll(std::initializer_list<ValueType> list) {
    for (const ValueType& value : list) {
        remove(value);
    }
    return *this;
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::retainAll(const LinkedHashSet& set2) {
    Vector<ValueType> toRemove;
    for (const ValueType& value : *this) {
        if (!set2.map.containsKey(value)) {
            toRemove.add(value);
        }
    }
    for (const ValueType& value : toRemove) {
        remove(value);
    }
    return *this;
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::retainAll(std::initializer_list<ValueType> list) {
    LinkedHashSet<ValueType> set2(list);
    return retainAll(set2);
}

template <typename ValueType>
int LinkedHashSet<ValueType>::size() const {
    return map.size();
}

template <typename ValueType>
std::string LinkedHashSet<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

/*
 * Implementation notes: set operators
 * -----------------------------------
 * The implementations for the set operators use iteration to walk
 * over the elements in one or both sets.
 */
template <typename ValueType>
bool LinkedHashSet<ValueType>::operator ==(const LinkedHashSet& set2) const {
    return equals(set2);
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::operator !=(const LinkedHashSet& set2) const {
    return !equals(set2);
}

// Implementation note:
// The definitions of <, <=, >, and >= are a bit unintuitive here.
// Because Sets are considered to be "equal" if they have the same elements,
// regardless of order, the equals() method and == / != operators ignore order.
//
// Example: {1, 2, 3, 4} == {4, 3, 2, 1}  true
//
// Similarly, if you ask whether a set is <= or >= to another, this includes
// the notion of equality, so it should return true if the sets contain the same
// elements, regardless of order.
//
// Example: {1, 2, 3, 4} == {4, 3, 2, 1}  true
// Example: {1, 2, 3, 4} <= {4, 3, 2, 1}  true
// Example: {1, 2, 3, 4} >= {4, 3, 2, 1}  true
//
// If you ask whether a set is < or > to another, it is assumed that you don't
// want this to return true if they are "equal", so we must check for non-equality
// before checking the elements pairwise.
//
// Example: {1, 2, 3, 4} <  {4, 3, 2, 1}       false   (because equal)
// Example: {4, 2, 3, 1} >  {1, 3, 2, 4}       false   (because equal)
// Example: {1, 2, 3, 4} <  {4, 3, 2}          true
// Example: {1, 2, 3, 4} <= {4, 3, 2}          true
// Example: {1, 2, 3, 4} <  {4, 3, 2, 1, 0}    true
// Example: {1, 2, 3, 4} <= {4, 3, 2, 1, 0}    true
//
// This issue is unique to LinkedHashSet because Set sorts into a predictable sorted order
// and HashSet opts not to implement <, <=, >, or >= due to its unpredictable hash order.

template <typename ValueType>
bool LinkedHashSet<ValueType>::operator <(const LinkedHashSet& set2) const {
    return !equals(set2) && stanfordcpplib::collections::compare(*this, set2) < 0;
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::operator <=(const LinkedHashSet& set2) const {
    return equals(set2) || stanfordcpplib::collections::compare(*this, set2) <= 0;
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::operator >(const LinkedHashSet& set2) const {
    return !equals(set2) && stanfordcpplib::collections::compare(*this, set2) > 0;
}

template <typename ValueType>
bool LinkedHashSet<ValueType>::operator >=(const LinkedHashSet& set2) const {
    return equals(set2) || stanfordcpplib::collections::compare(*this, set2) >= 0;
}

template <typename ValueType>
LinkedHashSet<ValueType> LinkedHashSet<ValueType>::operator +(const LinkedHashSet& set2) const {
    LinkedHashSet<ValueType> set = *this;
    set.addAll(set2);
    return set;
}

template <typename ValueType>
LinkedHashSet<ValueType> LinkedHashSet<ValueType>::operator +(std::initializer_list<ValueType> list) const {
    LinkedHashSet<ValueType> set = *this;
    set.addAll(list);
    return set;
}

template <typename ValueType>
LinkedHashSet<ValueType> LinkedHashSet<ValueType>::operator +(const ValueType& element) const {
    LinkedHashSet<ValueType> set = *this;
    set.add(element);
    return set;
}

template <typename ValueType>
LinkedHashSet<ValueType> LinkedHashSet<ValueType>::operator *(const LinkedHashSet& set2) const {
    LinkedHashSet<ValueType> set = *this;
    return set.retainAll(set2);
}

template <typename ValueType>
LinkedHashSet<ValueType> LinkedHashSet<ValueType>::operator *(std::initializer_list<ValueType> list) const {
    LinkedHashSet<ValueType> set = *this;
    return set.retainAll(list);
}

template <typename ValueType>
LinkedHashSet<ValueType> LinkedHashSet<ValueType>::operator -(const LinkedHashSet& set2) const {
    LinkedHashSet<ValueType> set = *this;
    return set.removeAll(set2);
}

template <typename ValueType>
LinkedHashSet<ValueType> LinkedHashSet<ValueType>::operator -(std::initializer_list<ValueType> list) const {
    LinkedHashSet<ValueType> set = *this;
    return set.removeAll(list);
}

template <typename ValueType>
LinkedHashSet<ValueType> LinkedHashSet<ValueType>::operator -(const ValueType& element) const {
    LinkedHashSet<ValueType> set = *this;
    set.remove(element);
    return set;
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::operator +=(const LinkedHashSet& set2) {
    return addAll(set2);
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::operator +=(std::initializer_list<ValueType> list) {
    return addAll(list);
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::operator +=(const ValueType& value) {
    add(value);
    removeFlag = false;
    return *this;
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::operator *=(const LinkedHashSet& set2) {
    return retainAll(set2);
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::operator *=(std::initializer_list<ValueType> list) {
    return retainAll(list);
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::operator -=(const LinkedHashSet& set2) {
    return removeAll(set2);
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::operator -=(std::initializer_list<ValueType> list) {
    return removeAll(list);
}

template <typename ValueType>
LinkedHashSet<ValueType>& LinkedHashSet<ValueType>::operator -=(const ValueType& value) {
    remove(value);
    removeFlag = true;
    return *this;
}

template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const LinkedHashSet<ValueType>& set) {
    return stanfordcpplib::collections::writeCollection(os, set);
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, LinkedHashSet<ValueType>& set) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, set, element, /* descriptor */ "LinkedHashSet::operator >>");
}

/*
 * Template hash function for hash sets.
 * Requires the element type in the LinkedHashSet to have a hashCode function.
 */
template <typename T>
int hashCode(const LinkedHashSet<T>& set) {
    return stanfordcpplib::collections::hashCodeCollection(set, /* orderMatters */ false);
}

/*
 * Function: randomElement
 * Usage: element = randomElement(set);
 * ------------------------------------
 * Returns a randomly chosen element of the given set.
 * Throws an error if the set is empty.
 */
template <typename T>
const T& randomElement(const LinkedHashSet<T>& set) {
    return stanfordcpplib::collections::randomElement(set);
}

#endif // _linkedhashset_h

/////////////////////// END code extracted from StanfordCPPLib/collections/linkedhashset.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/basicgraph.h ///////////////////////
/*
 * File: basicgraph.h
 * ------------------
 * This file contains the declaration of some useful graph types,
 * specifically the Vertex and Edge structures used in the typical graph.
 * together in lecture.  We also declare BasicGraph, an instantiation of
 * Stanford's Graph class using Vertex and Edge as its type parameters.
 *
 * Most members are implemented in this file, since the class is a template.
 * See BasicGraph.cpp for implementation of some non-template members.
 *
 * @author Marty Stepp
 * @version 2018/11/18
 * - bug fix for getInverseEdge/Arc with null parameter
 * @version 2018/09/07
 * - reformatted doc-style comments
 * @version 2018/03/10
 * - added methods front, back, toMap
 * - added operator << for various collections of Vertex* and Edge*
 * @version 2018/02/28
 * - compiler flag to enable/disable Vertex fields like visited, previous
 * @version 2017/11/14
 * - fix missing "this->" on some methods
 * - added getVertexNames, vertexCount, edgeCount
 * @version 2017/10/24
 * - print nullptr instead of null in uppercase
 * @version 2017/10/18
 * - fix compiler warnings
 * @version 2016/12/09
 * - added iterator version checking support (implicitly via Graph)
 * @version 2016/12/04
 * - bug fix in resetData method (was referring to Vertex* and Edge*)
 * @version 2016/12/01
 * - bug fix in addEdge method (now correctly adds vertexes if not present)
 * - fixed bugs in some node/arc methods (should not crash on empty/null args)
 * @version 2016/11/26
 * - added BasicGraphV, VertexV, EdgeV macros
 * - added getInverseEdgeSet
 * @version 2016/11/19
 * - changed addVertex to not throw when adding duplicates
 * - added operator []
 * @version 2016/11/07
 * - small bug fix for printing cost in operator << (courtesy GitHub @hsivnightbeam)
 * @version 2016/10/14
 * - modified floating-point equality tests to use floatingPointEqual function
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/09/22
 * - bug fix for hashCode function
 * @version 2016/08/12
 * - added initializer_list functionality
 * @version 2014/12/04
 * - bug fix: Edge end reference was not properly pointing at finish field
 * @version 2014/11/21
 * - bug fix: Edge weight reference was not properly pointing at cost field
 * @version 2014/11/13
 * - added iterator begin(), end() support so that students can directly
 *   for-each over the vertices of a graph.
 * - added comparison operators ==, !=, <, etc.
 * - bug fix to Edge to add move/copy = operators
 * @version 2014/10/31
 * - bug fix: extraData was being nulled accidentally in Vertex::resetData()
 * @version 2014/10/23
 * - bug fixes based on cppcheck lint output
 * @version 2014/10/20
 * - converted functions to accept const string& rather than string for speed
 * @version 2014/08/16
 * - added Vertex 'weight' alias for 'cost'
 * - added Edge 'weight' alias for 'cost, and 'end' alias for 'finish'
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _basicgraph_h
#define _basicgraph_h

#include <initializer_list>
#include <sstream>
#include <string>
#include <utility>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * Forward declarations of Vertex/Edge structures so that they can refer
 * to each other mutually.
 * @private
 */
template <typename V = void*, typename E = void*>
class EdgeGen;

/**
 * Canonical Vertex (Node) structure implementation needed by Graph class template.
 * Each Vertex structure represents a single vertex in the graph.
 */
template <typename V = void*, typename E = void*>
class VertexGen : public Observable<int> {
public:
    /**
     * The vertex's name as a string.
     */
    std::string name;

    /**
     * The edges outbound from this vertex to its neighbors.
     */
    Set<EdgeGen<V, E>*> arcs;     // required by Stanford Graph;

    /**
     * The edges outbound from this vertex to its neighbors;
     * an alias of the 'arcs' member.
     */
    Set<EdgeGen<V, E>*>& edges;

#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    /**
     * The cost to reach this vertex; initially 0.
     */
    double cost;

    /**
     * An alias for the 'cost' member.
     */
    double& weight;

    /**
     * Whether this vertex has been visited before; initally false.
     */
    bool visited;

    /**
     * The vertex that comes before this one; initially null.
     */
    VertexGen* previous;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS

    /**
     * The following pointer can point to any extra data needed by the vertex.
     * This field is generally not necessary and can be ignored.
     */
    V data;

    /**
     * @private
     */
    V& extraData;       // alias of data; they are the same field

    /**
     * Constructs a vertex with the given name.
     */
    VertexGen(const std::string& name = "");

    /**
     * Copy constructor.
     */
    VertexGen(const VertexGen& other);

    /**
     * Frees up any memory dynamically allocated by this vertex.
     */
    ~VertexGen();

    /**
     * Returns the color of this vertex, if any.  Initially WHITE.
     */
    /* Color */ int getColor() const;

    /**
     * Wipes the supplementary data of this vertex back to its initial state.
     * Specifically, sets cost to 0, visited to false, and previous to nullptr.
     */
    void resetData();

    /**
     * Sets the color of this vertex to be the given color.
     * The color must be one of WHITE, GRAY, YELLOW, or GREEN.
     * Future calls to getColor will return the color you pass here.
     */
    void setColor(/* Color */ int c);

    /**
     * Returns a string representation of this vertex for debugging, such as
     * "Vertex{name=r13c42, cost=11, visited=true, previous=r12c41, neighbors={r12c41, r12c43}}".
     */
    std::string toString() const;

    /**
     * Copy assignment operator.
     */
    VertexGen& operator =(const VertexGen& other);

    /**
     * Move assignment operator.
     */
    VertexGen& operator =(VertexGen&& other);

private:
    /* Color */ int m_color;   // vertex's color as passed to setColor
};

/**
 * Makes a vertex printable to an output stream.
 * See toString for an example of the output format.
 * Note that printing a vertex is not the same as printing a vertex pointer.
 * If you try to print a pointer, you will just see its address in hex.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const VertexGen<V, E>& v);

/**
 * Canonical Edge (Arc) structure implementation needed by Graph class template.
 * Each Edge structure represents a single edge in the graph.
 */
template <typename V, typename E>
class EdgeGen {
public:
    /**
     * The edge's starting vertex.
     */
    VertexGen<V, E>* start;

    /**
     * The edge's ending vertex.
     */
    VertexGen<V, E>* finish;   // required by Stanford Graph;

    /**
     * An alias of finish; they are the same field.
     */
    VertexGen<V, E>*& end;

    /**
     * The edge's weight; default 0.
     */
    double cost;

    /**
     * An alias for the 'cost' member.
     */
    double& weight;

#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    /**
     * Whether this edge has been visited before; initally false.
     */
    bool visited;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS

    /**
     * A pointer that can point to any extra data needed by the vertex.
     * This field is generally not necessary and can be ignored.
     */
    void* data;

    /**
     * An alias for the 'data' member.
     */
    void*& extraData;

    /**
     * Constructs a new edge between the given start/end vertices with
     * the given cost.
     */
    EdgeGen(VertexGen<V, E>* start = nullptr, VertexGen<V, E>* finish = nullptr, double cost = 0.0);

    /**
     * Frees up any memory dynamically allocated by this edge.
     */
    ~EdgeGen();

    /**
     * Wipes the supplementary data of this edge back to its initial state.
     */
    void resetData();

    /**
     * Returns a string representation of this edge for debugging, such as
     * "Arc{start=r12c42, finish=r12c41, cost=0.75}".
     */
    std::string toString() const;

    /**
     * Copy assignment operator.
     */
    EdgeGen& operator =(const EdgeGen& other);

    /**
     * Move assignment operator.
     */
    EdgeGen& operator =(EdgeGen&& other);
};

/**
 * Makes an edge printable to an output stream.
 * See toString for an example of the output format.
 * Note that printing an edge is not the same as printing an edge pointer.
 * If you try to print a pointer, you will just see its address in hex.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const EdgeGen<V, E>& edge);


/**
 * BasicGraph is just basically an instantiation of Graph using Vertex and Edge
 * as its template parameters.  It also adds a few convenience functions such
 * as mirroring members like "addArc" with an equivalent more familiar name
 * like "addEdge".
 *
 * There are a few convenience functions related to neighbors, like isNeighbor.
 * BasicGraph contains a DFS implementation called isReachable, not found
 * in the normal Stanford Graph class.
 *
 * There are also a few functions added to make edges more convenient to work with:
 * getEdge(v1, v2) to get the edge between a given pair of vertices,
 * and getInverseEdge(edge) to get the edge v2 -> v1 for a given edge v1 -> v2.
 */
template <typename V = void*, typename E = void*>
class BasicGraphGen : public Graph<VertexGen<V, E>, EdgeGen<V, E> > {
public:
    /**
     * Constructs a new empty graph.
     * @bigoh O(1)
     */
    BasicGraphGen();

    /**
     * Constructs a new graph containing the given vertexes.
     * @bigoh O(V)
     */
    BasicGraphGen(std::initializer_list<std::string> vertexList);

    /**
     * Adds a directed edge to the graph from vertex v1 to vertex v2.
     * Note that it is allowed to have multiple edges between the same pair of vertexes.
     *
     * Returns a pointer to the edge, though clients need not store that pointer;
     * you can get the pointer again later by calling getEdge and passing the two vertexes.
     *
     * Equivalent to addNode.
     *
     * @return a pointer to the edge created
     * @bigoh O(log V + log E)
     */
    EdgeGen<V, E>* addEdge(const std::string& v1, const std::string& v2, double cost = 0.0, bool directed = true);

    /**
     * Adds a directed edge to the graph from vertex v1 to vertex v2.
     * If either vertex is not found in the graph, said vertex will be added to the graph.
     * Note that it is allowed to have multiple edges between the same pair of vertexes.
     *
     * Returns a pointer to the edge, though clients need not store that pointer;
     * you can get the pointer again later by calling getEdge and passing the two vertexes.
     *
     * Equivalent to addNode.
     *
     * @return a pointer to the edge created
     * @throw ErrorException if either vertex is null
     * @bigoh O(log V + log E)
     */
    EdgeGen<V, E>* addEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2, double cost = 0.0, bool directed = true);

    /**
     * Adds the given directed edge to the graph from vertex v1 to vertex v2.
     * If either vertex is not found in the graph, said vertex will be added to the graph.
     * Note that it is allowed to have multiple edges between the same pair of vertexes.
     *
     * Returns a pointer to the edge, though clients need not store that pointer;
     * you can get the pointer again later by calling getEdge and passing the two vertexes.
     *
     * Equivalent to addNode.
     *
     * @return a pointer to the edge created
     * @throw ErrorException if either vertex is null
     * @bigoh O(log V + log E)
     */
    EdgeGen<V, E>* addEdge(EdgeGen<V, E>* e, bool directed = true);

    /**
     * Adds a vertex to the graph, if no vertex with that name already exists in the graph.
     * This version of this method accepts a string for the vertex's name,
     * creates a new vertex of the appropriate type and initializes its fields.
     * Returns a pointer to the vertex, though clients need not store that pointer;
     * you can get the pointer again later by calling getVertex and passing the same name.
     *
     * The vertexes in a graph must have unique names.
     * If this graph already contains a vertex with the given name,
     * the vertex will not be added and the graph's state will not change.
     *
     * Equivalent to addNode.
     *
     * @return a pointer to the vertex created
     * @bigoh O(log V)
     */
    VertexGen<V, E>* addVertex(const std::string& name);

    /**
     * Adds a vertex to the graph, if no vertex with that name already exists in the graph.
     * This version of this method accepts a string for the vertex's name,
     * creates a new vertex of the appropriate type and initializes its fields.
     * The other accepts a structure representing the vertex and its data.
     * Returns a pointer to the vertex, though clients need not store that pointer;
     * you can get the pointer again later by calling getVertex and passing the same name.
     *
     * The vertexes in a graph must have unique names.
     * If this graph already contains a vertex with the given name,
     * the vertex will not be added and the graph's state will not change.
     *
     * When calling this function, you are relinquishing ownership of the Vertex
     * structure's lifecycle to the graph; our graph will free it when done with it.
     *
     * Equivalent to addNode.
     *
     * @return a pointer to the vertex created
     * @throws ErrorException if vertex is null
     * @bigoh O(log V)
     */
    VertexGen<V, E>* addVertex(VertexGen<V, E>* v);

    /**
     * Removes all edges from the graph.
     * Frees any edge objects that were internally allocated as heap storage.
     *
     * Equivalent to clearArcs.
     * @bigoh O(E log E)
     */
    void clearEdges();

    /**
     * Removes all outbound edges of the given vertex from the graph.
     * The vertex itself is not removed.
     * If the vertex is null or is not found in the graph, has no effect.
     *
     * Equivalent to clearArcs.
     * @bigoh O(E log E)
     * @bigoh O(log V + E)
     */
    void clearEdges(VertexGen<V, E>* v);

    /**
     * Removes all outbound edges of the given vertex from the graph.
     * The vertex itself is not removed.
     * If the vertex is not found in the graph, has no effect.
     *
     * Equivalent to clearArcs.
     * @bigoh O(E log E)
     */
    void clearEdges(const std::string& v);

    /**
     * Returns true if the graph has an edge from v1 to v2 in the graph.
     * If either of the vertexes supplied is null or is not found in the graph, returns false.
     *
     * Equivalent to containsArc.
     * @bigoh O(log E)
     */
    bool containsEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2) const;

    /**
     * Returns true if the graph has an edge from v1 to v2 in the graph.
     * If either of the vertexes supplied is not found in the graph, returns false.
     *
     * Equivalent to containsArc.
     * @bigoh O(log E)
     */
    bool containsEdge(const std::string& v1, const std::string& v2) const;

    /**
     * Returns true if the graph contains the given edge.
     * If the edge structure is null, returns false.
     *
     * Equivalent to containsArc.
     * @bigoh O(log E)
     */
    bool containsEdge(EdgeGen<V, E>* edge) const;

    /**
     * Returns whether the graph contains a vertex with the given name.
     *
     * Equivalent to containsNode.
     * @bigoh O(log V)
     */
    bool containsVertex(const std::string& name) const;

    /**
     * Returns whether the graph contains the given vertex.
     * If a null pointer is passed, returns false.
     *
     * Equivalent to containsNode.
     * @bigoh O(log V)
     */
    bool containsVertex(VertexGen<V, E>* v) const;

    /**
     * Returns the number of edges in the graph.
     *
     * Equivalent to arcCount.
     * @bigoh O(log V)
     */
    int edgeCount() const;

    /**
     * Returns the structure representing the edge from v1 to v2 in the graph.
     * If either of the vertexes supplied is null or is not found in the graph, the function will return nullptr.
     * If there are multiple edges between the given pair of vertexes, which of the edges will be returned is unspecified.
     *
     * Equivalent to getArc.
     *
     * @param v1 start vertex
     * @param v2 end vertex
     * @return edge from v1 to v2, or nullptr if there is no such edge
     * @bigoh O(log V + log E)
     */
    EdgeGen<V, E>* getEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2) const;

    /**
     * Returns the structure representing the edge from v1 to v2 in the graph.
     * If either of the vertexes supplied is not found in the graph, the function will return nullptr.
     * If there are multiple edges between the given pair of vertexes, which of the edges will be returned is unspecified.
     *
     * Equivalent to getArc.
     *
     * @param v1 start vertex
     * @param v2 end vertex
     * @return edge from v1 to v2, or nullptr if there is no such edge
     * @bigoh O(log V + log E)
     */
    EdgeGen<V, E>* getEdge(const std::string& v1, const std::string& v2) const;

    /**
     * Returns the set of all edges in the graph.
     *
     * Equivalent to getArcSet.
     * @bigoh O(1)
     */
    const Set<EdgeGen<V, E>*>& getEdgeSet() const;

    /**
     * Returns the set of all edges that start at the specified vertex.
     * If the vertex supplied is null or is not found in the graph,
     * the function will return an empty set.
     *
     * Equivalent to getArcSet.
     * @bigoh O(1)
     */
    const Set<EdgeGen<V, E>*>& getEdgeSet(VertexGen<V, E>* v) const;

    /**
     * Returns the set of all edges that start at the specified vertex.
     * If the vertex supplied is not found in the graph,
     * the function will return an empty set.
     *
     * Equivalent to getArcSet.
     * @bigoh O(1)
     */
    const Set<EdgeGen<V, E>*>& getEdgeSet(const std::string& v) const;

    /**
     * Returns the edge that is the opposite of the given edge;
     * that is, if the specified edge e starts at v1 and ends at v2,
     * will return the edge that starts at v2 and ends at v1,
     * if such an edge exists in the graph.
     *
     * If the edge supplied is nullptr, is not found in the graph,
     * or has no inverse, the function will return nullptr.
     *
     * If there are multiple edges between the given pair of vertexes,
     * which of the edges will be returned is unspecified.
     *
     * Equivalent to getInverseEdge.
     * @bigoh O(E)
     */
    EdgeGen<V, E>* getInverseArc(EdgeGen<V, E>* edge) const;

    /**
     * Returns the edge that is the opposite of the given edge;
     * that is, if the specified edge e starts at v1 and ends at v2,
     * will return the edge that starts at v2 and ends at v1,
     * if such an edge exists in the graph.
     *
     * If the edge supplied is nullptr, is not found in the graph,
     * or has no inverse, the function will return nullptr.
     *
     * If there are multiple edges between the given pair of vertexes,
     * which of the edges will be returned is unspecified.
     *
     * Equivalent to getInverseArc.
     * @bigoh O(E)
     */
    EdgeGen<V, E>* getInverseEdge(EdgeGen<V, E>* edge) const;

    /**
     * Returns the set of all edges in the graph that end at the specified vertex.
     * If the vertex supplied is null or is not found in the graph,
     * the function will return an empty set.
     *
     * Equivalent to getInverseArcSet.
     * @bigoh O(E)
     */
    const Set<EdgeGen<V, E>*> getInverseEdgeSet(VertexGen<V, E>* v) const;

    /**
     * Returns the set of all edges in the graph that end at the specified vertex.
     * If the vertex supplied is null or is not found in the graph,
     * the function will return an empty set.
     *
     * Equivalent to getInverseArcSet.
     * @bigoh O(E)
     */
    const Set<EdgeGen<V, E>*> getInverseEdgeSet(const std::string& v) const;

    /**
     * Looks up a vertex in the graph by name and returns a pointer to
     * its internal data structure.
     * If no vertex with the specified name exists, returns nullptr.
     * @bigoh O(log V)
     */
    VertexGen<V, E>* getVertex(const std::string& name) const;

    /**
     * Returns a set of the names of all vertexes in the graph.
     * The vertexes will be sorted by name in case-sensitive alphabetical order.
     * @bigoh O(V log V)
     */
    Set<std::string> getVertexNames() const;

    /**
     * Returns the set of all vertexes in the graph.
     * The vertexes will be sorted by name in case-sensitive alphabetical order.
     * @bigoh O(V log V)
     */
    const Set<VertexGen<V, E>*>& getVertexSet() const;

    /**
     * Removes the edge from v1 to v2 from the graph.
     * If more than one edge connects the specified endpoints, all of them are removed.
     * If either of the vertexes supplied is not found in the graph,
     * calling this function will have no effect on the graph.
     * @bigoh O(E + log V)
     */
    void removeEdge(const std::string& v1, const std::string& v2, bool directed = true);

    /**
     * Removes the edge from v1 to v2 from the graph.
     * If more than one edge connects the specified endpoints, all of them are removed.
     * If either of the vertexes supplied is null or not found in the graph,
     * calling this function will have no effect on the graph.
     * @bigoh O(E + log V)
     */
    void removeEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2, bool directed = true);

    /**
     * Removes the given edge from the graph.
     * If the edge supplied is not found in the graph,
     * calling this function will have no effect on the graph.
     * @bigoh O(log E + log V)
     */
    void removeEdge(EdgeGen<V, E>* e, bool directed = true);

    /**
     * Removes the given vertex from the graph.
     * If the vertex is not found in the graph, the call has no effect.
     * @bigoh O(E + log V)
     */
    void removeVertex(const std::string& name);

    /**
     * Removes the given vertex from the graph.
     * If the vertex is null or is not found in the graph, the call has no effect.
     * @bigoh O(E + log V)
     */
    void removeVertex(VertexGen<V, E>* v);

    /**
     * Sets the data stored in each vertex and edge back to its original value
     * by calling resetData on every vertex and edge.
     * @private
     * @bigoh O(V + E)
     */
    void resetData();

    /**
     * Sets whether the resetData method is enabled (default true).
     * @private
     * @bigoh O(1)
     */
    void setResetEnabled(bool enabled);

    /* @inherit */
    virtual void scanArcData(TokenScanner& scanner, EdgeGen<V, E>* edge, EdgeGen<V, E>* inverse);

    /* @inherit */
    virtual void writeArcData(std::ostream& out, EdgeGen<V, E>* edge) const;

    /**
     * Returns a Map representing an adjacency list equivalent to this graph.
     * Each vertex's name is a key in the map, and its neighboring vertexes' names
     * are stored in a Set as the value associated with that key.
     * It should be noted that this member does not preserve the weights of the edges
     * between the neighboring vertexes, so it is not ideal for use with weighted graphs.
     * @bigoh O(V + E)
     */
    Map<std::string, Set<std::string>> toMap() const;

    /**
     * Returns the number of vertexes in the graph.
     * Equivalent to size.
     * @bigoh O(1)
     */
    int vertexCount() const;

    /**
     * Overloads <code>[]</code> to return vertex pointers by vertex name.
     * @bigoh O(log V)
     */
    VertexGen<V, E>* operator [](const std::string& name);

    /**
     * Overloads <code>[]</code> to return vertex pointers by vertex name.
     * @bigoh O(log V)
     */
    const VertexGen<V, E>* operator [](const std::string& name) const;

private:
    bool m_resetEnabled;
};

/**
 * Hash function for BasicGraphGen.
 */
template <typename V, typename E>
int hashCode(const BasicGraphGen<V, E>& graph);

/*
 * Defines a Vertex to be a VertexGen with its data bound to be a void*.
 * Retained for backward compatibility.
 */
typedef VertexGen<void*, void*> Vertex;
#define VertexV VertexGen

/*
 * You can refer to a Vertex as a Node if you prefer.
 */
#define Node Vertex

/*
 * Defines an Edge to be an EdgeGen with its data bound to be a void*.
 * Retained for backward compatibility.
 */
typedef EdgeGen<void*, void*> Edge;
#define EdgeV EdgeGen

/*
 * You can refer to an Edge as an Arc if you prefer.
 */
#define Arc Edge

/*
 * Defines a BasicGraph to be a BasicGraphGen with its data bound to be a void*.
 * Retained for backward compatibility.
 */
typedef BasicGraphGen<void*, void*> BasicGraph;
#define BasicGraphV BasicGraphGen

/**
 * Hash function for BasicGraph.
 */
int hashCode(const BasicGraph& graph);


/*
 * Vertex member implementations
 */
template <typename V, typename E>
VertexGen<V, E>::VertexGen(const std::string& theName)
        : name(theName),
          edges(arcs),
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
          weight(cost),
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
          data(V()),
          extraData(data) {
    resetData();
}

template <typename V, typename E>
VertexGen<V, E>::VertexGen(const VertexGen& other)
    : name(other.name),
      arcs(other.arcs),
      edges(arcs),
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
      cost(other.cost),
      weight(cost),
      visited(other.visited),
      previous(other.previous),
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
      data(other.data),
      extraData(data),
      m_color(other.m_color) {
    // empty
}

template <typename V, typename E>
VertexGen<V, E>::~VertexGen() {
    // empty
}

template <typename V, typename E>
int VertexGen<V, E>::getColor() const {
    return m_color;
}

template <typename V, typename E>
void VertexGen<V, E>::resetData() {
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    cost = 0.0;
    previous = nullptr;
    visited = false;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    m_color = /* UNCOLORED */ 0;
}

template <typename V, typename E>
void VertexGen<V, E>::setColor(int c) {
    m_color = c;
    notifyObservers();
}

template <typename V, typename E>
std::string VertexGen<V, E>::toString() const {
    std::ostringstream out;
    out << *this;
    return out.str();
}

template <typename V, typename E>
VertexGen<V, E>& VertexGen<V, E>::operator =(const VertexGen& other) {
    if (this != &other) {
        name = other.name;
        arcs = other.arcs;
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
        cost = other.cost;
        visited = other.visited;
        previous = other.previous;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
        data = other.data;
        m_color = other.m_color;
    }
    return *this;
}

template <typename V, typename E>
VertexGen<V, E>& VertexGen<V, E>::operator =(VertexGen&& other) {
    if (this != &other) {
        name = other.name;
        arcs = other.arcs;
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
        cost = other.cost;
        visited = other.visited;
        previous = other.previous;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
        data = other.data;
        m_color = other.m_color;
    }
    return *this;
}

template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const VertexGen<V, E>& v) {
    out << "Vertex{name=" << v.name;

#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    if (!floatingPointEqual(v.cost, 0.0)) {
        out << ", cost=" << v.cost;
    }
    out << ", visited=" << (v.visited ? "true" : "false");
    out << ", previous=" << (v.previous == nullptr ? std::string("nullptr") : v.previous->name);
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS

    // print neighbors
    out << ", neighbors={";
    int i = 0;
    for (EdgeGen<V, E>* edge : v.edges) {
        if (i > 0) {
            out << ", ";
        }
        i++;
        if (edge->finish) {
            out << edge->finish->name;
        } else {
            out << "nullptr";
        }
    }
    out << "}";   // end of neighbors

    out << "}";   // end of Vertex
    return out;
}


/*
 * Edge member implementations
 */
template <typename V, typename E>
EdgeGen<V, E>::EdgeGen(VertexGen<V, E>* theStart, VertexGen<V, E>* theFinish, double theCost)
        : start(theStart),
          finish(theFinish),
          end(this->finish),
          cost(theCost),
          weight(this->cost),
          data(nullptr),
          extraData(data) {
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    this->extraData = nullptr;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    this->resetData();
}

template <typename V, typename E>
EdgeGen<V, E>::~EdgeGen() {
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    if (this->extraData != nullptr) {
        this->extraData = nullptr;
        // delete this->extraData;
    }
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
}

template <typename V, typename E>
void EdgeGen<V, E>::resetData() {
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    this->visited = false;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
}

template <typename V, typename E>
std::string EdgeGen<V, E>::toString() const {
    std::ostringstream out;
    out << *this;
    return out.str();
}

template <typename V, typename E>
EdgeGen<V, E>& EdgeGen<V, E>::operator =(const EdgeGen& other) {
    if (this != &other) {
        start = other.start;
        finish = other.finish;
        cost = other.cost;
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
        visited = other.visited;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    }
    return *this;
}

template <typename V, typename E>
EdgeGen<V, E>& EdgeGen<V, E>::operator =(EdgeGen&& other) {
    start = other.start;
    finish = other.finish;
    cost = other.cost;
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    visited = other.visited;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    return *this;
}

/**
 * Writes the given edge structure to the given output stream.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const EdgeGen<V, E>& edge) {
    out << "Edge{start=";
    if (!edge.start) {
        out << "nullptr";
    } else {
        out << edge.start->name;
    }
    out << ", finish=";
    if (!edge.finish) {
        out << "nullptr";
    } else {
        out << edge.finish->name;
    }
    if (!floatingPointEqual(edge.cost, 0.0)) {
        out << ", cost=" << edge.cost;
    }
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    if (edge.visited) {
        out << ", visited=" << (edge.visited ? "true" : "false");
    }
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    out << "}";
    return out;
}


/*
 * BasicGraph member implementations
 */
template <typename V, typename E>
BasicGraphGen<V, E>::BasicGraphGen() : Graph<VertexGen<V, E>, EdgeGen<V, E> >() {
    m_resetEnabled = true;
}

template <typename V, typename E>
BasicGraphGen<V, E>::BasicGraphGen(std::initializer_list<std::string> vertexList)
        : Graph<VertexGen<V, E>, EdgeGen<V, E> >() {
    m_resetEnabled = true;
    for (const std::string& vertexName : vertexList) {
        this->addVertex(vertexName);
    }
}

template <typename V, typename E>
void BasicGraphGen<V, E>::clearEdges() {
    this->clearArcs();
}

template <typename V, typename E>
void BasicGraphGen<V, E>::clearEdges(VertexGen<V, E>* v) {
    this->clearArcs(v);
}

template <typename V, typename E>
void BasicGraphGen<V, E>::clearEdges(const std::string& v) {
    this->clearArcs(v);
}

template <typename V, typename E>
bool BasicGraphGen<V, E>::containsEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2) const {
    return this->containsArc(v1, v2);
}

template <typename V, typename E>
bool BasicGraphGen<V, E>::containsEdge(const std::string& v1, const std::string& v2) const {
    return this->containsArc(v1, v2);
}

template <typename V, typename E>
bool BasicGraphGen<V, E>::containsEdge(EdgeGen<V, E>* edge) const {
    return this->containsArc(edge);
}

template <typename V, typename E>
bool BasicGraphGen<V, E>::containsVertex(const std::string& name) const {
    return this->containsNode(name);
}

template <typename V, typename E>
bool BasicGraphGen<V, E>::containsVertex(VertexGen<V, E>* v) const {
    return this->containsNode(v);
}

template <typename V, typename E>
int BasicGraphGen<V, E>::edgeCount() const {
    return this->arcCount();
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::getEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2) const {
    return this->getArc(v1, v2);
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::getEdge(const std::string& v1, const std::string& v2) const {
    return this->getArc(v1, v2);
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::getInverseArc(EdgeGen<V, E>* edge) const {
    return (edge) ? this->getArc(edge->finish, edge->start) : nullptr;
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::getInverseEdge(EdgeGen<V, E>* edge) const {
    return this->getInverseArc(edge);
}

template <typename V, typename E>
void BasicGraphGen<V, E>::resetData() {
    if (m_resetEnabled) {
        for (VertexGen<V, E>* v : this->getVertexSet()) {
            v->resetData();
        }
        for (EdgeGen<V, E>* e : this->getEdgeSet()) {
            e->resetData();
        }
    }
}

template <typename V, typename E>
void BasicGraphGen<V, E>::setResetEnabled(bool enabled) {
    m_resetEnabled = enabled;
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::addEdge(const std::string& v1, const std::string& v2, double cost, bool directed) {
    if (!this->containsVertex(v1)) {
        this->addVertex(v1);
    }
    if (!this->containsVertex(v2)) {
        this->addVertex(v2);
    }
    return this->addEdge(this->getVertex(v1), this->getVertex(v2), cost, directed);
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::addEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2, double cost, bool directed) {
    EdgeGen<V, E>* e = new EdgeGen<V, E>(v1, v2, cost);
    return this->addEdge(e, directed);
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::addEdge(EdgeGen<V, E>* e, bool directed) {
    EdgeGen<V, E>* result = this->addArc(e);
    if (!directed) {
        EdgeGen<V, E>* result2 = this->addArc(e->finish, e->start);
        result2->cost = e->cost;
    }
    return result;
}

template <typename V, typename E>
VertexGen<V, E>* BasicGraphGen<V, E>::addVertex(const std::string& name) {
    return this->addNode(name);
}

template <typename V, typename E>
VertexGen<V, E>* BasicGraphGen<V, E>::addVertex(VertexGen<V, E>* v) {
    return this->addNode(v);
}

template <typename V, typename E>
const Set<EdgeGen<V, E>*>& BasicGraphGen<V, E>::getEdgeSet() const {
    return this->getArcSet();
}

template <typename V, typename E>
const Set<EdgeGen<V, E>*>& BasicGraphGen<V, E>::getEdgeSet(VertexGen<V, E>* v) const {
    return this->getArcSet(v);
}

template <typename V, typename E>
const Set<EdgeGen<V, E>*>& BasicGraphGen<V, E>::getEdgeSet(const std::string& v) const {
    return this->getArcSet(v);
}

template <typename V, typename E>
const Set<EdgeGen<V, E>*> BasicGraphGen<V, E>::getInverseEdgeSet(VertexGen<V, E>* v) const {
    return this->getInverseArcSet(v);
}

template <typename V, typename E>
const Set<EdgeGen<V, E>*> BasicGraphGen<V, E>::getInverseEdgeSet(const std::string& v) const {
    return this->getInverseArcSet(v);
}


template <typename V, typename E>
VertexGen<V, E>* BasicGraphGen<V, E>::getVertex(const std::string& name) const {
    return this->getNode(name);
}

template <typename V, typename E>
Set<std::string> BasicGraphGen<V, E>::getVertexNames() const {
    return this->getNodeNames();
}


template <typename V, typename E>
const Set<VertexGen<V, E>*>& BasicGraphGen<V, E>::getVertexSet() const {
    return this->getNodeSet();
}

template <typename V, typename E>
void BasicGraphGen<V, E>::removeEdge(const std::string& v1, const std::string& v2, bool directed) {
    this->removeEdge(this->getVertex(v1), this->getVertex(v2), directed);
}

template <typename V, typename E>
void BasicGraphGen<V, E>::removeEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2, bool directed) {
    this->removeArc(v1, v2);
    if (!directed) {
        this->removeArc(v2, v1);
    }
}

template <typename V, typename E>
void BasicGraphGen<V, E>::removeEdge(EdgeGen<V, E>* e, bool directed) {
    this->removeArc(e);
    if (!directed) {
        this->removeArc(e->finish, e->start);
    }
}

template <typename V, typename E>
void BasicGraphGen<V, E>::removeVertex(const std::string& name) {
    this->removeNode(name);
}

template <typename V, typename E>
void BasicGraphGen<V, E>::removeVertex(VertexGen<V, E>* v) {
    this->removeNode(v);
}

template <typename V, typename E>
Map<std::string, Set<std::string>> BasicGraphGen<V, E>::toMap() const {
    Map<std::string, Set<std::string>> result;
    for (Vertex* v : this->getVertexSet()) {
        Set<std::string> neighborSet;
        for (Vertex* neighbor : this->getNeighbors(v)) {
            neighborSet += neighbor->name;
        }
        result[v->name] = neighborSet;
    }
    return result;
}

template <typename V, typename E>
int BasicGraphGen<V, E>::vertexCount() const {
    return this->nodeCount();
}

template <typename V, typename E>
VertexGen<V, E>* BasicGraphGen<V, E>::operator [](const std::string& name) {
    return this->getVertex(name);
}

template <typename V, typename E>
const VertexGen<V, E>* BasicGraphGen<V, E>::operator [](const std::string& name) const {
    return this->getVertex(name);
}

template <typename V, typename E>
void BasicGraphGen<V, E>::scanArcData(TokenScanner& scanner, EdgeGen<V, E>* edge, EdgeGen<V, E>* inverse) {
    std::string colon = scanner.nextToken();   // ":", skip over
    if (colon == ":") {
        std::string costStr = scanner.nextToken();
        edge->cost = stringToReal(costStr);
        if (inverse) {
            inverse->cost = edge->cost;
        }
    } else {
        // no cost for this edge (cost 0); un-read the colon token because
        // it probably wasn't actually a colon
        scanner.saveToken(colon);
    }
}

template <typename V, typename E>
void BasicGraphGen<V, E>::writeArcData(std::ostream& out, EdgeGen<V, E>* edge) const {
    if (!floatingPointEqual(edge->cost, 0.0)) {
        out << " : ";
        out << edge->cost;
    }
}

/**
 * Template hash function for graphs.
 */
template <typename V, typename E>
int hashCode(const BasicGraphGen<V, E>& graph) {
    int code = hashSeed();
    for (VertexGen<V, E>* v : graph) {
        code = hashMultiplier() * code + hashCode(v->name);
    }
    for (EdgeGen<V, E>* e : graph.getEdgeSet()) {
        code = hashMultiplier() * code + hashCode(e->start->name);
        code = hashMultiplier() * code + hashCode(e->finish->name);
    }
    return (code & hashMask());
}

/**
 * Overloaded operator to print a set of edge pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const HashSet<EdgeGen<V, E>*>& sete) {
    out << "{";
    if (!sete.isEmpty()) {
        bool first = true;
        for (EdgeGen<V, E>* e : sete) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (e) {
                if (e->start) {
                    out << e->start->name;
                } else {
                    out << "null";
                }
                out << " -> ";
                if (e->finish) {
                    out << e->finish->name;
                } else {
                    out << "null";
                }
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a set of vertex pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const HashSet<VertexGen<V, E>*>& setv) {
    out << "{";
    if (!setv.isEmpty()) {
        bool first = true;
        for (VertexGen<V, E>* v : setv) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (v) {
                out << v->name;
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a list of edge pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const LinkedList<EdgeGen<V, E>*>& liste) {
    out << "{";
    if (!liste.isEmpty()) {
        bool first = true;
        for (EdgeGen<V, E>* e : liste) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (e) {
                if (e->start) {
                    out << e->start->name;
                } else {
                    out << "null";
                }
                out << " -> ";
                if (e->finish) {
                    out << e->finish->name;
                } else {
                    out << "null";
                }
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a list of vertex pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const LinkedList<VertexGen<V, E>*>& lst) {
    out << "{";
    if (!lst.isEmpty()) {
        bool first = true;
        for (VertexGen<V, E>* v : lst) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (v) {
                out << v->name;
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a set of edge pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const Set<EdgeGen<V, E>*>& sete) {
    out << "{";
    if (!sete.isEmpty()) {
        bool first = true;
        for (EdgeGen<V, E>* e : sete) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (e) {
                if (e->start) {
                    out << e->start->name;
                } else {
                    out << "null";
                }
                out << " -> ";
                if (e->finish) {
                    out << e->finish->name;
                } else {
                    out << "null";
                }
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a set of vertex pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const Set<VertexGen<V, E>*>& setv) {
    out << "{";
    if (!setv.isEmpty()) {
        bool first = true;
        for (VertexGen<V, E>* v : setv) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (v) {
                out << v->name;
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a vector of edge pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const Vector<EdgeGen<V, E>*>& vece) {
    out << "{";
    if (!vece.isEmpty()) {
        bool first = true;
        for (EdgeGen<V, E>* e : vece) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (e) {
                if (e->start) {
                    out << e->start->name;
                } else {
                    out << "null";
                }
                out << " -> ";
                if (e->finish) {
                    out << e->finish->name;
                } else {
                    out << "null";
                }
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a vector of vertex pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const Vector<VertexGen<V, E>*>& vec) {
    out << "{";
    if (!vec.isEmpty()) {
        bool first = true;
        for (VertexGen<V, E>* v : vec) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (v) {
                out << v->name;
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

#endif // _basicgraph_h

/////////////////////// END code extracted from StanfordCPPLib/collections/basicgraph.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/stl.h ///////////////////////
/*
 * File: stl.h
 * -----------
 * Contains utility functions related to the STL collections.
 *
 * @author Marty Stepp
 * @version 2018/10/19
 * - added toStl* methods (moved here from being members of our collections)
 *   This is to avoid a default include of STL containers in student code.
 * @version 2016/10/22
 * - added toString
 * @version 2016/09/22
 * - initial version
 * @since 2016/09/22
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _stl_h
#define _stl_h

#include <initializer_list>
#include <iostream>
#include <iterator>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <vector>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

// STL containers:
// array, vector, deque, forward_list, ist, stack, queue, priority_queue,
// set, multiset, map, multimap, unordered_*, bitset, valarray

/**
 * Writes the given list of values to the given output stream
 * in a "{10, 20, 30}" format.
 */
template <typename T>
std::ostream& operator <<(std::ostream& out, const std::initializer_list<T>& list) {
    return stanfordcpplib::collections::writeCollection(out, list);
}

/**
 * Writes the given vector of values to the given output stream
 * in a "{10, 20, 30}" format.
 */
template <typename T>
std::ostream& operator <<(std::ostream& out, const std::vector<T>& vec) {
    return stanfordcpplib::collections::writeCollection(out, vec);
}

/**
 * Returns an STL queue object with the same elements as this Queue.
 */
template <typename ValueType>
std::deque<ValueType> toStlDeque(const Queue<ValueType>& q) {
    Queue<ValueType> copy = q;
    std::deque<ValueType> result;
    while (!copy.isEmpty()) {
        result.push_back(copy.dequeue());
    }
    return result;
}

/**
 * Returns an STL list object with the same elements as this LinkedList.
 */
template <typename ValueType>
std::list<ValueType> toStlList(const LinkedList<ValueType>& l) {
    std::list<ValueType> result;
    for (const ValueType& value : l) {
        result.push_back(value);
    }
    return result;
}

/**
 * Returns an STL map object with the same elements as this map.
 */
template <typename KeyType, typename ValueType>
std::map<KeyType, ValueType> toStlMap(const Map<KeyType, ValueType>& m) {
    std::map<KeyType, ValueType> result;
    for (const KeyType& key : m) {
        result[key] = m[key];
    }
    return result;
}

/**
 * Returns an STL queue object with the same elements as this Queue.
 */
template <typename ValueType>
std::queue<ValueType> toStlQueue(const Queue<ValueType>& q) {
    Queue<ValueType> copy = q;
    std::queue<ValueType> result;
    while (!copy.isEmpty()) {
        result.push_back(copy.dequeue());
    }
    return result;
}

/**
 * Returns an STL set object with the same elements as this DawgLexicon.
 */
std::set<std::string> toStlSet(const DawgLexicon& lex);

/**
 * Returns an STL set object with the same elements as this Lexicon.
 */
std::set<std::string> toStlSet(const Lexicon& lex);

/**
 * Returns an STL set object with the same elements as this Set.
 */
template <typename ValueType>
std::set<ValueType> toStlSet(const Set<ValueType>& s) {
    std::set<ValueType> result;
    for (ValueType& value : s) {
        result.insert(value);
    }
    return result;
}

/**
 * Returns an STL stack object with the same elements as this Stack.
 */
template <typename ValueType>
std::stack<ValueType> toStlStack(const Stack<ValueType>& s) {
    Stack<ValueType> copy = s;
    std::stack<ValueType> result;
    while (!copy.isEmpty()) {
        result.push(copy.pop());
    }
    return result;
}

/**
 * Returns an STL vector object with the same elements as this Vector.
 */
template <typename ValueType>
std::vector<ValueType> toStlVector(const Vector<ValueType>& v) {
    std::vector<ValueType> result;
    for (int i = 0; i < v.size(); i++) {
        result.push_back(v[i]);
    }
    return result;
}

/**
 * Converts the given list of values to a string such as "{1, 2, 3}".
 */
template <typename T>
std::string toString(const std::initializer_list<T>& list) {
    std::ostringstream out;
    out << list;
    return out.str();
}

/**
 * Converts the given vector of values to a string such as "{1, 2, 3}".
 */
template <typename T>
std::string toString(const std::vector<T>& vec) {
    std::ostringstream out;
    out << vec;
    return out.str();
}

#endif // _stl_h

/////////////////////// END code extracted from StanfordCPPLib/collections/stl.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/graphics/consoletext.h ///////////////////////
/*
 * File: consoletext.h
 * -------------------
 * This file provides a way to use the functions from console.h
 * without mandating the use of the Stanford C++ library's
 * graphical console window.
 * 
 * @author Marty Stepp
 * @version 2018/08/31
 * - initial version
 */

#define __DONT_ENABLE_QT_GRAPHICAL_CONSOLE

#undef __DONT_ENABLE_QT_GRAPHICAL_CONSOLE

/////////////////////// END code extracted from StanfordCPPLib/graphics/consoletext.h ///////////////////////

#define __DONT_ENABLE_GRAPHICAL_CONSOLE
/////////////////////// BEGIN code extracted from StanfordCPPLib/graphics/console.h ///////////////////////
/*
 * File: console.h
 * ---------------
 * This file contains functions related to the library's graphical console window,
 * implemented using the Qt graphics library in native C++ instead of Java.
 * In general if you #include this file, it will implicitly enable the graphical
 * console.  If you don't want to do that, you should #define a flag named
 * __DONT_ENABLE_QT_GRAPHICAL_CONSOLE right before #include'ing this header.
 * Once the graphical console has been enabled, it cannot easily be turned off
 * again for that program.
 * 
 * @author Marty Stepp
 * @version 2018/11/22
 * - added headless mode support
 * @version 2018/10/18
 * - fixed includes to avoid accidentally enabling GUI unintentionally
 * @version 2018/09/08
 * - added doc comments for new documentation generation
 * @version 2018/08/27
 * - cleaned up comments
 * @version 2018/08/23
 * - renamed to console.h to replace Java version
 * - separated out gconsolewindow.h/cpp
 * @version 2018/07/29
 * - menu, icons, hotkeys
 * @version 2018/07/26
 * - refactored GConsoleWindow class
 * @version 2018/07/15
 * - initial version, based on io/console.h
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _console_h
#define _console_h

#include <iostream>
#include <sstream>
#include <string>

#ifndef SPL_HEADLESS_MODE
class GConsoleWindow;
class GDimension;
class GPoint;
#endif // SPL_HEADLESS_MODE

/**
 * Erases the contents of the console window.
 */
void clearConsole();

/**
 * Returns whether the console's "clear" function should be enabled.
 * Default true.  If false, clear() will just print a message
 * rather than actually clearing the console.
 * @private
 */
bool getConsoleClearEnabled();

/**
 * Returns what the console will do when the user hits its "close" button.
 * By default, this is CONSOLE_HIDE_ON_CLOSE unless set otherwise.
 */
/* GWindow::CloseOperation */ int getConsoleCloseOperation();

/**
 * Returns whether or not the input/output from the Stanford graphical
 * console window is being echoed onto the standard operating system terminal
 * window. Initially this is false unless set to true by a previous call to
 * setConsoleEcho(true).
 */
bool getConsoleEcho();

/**
 * Returns whether the graphical console window is enabled.
 * This is true if you have included "qconsole.h" in your program.
 */
bool getConsoleEnabled();

/**
 * Returns whether an event should be generated if the console
 * window is closed.  By default this is false initially.
 * @private
 * @deprecated
 */
bool getConsoleEventOnClose();

/**
 * Returns whether the overall C++ program will terminate if the console
 * window is closed.  By default this is false initially.
 */
bool getConsoleExitProgramOnClose();

/**
 * Returns the font currently being used by the console.  The font
 * is typically a string in the form <code>family-style-size</code>.
 * In this string, <code>family</code> is the name of the font family;
 * <code>style</code> is either missing (indicating a plain font) or one
 * of the strings <code>Bold</code>, <code>Italic</code>, or
 * <code>BoldItalic</code>; and <code>size</code> is an integer
 * indicating the point size.
 * See gfont.h for more information about font strings.
 */
std::string getConsoleFont();

/**
 * Returns the height of the console window in pixels.
 */
double getConsoleHeight();

/**
 * Returns the x/y position of the top-left corner of the console window.
 */
#ifndef SPL_HEADLESS_MODE
GPoint getConsoleLocation();
#endif // SPL_HEADLESS_MODE

/**
 * Returns whether the location of the console window should be remembered and
 * restored between runs of the program.  Initially false.
 */
bool getConsoleLocationSaved();

/**
 * Returns whether or not a feature is enabled that causes exceptions to be
 * echoed to the Stanford graphical console window when they are thrown.
 * Disabled (false) by default.
 */
bool getConsolePrintExceptions();

/**
 * Returns whether functions like setConsoleFont or setConsoleSize
 * are currently ignored.  See setConsoleSettingsLocked.
 * Clients should generally not call this method.
 * @private
 */
bool getConsoleSettingsLocked();

/**
 * Returns the size of the console window in pixels.
 */
#ifndef SPL_HEADLESS_MODE
GDimension getConsoleSize();
#endif // SPL_HEADLESS_MODE

/**
 * Returns the width of the console window in pixels.
 */
double getConsoleWidth();

/**
 * Returns a pointer to the graphical console window,
 * which is a subclass of GWindow, so you can manipulate it as you would
 * any other window.
 *
 * @private
 */
#ifndef SPL_HEADLESS_MODE
GConsoleWindow* getConsoleWindow();
#endif // SPL_HEADLESS_MODE

/**
 * Returns the title bar text of the console window.
 */
std::string getConsoleWindowTitle();

/**
 * Initializes the state of the Qt graphical console, if it has not already
 * been initialized.
 * Clients should generally not call this method.
 * @private
 */
void initializeQtGraphicalConsole();

// defined in gwindow.h/cpp
extern void pause(double milliseconds);

/**
 * Returns whether the console's "clear" function should be enabled.
 * Default true.  If false, clear() will just print a message
 * rather than actually clearing the console.
 * This is sometimes used to facilitate creation of auto-grading scripts.
 * @private
 */
void setConsoleClearEnabled(bool value);

/**
 * Sets what the console should do when the user hits its "close" button.
 */
void setConsoleCloseOperation(/*GWindow::CloseOperation*/ int op);

/**
 * Enables or disables echoing the input/output from the Stanford graphical
 * console window onto the standard operating system terminal window.
 * Normally you don't need this echoing, but if you want to be able to copy
 * and paste your console interaction into another window, it is useful.
 */
void setConsoleEcho(bool echo);

/**
 * Sets the color used to display text in the console window.
 * The color string passed should be in a hex format such as "#ffa32f";
 * See gcolor.h for more detail about colors and color strings.
 */
void setConsoleErrorColor(const std::string& color);

/**
 * Sets whether an event should be generated if the console
 * window is closed.  By default this is false initially.
 * @private
 * @deprecated
 */
void setConsoleEventOnClose(bool eventOnClose);

/**
 * Sets whether the overall C++ program should terminate if the console
 * window is closed.  By default this is false initially.
 */
void setConsoleExitProgramOnClose(bool exitOnClose);

/**
 * Changes the font used for the console.  The <code>font</code> parameter
 * is typically a string in the form <code>family-style-size</code>.
 * In this string, <code>family</code> is the name of the font family;
 * <code>style</code> is either missing (indicating a plain font) or one
 * of the strings <code>Bold</code>, <code>Italic</code>, or
 * <code>BoldItalic</code>; and <code>size</code> is an integer
 * indicating the point size.  If any of these components is
 * specified as an asterisk, the existing value is retained.
 * The <code>font</code> parameter can also be a sequence of
 * such specifications separated by semicolons, in which case the
 * first available font on the system is used.
 * See gfont.h for more detail about font strings.
 */
void setConsoleFont(const std::string& font);

/**
 * Changes the (x, y) pixel position of the top-left corner of the console to
 * the specified coordinates, relative to the top/left of the screen.
 */
void setConsoleLocation(double x, double y);

/**
 * Sets whether the location of the console window should be remembered and
 * restored between runs of the program.  Default false.
 */
void setConsoleLocationSaved(bool value);

/**
 * Sets the color used to display text in the console window.
 * The color string passed should be in a hex format such as "#ffa32f";
 * See gcolor.h for more detail about color strings.
 */
void setConsoleOutputColor(const std::string& color);

/**
 * Enables or disables a feature that causes exceptions to be echoed to the
 * Stanford graphical console window when they are thrown.
 * Disabled (false) by default.
 * Note that using this feature may make it harder to get a stack trace in the
 * debugger if you are debugging the cause of an exception.
 */
void setConsolePrintExceptions(bool printExceptions, bool force = false);

/**
 * If set to true, disables functions like setConsoleFont or setConsoleSize,
 * to facilitate autograder construction by negating any such calls in the
 * student's main program.  Initially false.
 * Clients should generally not call this method.
 * @private
 */
void setConsoleSettingsLocked(bool value);

/**
 * Changes the size of the console to the specified dimensions in pixels.
 */
void setConsoleSize(double width, double height);

/**
 * Changes the title bar text of the console window to the specified text.
 */
void setConsoleWindowTitle(const std::string& title);

/**
 * Closes the graphical console window and turns it off.
 */
void shutdownConsole();

#endif // _console_h


/*
 * console.h is weird in that a student's program must be able to #include it
 * and then magically receive the graphical console instead of the standard one;
 * but we want other lib files to be able to include console.h to get the
 * function prototypes without actually turning the graphical console on.
 * To achieve this, we have the __DONT_ENABLE_QT_GRAPHICAL_CONSOLE flag that lib
 * files can set right before #include'ing console.h.  If they do so, it will
 * declare the prototypes but not initialize the graphical console.
 */
#ifndef __DONT_ENABLE_QT_GRAPHICAL_CONSOLE

// signal that graphical console is in use (so it will be initialized)
#define SPL_GRAPHICAL_CONSOLE_IN_USE 1

extern void setConsoleEnabled(bool);

namespace stanfordcpplib {
namespace qtgui {

#ifndef QtConsoleInitializer_created
#define QtConsoleInitializer_created
/**
 * @private
 */
class QtConsoleInitializer_private {
public:
    /*
     * Code to initialize the library.
     * Implemented as a class constructor so that it will run during
     * static initialization phase, which happens before the student's
     * main function.
     */
    QtConsoleInitializer_private() {
        setConsoleEnabled(true);
    }
};

/**
 * @private
 */
static QtConsoleInitializer_private __qt_console_init;
#endif // QtConsoleInitializer_created

} // namespace qtgui
} // namespace stanfordcpplib

#endif // __DONT_ENABLE_QT_GRAPHICAL_CONSOLE

#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

/////////////////////// END code extracted from StanfordCPPLib/graphics/console.h ///////////////////////

#undef __DONT_ENABLE_GRAPHICAL_CONSOLE
/////////////////////// BEGIN code extracted from StanfordCPPLib/io/bitstream.h ///////////////////////
/*
 * File: bitstream.h
 * -----------------
 * This file defines the ibitstream and obitstream classes which are basically
 * same as the ordinary istream and ostream classes, but add the
 * functionality to read and write one bit at a time.
 *
 * The idea is that you can substitute an ibitstream in place of an
 * istream and use the same operations (get, fail, >>, etc.)
 * along with added member functions of readBit, rewind, and size.
 *
 * Similarly, the obitstream can be used in place of ofstream, and has
 * same operations (put, fail, <<, etc.) along with additional
 * member functions writeBit and size.
 *
 * There are two subclasses of ibitstream: ifbitstream and istringbitstream,
 * which are similar to the ifstream and istringstream classes.  The
 * obitstream class similarly has ofbitstream and ostringbitstream as
 * subclasses.
 *
 * @author Keith Schwarz, Eric Roberts, Marty Stepp
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2016/11/12
 * - made toPrintable non-static and visible
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _bitstream_h
#define _bitstream_h

#include <istream>
#include <ostream>
#include <fstream>
#include <sstream>

/**
 * Constant: PSEUDO_EOF
 * A constant representing the PSEUDO_EOF marker that you will
 * write at the end of your Huffman-encoded file.
 */
const int PSEUDO_EOF = 256;

/**
 * Constant: NOT_A_CHAR
 * A constant representing an extended character that does not
 * actually hold a value.  When you are constructing your Huffman
 * encoding tree, you should set the characters in each internal
 * node (non-leaf) to this value to explicitly mark that they are not
 * being used.
 */
const int NOT_A_CHAR = 257;

/**
 * Defines a class for reading files with all the functionality of istream
 * along with an added member function for reading a single bit and convenience
 * functions for rewinding the stream back to the beginning and getting the stream
 * size.
 *
 * You will probably not create instances of this class directly.  Instead, you
 * will create ifbitstreams or istringbitstreams to read from files or string buffers.
 */
class ibitstream: public std::istream {
public:
    /**
     * Initializes a new ibitstream that is not attached to any source.  You are
     * unlikely to use this function directly.
     */
    ibitstream();

    /**
     * Reads a single bit from the ibitstream and returns 0 or 1 depending on
     * the bit value.  If the stream is exhausted, EOF (-1) is returned.
     * Raises an error if this ibitstream has not been properly opened.
     */
    int readBit();

    /**
     * Rewinds the ibitstream back to the beginning so that subsequent reads
     * start again from the beginning.  Raises an error if this ibitstream
     * has not been properly opened.
     */
    void rewind();
    
    /**
     * Sets 'fake' mode, where it actually reads bytes when you say readBit.
     */
    void setFake(bool fake);

    /**
     * Returns the size in bytes of the data attached to this stream.
     * Raises an error if this ibitstream has not been properly opened.
     */
    long size();

    /**
     * Returns whether or not this ibitstream is opened.  This only has
     * meaning if the ibitstream is a file stream; otherwise it always
     * returns true.
     */
    virtual bool is_open();

private:
    std::streampos lastTell;
    int curByte;
    int pos;
    bool fake;
};


/**
 * Defines a class for writing files with all the functionality of ostream
 * along with an added member function for writing a single bit and a convenience
 * function for getting the stream size.
 *
 * You are unlikely to instantiate this class directly; instead, instantiate one
 * of the subclasses.
 */
class obitstream: public std::ostream {
public:
    /**
     * Initializes a new obitstream that is not attached to any file.  Use the
     * open member function from ofstream to attach the stream to a file.
     */
    obitstream();

    /**
     * Writes a single bit to the obitstream.
     * Raises an error if this obitstream has not been properly opened.
     */
    void writeBit(int bit);

    /**
     * Returns the size in bytes of the file attached to this stream.
     * Raises an error if this obitstream has not been properly opened.
     */
    long size();

    /**
     * Sets 'fake' mode, where it actually writes bytes when you say writeBit.
     */
    void setFake(bool fake);
    
    /**
     * Returns whether or not this obitstream is opened.  This only has
     * meaning if the obitstream is a file stream; otherwise it always
     * returns true.
     */
    virtual bool is_open();

private:
    std::streampos lastTell;
    int curByte;
    int pos;
    bool fake;
};

/**
 * A class for reading files in all of the usual ways, plus bit-by-bit.
 * You can treat this class like a normal ifstream, except that there is
 * extra support for bit-level operations.
 */
class ifbitstream: public ibitstream {
public:
    /**
     * Constructs a new ifbitstream not attached to any file.  You can
     * open a file for reading using the .open() member functions.
     */
    ifbitstream();

    /**
     * Constructs a new ifbitstream that reads the file with the given name,
     * if it exists.  If not, the stream enters an error state.
     */
    ifbitstream(const char* filename);

    /**
     * Constructs a new ifbitstream that reads the specified file, if
     * it exists.  If not, the stream enters an error state.
     */
    ifbitstream(const std::string& filename);

    /**
     * Opens the specified file for reading.  If an error occurs, the
     * stream enters a failure state, which can be detected by calling
     * ifb.fail().
     */
    void open(const char* filename);

    /**
     * Opens the specified file for reading.  If an error occurs, the
     * stream enters a failure state, which can be detected by calling
     * ifb.fail().
     */
    void open(const std::string& filename);

    /**
     * Returns whether or not this ifbitstream is connected to a file for
     * reading.
     */
    bool is_open();

    /**
     * Closes the currently-opened file, if the stream is open.  If the
     * stream is not open, puts the stream into a fail state.
     */
    void close();

private:
    // the actual file buffer which does reading and writing.
    std::filebuf fb;
};

/**
 * A class for writing files in all of the usual ways, plus bit-by-bit.
 * You can treat this class like a normal ofstream, except that there is
 * extra support for bit-level operations.
 *
 * As a safety feature, you cannot use ofbitstream to open files that end
 * in .h, .hh, .cpp, or .cc for writing, as this could very easily cause
 * you to destroy your source files.
 */
class ofbitstream: public obitstream {
public:
    /**
     * Constructs a new ofbitstream not attached to any file.  You can
     * open a file for writing using the .open() member functions.
     */
    ofbitstream();

    /**
     * Constructs a new ofbitstream that writes the specified file, if
     * it exists.  If not, the stream enters an error state.  Read
     * the documentation on "open" for more details.
     */
    ofbitstream(const char* filename);

    /**
     * Constructs a new ofbitstream that writes the specified file, if
     * it exists.  If not, the stream enters an error state.  Read
     * the documentation on "open" for more details.
     */
    ofbitstream(const std::string& filename);

    /**
     * Opens the specified file for writing.  If an error occurs, the
     * stream enters a failure state, which can be detected by calling
     * ifb.fail().  If an invalid filename is specified (for example,
     * a source file), reports an error.
     */
    void open(const char* filename);

    /**
     * Opens the specified file for writing.  If an error occurs, the
     * stream enters a failure state, which can be detected by calling
     * ifb.fail().  If an invalid filename is specified (for example,
     * a source file), reports an error.
     */
    void open(const std::string& filename);

    /**
     * Returns whether or not this ofbitstream is connected to a file for
     * reading.
     */
    bool is_open();

    /**
     * Closes the currently-opened file, if the stream is open.  If the
     * stream is not open, puts the stream into a fail state.
     */
    void close();

private:
    // the actual file buffer which does reading and writing.
    std::filebuf fb;
};

/**
 * A variant on C++'s istringstream class, which acts as a stream that
 * reads its data from a string.  This is mostly used by the testing
 * code to test your Huffman encoding without having to read or write
 * files on disk, but you can use it in your own testing if you would
 * like.
 */
class istringbitstream: public ibitstream {
public:
    /**
     * Constructs an istringbitstream reading the specified string.
     */
    istringbitstream(const std::string& s = "");

    /**
     * Sets the underlying string of the istringbitstream.
     */
    void str(const std::string& s);
private:
    // the actual string buffer that does character storage
    std::stringbuf sb;
};

/**
 * A variant on C++'s ostringstream class, which acts as a stream that
 * writes its data to a string.  This is mostly used by the testing
 * code to test your Huffman encoding without having to read or write
 * files on disk, but you can use it in your own testing if you would
 * like.
 */
class ostringbitstream: public obitstream {
public:
    /**
     * Constructs an ostringbitstream.
     */
    ostringbitstream();

    /**
     * Retrieves the underlying string of the istringbitstream.
     */
    std::string str();

private:
    // the actual string buffer that does character storage
    std::stringbuf sb;
};

/**
 * Returns a printable string for the given character.
 * @example toPrintable('c') returns "c"
 * @example toPrintable('\n') returns "\\n"
 */
std::string toPrintable(int ch);

#endif // _bitstream_h

/////////////////////// END code extracted from StanfordCPPLib/io/bitstream.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/io/plainconsole.h ///////////////////////
/*
 * File: plainconsole.h
 * --------------------
 * This file declares functions to add utility to the
 * C++ plain text console streams, cin/cout/cerr.
 * See plainconsole.cpp for implementation of each function.
 *
 * @author Marty Stepp
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2015/10/21
 * @since 2015/10/21
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _plainconsole_h
#define _plainconsole_h

namespace plainconsole {
/**
 * Sets the cout console to throw an error if more than the given number of
 * total characters are ever printed to it.
 * This can be used to stop student programs that try to print infinite output.
 */
void setOutputLimit(int limit);

/**
 * Sets whether user input values read from cin are echoed back to cout.
 * This is useful when capturing output dialogues for comparison/diffing.
 */
void setEcho(bool value);
} // namespace plainconsole

#endif // _plainconsole_h

/////////////////////// END code extracted from StanfordCPPLib/io/plainconsole.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/complex.h ///////////////////////
/*
 * File: complex.h
 * ---------------
 * This file exports a type representing complex numbers.
 *
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2017/10/18
 * - initial version
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _complex_h
#define _complex_h

#include <iostream>
#include <string>

/**
 * A Complex object represents a complex number of the form a + bi.
 */
class Complex {
public:
    /**
     * Constructs a new imaginary number: (a + b * i).
     */
    Complex(double a = 0.0, double b = 0.0);

    /**
     * Returns the absolute value of the complex number.
     */
    double abs() const;

    /**
     * Returns the imaginary value of the complex number.
     */
    double imag() const;

    /**
     * Returns the real value of the complex number.
     */
    double real() const;

    /**
     * Returns a string representation of this complex number,
     * such as "4+3i" or "-2-4i" or "0".
     */
    std::string toString() const;

    /**
     * Adds two complex numbers and returns
     * the result as a new complex number.
     */
    friend Complex operator +(const Complex& m, const Complex& n);

    /**
     * Subtracts two complex numbers and returns
     * the result as a new complex number.
     */
    friend Complex operator -(const Complex& m, const Complex& n);

    /**
     * Multiplies two complex numbers and returns
     * the result as a new complex number.
     */
    friend Complex operator *(const Complex& m, const Complex& n);

    friend std::istream& operator >>(std::istream& out, Complex& c);

private:
    double a;   // real value
    double b;   // imag value
};

/**
 * Returns an integer hash code for complex numbers so that they
 * can be stored in HashSet and HashMap collections.
 */
int hashCode(const Complex& c);

/**
 * These relational operators define a total ordering for complex numbers.
 * Mathematically this is not well-defined, but we provide this simply so
 * that Complex objects can be stored in a Set or Map collection.
 */
bool operator <(const Complex& c1, const Complex& c2);
bool operator <=(const Complex& c1, const Complex& c2);
bool operator >(const Complex& c1, const Complex& c2);
bool operator >=(const Complex& c1, const Complex& c2);
bool operator ==(const Complex& c1, const Complex& c2);
bool operator !=(const Complex& c1, const Complex& c2);

/**
 * Writes the complex number to an output stream.
 */
std::ostream& operator <<(std::ostream& out, const Complex& c);

/**
 * Reads a complex number from an output stream.
 */
std::istream& operator >>(std::istream& input, Complex& c);

#endif // _complex_h

/////////////////////// END code extracted from StanfordCPPLib/util/complex.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/biginteger.h ///////////////////////
/*
 * File: biginteger.h
 * ------------------
 * This file exports a class for arbitrary-size integer arithmetic.
 * It is meant to help get around the max/min value limit for types
 * such as int and long.
 *
 * In general, a BigInteger supports the standard operators and operations
 * that you would expect to be able to use on an int or long value.
 *
 * Example usage:
 *
 * BigInteger bi("1234567890123456789");
 * for (int i = 0; i < 10; i++) {
 *     bi *= 12345678;
 * }
 * cout << "really big number is: " << bi << endl;
 *
 * Implementation notes:
 * This code is heavily based on a BigInteger library taken from:
 * https://github.com/panks/BigInteger
 *
 * The implementation stores the big integer as a string of base-10 digits
 * along with a sign bit represented as a bool.
 * In general the operations are not heavily optimized; this class should not
 * be used in situations where performance is critical.
 * Note that better Big Integer libraries exist in other places for more
 * serious work and can be found using your favorite search engine.
 *
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2017/10/28
 * - initial version
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _biginteger_h
#define _biginteger_h

#include <iostream>
#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

class BigInteger {
public:
    /**
     * Constants to represent very commonly used big integer values
     */
    static const BigInteger NEGATIVE_ONE;
    static const BigInteger ZERO;
    static const BigInteger ONE;
    static const BigInteger TWO;
    static const BigInteger TEN;
    static const BigInteger MAX_INT;
    static const BigInteger MIN_INT;
    static const BigInteger MAX_UINT;
    static const BigInteger MAX_LONG;
    static const BigInteger MIN_LONG;
    static const BigInteger MAX_ULONG;
    static const BigInteger MAX_SHORT;
    static const BigInteger MIN_SHORT;
    static const BigInteger MAX_USHORT;

    /**
     * Constructs a new big integer set to zero.
     *
     * @example BigInteger bi;
     */
    BigInteger();

    /**
     * Constructs a new big integer whose value is a copy of another big integer.
     *
     * @example BigInteger bi1(bi2);
     */
    BigInteger(const BigInteger& other);

    /**
     * Constructs a new big integer set to the given value.
     *
     * @example BigInteger bi("1234567890123456789");
     */
    BigInteger(const std::string& s, int radix = 10);

    /**
     * Constructs a new big integer set to the given value.
     *
     * @example BigInteger bi(12345);
     * @example BigInteger bi2(-42);
     */
    BigInteger(long n);

    /**
     * Returns a new BigInteger whose value is the absolute value of this one.
     */
    BigInteger abs() const;

    /**
     * Returns the greatest common divisor of this and the given other big integer.
     * For example, gcd(24, 16) is 8.
     */
    BigInteger gcd(const BigInteger& other) const;

    /**
     * Returns true if this BigInteger's value is within the range of values
     * that can be stored as an int.
     */
    bool isInt() const;

    /**
     * Returns true if this BigInteger's value is within the range of values
     * that can be stored as a long.
     */
    bool isLong() const;

    /**
     * Returns true if this BigInteger represents a negative number < 0.
     * You could just perform the check yourself by testing whether number > 0,
     * but this member is faster because it doesn't need to create a temporary
     * BigInteger instance for doing the comparison.
     */
    bool isNegative() const;

    /**
     * Returns true if this BigInteger represents a non-negative number >= 0.
     * You could just perform the check yourself by testing whether number > 0,
     * but this member is faster because it doesn't need to create a temporary
     * BigInteger instance for doing the comparison.
     */
    bool isNonNegative() const;

    /**
     * Returns true if this BigInteger represents a positive number > 0.
     * You could just perform the check yourself by testing whether number > 0,
     * but this member is faster because it doesn't need to create a temporary
     * BigInteger instance for doing the comparison.
     */
    bool isPositive() const;

    /**
     * Returns whichever is larger between this big integer and the given
     * other big integer.
     */
    const BigInteger& max(const BigInteger& other) const;

    /**
     * Returns whichever is smaller between this big integer and the given
     * other big integer.
     */
    const BigInteger& min(const BigInteger& other) const;

    /**
     * Returns a new BigInteger whose value is (this ^^ exp) % m.
     * @throw ErrorException if exp is negative or if m is 0.
     */
    BigInteger modPow(const BigInteger& exp, const BigInteger& m) const;

    /**
     * Returns a new BigInteger whose value is the value of this BigInteger
     * raised to the given exponent.
     * @throw ErrorException if the exponent is negative.
     */
    BigInteger pow(long exp) const;

    /**
     * Returns a new BigInteger whose value is the value of this BigInteger
     * raised to the given exponent.
     * @throw ErrorException if the exponent is negative.
     */
    BigInteger pow(const BigInteger& exp) const;

    /**
     * Returns an int representation of this BigInteger, such as
     * -12345678.
     * @throw ErrorException if this BigInteger is out of the range of int.
     */
    int toInt() const;

    /**
     * Returns a long representation of this BigInteger, such as
     * -123456789.
     * @throw ErrorException if this BigInteger is out of the range of long.
     */
    long toLong() const;

    /**
     * Returns a string representation of this BigInteger, such as
     * "-1234567890123456789".
     */
    std::string toString(int radix = 10) const;

    /**
     * Increases the value of this BigInteger by 1 (prefix).
     */
    BigInteger& operator ++(); // prefix

    /**
     * Increases the value of this BigInteger by 1 (posfix).
     */
    BigInteger  operator ++(int); // postfix

    /**
     * Decreases the value of this BigInteger by 1 (prefix).
     */
    BigInteger& operator --(); // prefix

    /**
     * Decreases the value of this BigInteger by 1 (postfix).
     */
    BigInteger  operator --(int); // postfix

    /**
     * Assigns this BigInteger to store the sum of itself
     * and the given other BigInteger.
     */
    BigInteger& operator +=(const BigInteger& b);

    /**
     * Assigns this BigInteger to store the result of subtracting
     * the given other BigInteger from this BigInteger.
     */
    BigInteger& operator -=(const BigInteger& b);

    /**
     * Assigns this BigInteger to store the product of itself
     * and the given other BigInteger.
     */
    BigInteger& operator *=(const BigInteger& b);

    /**
     * Assigns this BigInteger to store the quotient of dividing
     * itself by the given other BigInteger.
     * @throw ErrorException if denominator is 0.
     * @throw ErrorException if denominator is not within the range of type long.
     */
    BigInteger& operator /=(const BigInteger& b);

    /**
     * Assigns this BigInteger to store the remainder of dividing
     * itself by the given other BigInteger.
     * @throw ErrorException if denominator is 0.
     * @throw ErrorException if denominator is not within the range of type long.
     */
    BigInteger& operator %=(const BigInteger& b);

    /**
     * Sets this big integer to a bitwise AND between this integer and the given other integer,
     * retaining only bits that are set in both.
     */
    BigInteger& operator &=(const BigInteger& b);

    /**
     * Sets this big integer to a bitwise OR between this integer and the given other integer,
     * retaining bits that are set in this integer or the other integer or both.
     */
    BigInteger& operator |=(const BigInteger& b);

    /**
     * Sets this big integer to a bitwise XOR between this integer and the given other integer,
     * retaining bits that are set in this integer or the other integer but not both.
     */
    BigInteger& operator ^=(const BigInteger& b);

    /**
     * Performs a bitwise NOT on this integer,
     * inverting the values of all of its bits.
     */
    BigInteger operator ~() const;

    /**
     * Performs a logical NOT on this integer,
     * setting it to 0 if non-zero, or to 1 if zero.
     */
    BigInteger operator !() const;

    /**
     * Sets this BigInteger to store the same value as the given other big integer.
     */
    BigInteger& operator =(const BigInteger& other);

    /**
     * Unary negation; returns a new BigInteger that is
     * the negative of this BigInteger.
     */
    BigInteger operator -() const;

    /**
     * Returns a new big integer whose value is equal to the value of
     * this big integer bit-shifted left by the given number of bits.
     * Equivalent to multiplying by 2 ^ shift.
     */
    BigInteger operator <<(unsigned int shift) const;

    /**
     * Modifies this big integer to be bit-shifted left by the given number of bits.
     * Equivalent to multiplying by 2 ^ shift.
     */
    BigInteger& operator <<=(unsigned int shift);

    /**
     * Returns a new big integer whose value is equal to the value of
     * this big integer bit-shifted right by the given number of bits.
     * Equivalent to dividing by 2 ^ shift.
     */
    BigInteger operator >>(unsigned int shift) const;

    /**
     * Modifies this big integer to be bit-shifted right by the given number of bits.
     * Equivalent to dividing by 2 ^ shift.
     */
    BigInteger& operator >>=(unsigned int shift);

    /**
     * Converts this BigInteger into a boolean value.
     * The value will be false if this BigInteger stores 0, or true otherwise.
     */
    explicit operator bool() const;

    /**
     * Converts this BigInteger into a double.
     * @throw ErrorException if this big integer is not within the range of type long.
     */
    // explicit operator double() const;

    /**
     * Converts this BigInteger into a float.
     * @throw ErrorException if this big integer is not within the range of type long.
     */
    // explicit operator float() const;

    /**
     * Converts this BigInteger into an integer.
     * @throw ErrorException if this big integer is not within the range of type int.
     */
    explicit operator int() const;

    /**
     * Converts this BigInteger into a long.
     * @throw ErrorException if this big integer is not within the range of type long.
     */
    explicit operator long() const;

    /**
     * Converts this BigInteger into a string.
     */
    explicit operator std::string() const;

private:
    /*
     * Constructs a new big integer set to the given value,
     * with optional sign (true=negative, false=positive).
     *
     * Example:
     * BigInteger bi("1234567890123456789", true);   // negative
     */
    BigInteger(const std::string& s, bool sin); // "string" constructor

    // add two big integers as string and return result; used by operator +
    static std::string add(const std::string& number1, const std::string& number2);

    // checks that the given string is in the proper format that it could be
    // interpreted as an integer in the given base; if not, issues an error()
    static void checkStringIsNumeric(const std::string& s, int radix = 10);

    // TODO: make work for big integer division
    // divide n by den and return result; used by operator /
    static std::pair<std::string, long> divide(const std::string& n, long den);
    static std::pair<BigInteger, BigInteger> divideBig(const BigInteger& numer, const BigInteger& denom);

    // return true if two BigIntegers are equal; used by operator ==
    static bool equals(const BigInteger& n1, const BigInteger& n2);

    // checks for -0 case and changes to 0
    void fixNegativeZero();

    /*
     * Returns the number stored by this BigInteger as a string.
     * If this BigInteger represents a negative number, the sign will be omitted.
     * Example: "1234567890123456789"
     */
    const std::string& getNumber() const; // retrieves the number

    /*
     * Returns the sign of this BigInteger; true if negative, false if not.
     */
    bool getSign() const;

    // return true if n1 > n2; used by operator >
    static bool greater(const BigInteger& n1, const BigInteger& n2);

    // return true if n1 < n2; used by operator <
    static bool less(const BigInteger& n1, const BigInteger& n2);

    // multiply two big integers as string and return result; used by operator *
    static std::string multiply(const std::string& n1, const std::string& n2);

    // removes leading 0s except one from given number
    static std::string removeLeadingZeros(const std::string& s);

    /*
     * Sets the number and the sign stored by this BigInteger.
     */
    void setValue(const std::string& s, int radix = 10);

    /*
     * Sets the number stored by this BigInteger.
     */
    void setNumber(const std::string& s, int radix = 10);

    /*
     * Sets the sign stored by this BigInteger.
     * The value true means negative; false means positive.
     */
    void setSign(bool s);

    // e.g. "0xfff" => "fff"
    static std::string stripNumberPrefix(const std::string& num, int radix = 10);

    // subtract num2 from num1 as string and return result; used by operator -
    static std::string subtract(const std::string& number1, const std::string& number2);

    // convert a string value into a long
    static long toLong(const std::string& s);

    // convert a long value to a string
    static std::string toString(long n);

    // TODO: remove?
    BigInteger& operator [](int n);

    friend int hashCode(const BigInteger& b);
    friend BigInteger operator +(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator -(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator *(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator /(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator %(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator &(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator |(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator ^(const BigInteger& b1, const BigInteger& b2);
    friend bool operator ==(const BigInteger& b1, const BigInteger& b2);
    friend bool operator !=(const BigInteger& b1, const BigInteger& b2);
    friend bool operator >(const BigInteger& b1, const BigInteger& b2);
    friend bool operator <(const BigInteger& b1, const BigInteger& b2);
    friend bool operator >=(const BigInteger& b1, const BigInteger& b2);
    friend bool operator <=(const BigInteger& b1, const BigInteger& b2);
    friend std::istream& operator >>(std::istream& input, BigInteger& b);
    friend std::ostream& operator <<(std::ostream& out, const BigInteger& b);

    // member variables
    std::string number;   // string representation of this big integer in base-10, e.g. "1234567890123456789"
    bool sign;            // true if number is negative
};

/**
 * Returns a string representation of the given big integer.
 * Equivalent to calling bi.toString().
 * Provided for consistency with the other lib functions like integerToString.
 */
std::string bigIntegerToString(const BigInteger& bi, int radix = 10);

/**
 * Returns an integer hash code for the given BigInteger.
 */
int hashCode(const BigInteger& b);

/**
 * Returns a new BigInteger that is the sum of this BigInteger
 * and the given other BigInteger.
 */
BigInteger operator +(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns a new BigInteger that is the result of subtracting
 * the given other BigInteger from this BigInteger.
 */
BigInteger operator -(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns a new BigInteger that is the product of this BigInteger
 * and the given other BigInteger.
 */
BigInteger operator *(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns a new BigInteger that is the quotient of dividing
 * this BigInteger by the given other BigInteger.
 * @throw ErrorException if denominator is 0.
 * @throw ErrorException if denominator is not within the range of type long.
 */
BigInteger operator /(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns a new BigInteger that is the remainder of dividing
 * this BigInteger by the given other BigInteger.
 * @throw ErrorException if denominator is 0.
 * @throw ErrorException if denominator is not within the range of type long.
 */
BigInteger operator %(const BigInteger& b1, const BigInteger& b2);

/**
 * Performs a bitwise AND between this integer and the given other integer,
 * retaining only bits that are set in both.
 */
BigInteger operator &(const BigInteger& b1, const BigInteger& b2);

/**
 * Performs a bitwise OR between this integer and the given other integer,
 * retaining bits that are set in this integer or the other integer or both.
 */
BigInteger operator |(const BigInteger& b1, const BigInteger& b2);

/**
 * Performs a bitwise XOR between this integer and the given other integer,
 * retaining bits that are set in this integer or the other integer but not both.
 */
BigInteger operator ^(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns true if two BigIntegers store the same value.
 */
bool operator ==(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns true if two BigIntegers do not store the same value.
 */
bool operator !=(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns true if this BigInteger stores a larger value than the given other one.
 */
bool operator >(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns true if this BigInteger stores a smaller value than the given other one.
 */
bool operator <(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns true if this BigInteger stores a value that is
 * greater than or equal to the given other one.
 */
bool operator >=(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns true if this BigInteger stores a value that is
 * less than or equal to the given other one.
 */
bool operator <=(const BigInteger& b1, const BigInteger& b2);

/**
 * Reads a BigInteger from the given input stream.
 */
std::istream& operator >>(std::istream& input, BigInteger& b);

/**
 * Writes this BigInteger to the given output stream.
 */
std::ostream& operator <<(std::ostream& out, const BigInteger& b);

/*
 * Free-standing arithmetic operators between int/long and BigInteger.
 * (Commenting these out because when present they seem to also match double,
 * producing bad results.)
 */
//BigInteger operator +(long n, const BigInteger& b);
//BigInteger operator -(long n, const BigInteger& b);
//BigInteger operator *(long n, const BigInteger& b);
//BigInteger operator /(long n, const BigInteger& b);
//BigInteger operator %(long n, const BigInteger& b);

// aliases for BigInteger for those who like abbreviations and lowercase
typedef BigInteger BigInt;
typedef BigInteger bigint;

#endif // _biginteger_h

/////////////////////// END code extracted from StanfordCPPLib/util/biginteger.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/bigfloat.h ///////////////////////
///// BEGIN BASE.H
//#pragma once

//#ifndef INTERNAL_INCLUDE
//
//#endif // INTERNAL_INCLUDE

//#include <stddef.h>
//#include <stdio.h>
//#include <stdarg.h>
//#include <vector>
//#include <map>
//#include <stdexcept>
//#include <string>
//#include <sstream>

//#ifdef _MSC_VER
//# define INLINE __forceinline
//  typedef  unsigned __int64 u8;
//  typedef  unsigned __int32 u4;
//  typedef  unsigned __int16 u2;
//  typedef  unsigned __int8  u1;
//  typedef  __int64 s8;
//  typedef  __int32 s4;
//  typedef  __int16 s2;
//  typedef  __int8  s1;
//#else
//# include <stdint.h>
//# define INLINE inline
//  typedef  uint64_t  u8;
//  typedef  uint32_t  u4;
//  typedef  uint16_t  u2;
//  typedef  uint8_t   u1;
//  typedef  int64_t  s8;
//  typedef  int32_t  s4;
//  typedef  int16_t  s2;
//  typedef  int8_t   s1;
//#endif

//class CosmosException : public std::exception
//{
//public:
//    CosmosException(const char* m) : _msg(m) {}
//    CosmosException(const std::string& m) : _msg(m) {}
//    virtual ~CosmosException() throw() {}
//    virtual const char* what() const throw()
//    {
//        return _msg.c_str();
//    }
//protected:
//    std::string _msg;
//};

/*#define ASSERT(condition, ...) do { \
  if (!(condition)) Assert(__LINE__, __FILE__, #condition, ##__VA_ARGS__); \
} while(0) */

/*#define ASSERTFG(f,g) do { \
  double fr = (f); double gr = (g); double diff = (fr-gr); \
  if (diff > 1.0e-10 || diff < -1.0e-10) \
  Assert(__LINE__, __FILE__, #f "," #g, "%f, %f, %f", fr, gr, diff); \
} while(0) */

//static void Assert(
//    int line,
//    const char* filename,
//    const char* condition)
//{
//	static const int bufSize = 4000;
//    char y[bufSize];
//    sprintf(y, "line=[%d], file=[%s], condition=[%s]",
//            line, filename, condition);
//    throw CosmosException(y);
//}

//static void Assert(
//    int line,
//    const char* filename,
//    const char* condition,
//    const char* fmt,
//    ...)
//{
//	static const int bufSize = 4000;
//    char x[bufSize];
//    char y[bufSize];
//    va_list args;
//    va_start(args, fmt);
//    vsprintf(x, fmt, args);
//    va_end(args);
//    sprintf(y, "line=[%d], file=[%s], condition=[%s], %s",
//            line, filename, condition, x);
//    throw CosmosException(y);
//}

///// END BASE.H






////#pragma once
////


//// This is not fast, but it has good accuracy.
//// I need this because orbital problems have a lot of nth-degree
//// polynomial approximations, and the coefficients of those polynomial
//// approximations are things like 48471792742212/237758976000.  The only
//// way to get the definitions of coefficients right is to do Gaussian
//// elimination on at least n equations with n unknowns, and a precision
//// about twice as great as the coefficients I want to end up with,
//// followed by continued fractions on the result to find the proper
//// fractional representation.
//class BigFloat
//{
//public:
//    BigFloat() { Zero(); }
//    BigFloat(const BigFloat& n) { Copy(n); }
//    BigFloat(s8 n) { FromInteger(n); }
//    BigFloat(s8 n, s8 exponent) { FromInteger(n, exponent); }
//    ~BigFloat() {}

//    // translation
//    BigFloat& FromInteger(s8 num, s8 exponent=0);
//    s8 ToInteger() const;  // it will truncate, but not overflow
//    static s8 RoundInteger(s8 value);  // round an s8 to right precision
//    double ToDouble() const;
//    bool IsNegative() const { return _isNegative; }
//    s8 ToExponent() const { return _exponent; }
//    u8 ToDigits() const;  // return digits filling an integer
//    void ToFraction(BigFloat& num, BigFloat& denom, int iter=1024) const;
//    void Print() const;
//    void PrintHex() const;
//    void PrintContinuedFraction() const;
//    void PrintDouble() const;

//    // arithmetic
//    BigFloat& PZero()
//    {
//        _exponent = c_zeroExponent;
//        _length = 0;
//        _isNegative = false;
//        return *this;
//    }
//    BigFloat& NZero()
//    {
//        _exponent = c_zeroExponent;
//        _length = 0;
//        _isNegative = true;
//        return *this;
//    }
//    BigFloat& Zero( bool neg = false) { return neg ? NZero() : PZero(); }
//    BigFloat& PInf()
//    {
//        _exponent = c_zeroExponent;
//        _length = 1;
//        _isNegative = false;
//        return *this;
//    }
//    BigFloat& NInf()
//    {
//        _exponent = c_zeroExponent;
//        _length = 1;
//        _isNegative = true;
//        return *this;
//    }
//    BigFloat& Inf( bool negative = false) { return negative ? NInf() : PInf(); }
//    BigFloat& NaN()
//    {
//        _exponent = c_zeroExponent;
//        _length = 2;
//        _isNegative = false;
//        return *this;
//    }

//    BigFloat& Copy(const BigFloat& n);
//    BigFloat& Negate();

//    // round to c_digits digits
//    //   carry=true: there should be an additional top digit of 1
//    //   previousDigit: what _d[c_digits] would have been, or 0
//    BigFloat& Round(bool carry, s8 previousDigit);
//    BigFloat& Round(u8 previousDigit);

//    // truncate to the nearest integer, towards zero
//    BigFloat& Trunc();

//    // -1 if |this|<|n|, 0 if |this|==|n|, 1 if |this|>|n|
//    int CompareAbsolute(const BigFloat& n) const;


//    // -1 if this<n, 0 if this==n, 1 if this>n
//    int Compare(const BigFloat& n) const;

//    bool IsZero() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 0;
//    }
//    bool IsPZero() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 0 &&
//            _isNegative == false;
//    }
//    bool IsNZero() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 0 &&
//            _isNegative == true;
//    }
//    bool IsInf() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 1;
//    }
//    bool IsPInf() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 1 &&
//            _isNegative == false;
//    }
//    bool IsNInf() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 1 &&
//            _isNegative == true;
//    }
//    bool IsNaN() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 2;
//    }
//    bool IsSpecial() const
//    {
//        return _exponent == c_zeroExponent;
//    }

//    BigFloat& Add(const BigFloat& n) { return AddOrSubtract(n, false); }
//    BigFloat& Sub(const BigFloat& n) { return AddOrSubtract(n, true); }
//    BigFloat& Mult(const BigFloat& n); // x => x*n
//    BigFloat& Div(const BigFloat& n); // x => x/n
//    BigFloat& Invert(); // x => 1/x
//    BigFloat& Sqrt(); // x => positive square root of x
//    BigFloat& Cos(); // x => cosine of x (x in radians)
//    BigFloat& Sin(); // x => sine of x (x in radians)
//    BigFloat& Sec(); // x => secant of x (x in radians)
//    BigFloat& Csc(); // x => cosecant of x (x in radians)
//    BigFloat& Tan(); // x => tangent of x (x in radians)
//    BigFloat& Exp(); // x => e to the xth power
//    BigFloat& ASin(); // x => arcsin of x (-1 => -pi/2, 1 => pi/2)
//    BigFloat& ACos(); // x => arccos of x (-1 => pi, 1 => 0)
//    BigFloat& ATan(); // x => arctan of x (-inf => -pi/2, inf => pi/2)
//    BigFloat& Ln();  // replaces x with the natural log of x
//    BigFloat& Log(const BigFloat& n);  // x => natural log of n base x
//    BigFloat& Power(const BigFloat& n); // replaces x with x to the nth
//    BigFloat& Rand(); // not impl: uniformly distributed value in [0,1)
//    BigFloat& RandNorm(); // not impl: pseudorandom normally-distributed value

//    // constants
//    static const BigFloat& Pi();  // length of unit circle, 3.14159...
//    static const BigFloat& E();  // the natural base for exponents, 2.71828...
//    static const BigFloat& ConstZero();
//    static const BigFloat& ConstOne();
//    static const BigFloat& ConstMinusOne();

//    // variations where arguments are signed integers
//    int Compare(s8 n, s8 exponent=0);
//    BigFloat& Add(s8 n, s8 exponent=0);
//    BigFloat& Sub(s8 n, s8 exponent=0);
//    BigFloat& Mult(s8 n, s8 exponent=0);
//    BigFloat& Div(s8 n, s8 exponent=0);
//    BigFloat& Power(s8 n, s8 exponent=0);  // not implemented

//    // Given an m*(m+1) matrix of BigFloat where the last col means =const,
//    // solve, and fill m[i][m] with the value for the ith variable.
//    static void GaussianElimination(BigFloat** m, s8 rows, s8 cols);
    
//    // assure that it works as expected
//    static void UnitTest();
        
//private:
//    // First, this => this mod 2pi.
//    // Return the quadrant (int)(this / (pi/4)), value 0..7
//    // this => (this + pi/4) mod pi/2 (positive), - pi/4.
//    // That means a negative value for odd quadrants and positive for even.
//    s8 Quadrant();
//    BigFloat& PartialSin();  // sin, but only for -pi/4 to pi/4
//    BigFloat& PartialCos();  // cos, but only for -pi/4 to pi/4
    
//    // this+n, or this-n if minus==true
//    BigFloat& AddOrSubtract(const BigFloat& n, bool minus);

//    // test whether this is the right representation of this integer
//    static void TestInteger(const BigFloat& n, s8 x);

//    // test addition and subtraction of two integers
//    static void TestAdd(s8 x, s8 y);

//    // test multiplication of two numbers
//    static void TestMult(s8 x, s8 ex, s8 y, s8 ey);

//    // test inverse of one number
//    static void TestInverse(s8 x, s8 ex);

//    // test sqrt of one number
//    static void TestSqrt(s8 x, s8 ex);

//    // representation: c_digits digits, each with range 0..c_range-1
//    // _d[0] is the most significant digit
//#ifdef BIGFLOAT_TEST
//    static const s8 c_digits = 4;
//    static const s8 c_log = 2;
//    static const s8 c_zeroExponent = -(((s8)1) << 4);
//#else
//    static const s8 c_digits = 10;
//    static const s8 c_log = 32;

//    // -1<<63 is a signed value, but 1<<63 is not, so 1<<62 then
//    static const s8 c_zeroExponent = -(((s8)1) << 62);
//#endif
//    static const s8 c_minExponent = c_zeroExponent + c_digits;
//    static const s8 c_maxExponent =  -c_zeroExponent;
//    static const u8 c_range = (((u8)1)<<c_log);

//    s8 _exponent;
//    u4 _d[c_digits];
//    bool _isNegative;
//    u2 _length; // number of digits used
//};

//class BigFloatCache
//{
//public:
//    static bool _isInitialized;
//    static BigFloat _zero;
//    static BigFloat _e;
//    static BigFloat *_ePower; // [i] is e^^(2^^i), i in -6..ePowerLen-1
//    static BigFloat *_eInvPower; // [i] is e^^-(2^^i), i in -6..ePowerLen-1
//    static s8 _ePowerLen;
//    static const s8 _ePowerNeg = -7;
//    static BigFloat _pi;
//    static BigFloat _twoPi;
//    static BigFloat _overTwoPi;
//    static BigFloat _piOverTwo;
//    static BigFloat _threePiOverTwo;
//    static BigFloat _piOverFour;
//    static s8 _overFactLen;
//    static BigFloat* _overFact;

//    // fill in _pi, _e, and various cached arrays
//    static void Init();
//};

/////////////////////// END code extracted from StanfordCPPLib/util/bigfloat.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/private/version.h ///////////////////////
/*
 * File: version.h
 * ---------------
 * This file contains declarations of the version number of the
 * Stanford C++ library.
 *
 * @author Marty Stepp
 * @version 2018/12/28
 */

#ifndef _version_h
#define _version_h

#include <string>

/*
 * Current version of the Stanford C++ library.
 * NOTE: This value and the other date values here all
 *       *MUST* be zero-padded to YYYY/MM/DD format;
 *       if month or day is < 10, insert a preceding 0
 */
#define STANFORD_CPP_LIB_VERSION "2018/12/28"

/*
 * Minimum version of your IDE's project that is supported.
 * platform.cpp checks this and exits if project .pro is older than
 * this to avoid incompatible versions.
 *
 * NOTE: This value and the other date values here all
 *       *MUST* be zero-padded to YYYY/MM/DD format;
 *       if month or day is < 10, insert a preceding 0
 */
#define STANFORD_CPP_PROJECT_MINIMUM_VERSION "2018/10/23"

/*
 * URL at which documentation about the libraries can be found.
 */
#define STANFORD_CPP_LIB_DOCS_URL "http://stanford.edu/~stepp/cppdoc/"


namespace version {
void ensureJavaBackEndVersion(std::string minVersion = "") /* deprecated */;
void ensureProjectVersion(std::string minVersion = "");
std::string getCppLibraryDocsUrl();
std::string getCppLibraryVersion();
std::string getJavaBackEndVersion() /* deprecated */;
std::string getProjectVersion();
} // namespace version

#endif // _version_h

/////////////////////// END code extracted from StanfordCPPLib/private/version.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/regexpr.h ///////////////////////
/*
 * File: regexpr.h
 * ---------------
 * This file exports functions for performing regular expression operations
 * on C++ strings.  It will be unnecessary once the C++11 regex library
 * is widely available, but as of this writing the regex library is not
 * supported on gcc and other major C++ compilers.
 * 
 * The regular expression functions are implemented by sending the strings and
 * regexes to the Java Back-End to run the operations in Java.  This is a bit
 * kludgy but we don't want to write our own regex parser from scratch.
 * Using Java's is a compromise for now.
 *
 * @author Marty Stepp
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2018/09/20
 * - added Qt version checking around some regex functions for compatibility
 * @version 2014/10/14
 * - removed regexMatchCountWithLines for simplicity
 * @since 2014/03/01
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _regexpr_h
#define _regexpr_h

#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * Returns true if the given string s matches the given regular expression
 * as a substring.
 * For an exact match instead, put "^" and "$" in your regex as start/end anchors.
 */
bool regexMatch(const std::string& s, const std::string& regexp);

/**
 * Returns the number of times the given regular expression is found inside
 * the given string s.
 * Returns 0 if there are no matches for the regexp.
 */
int regexMatchCount(const std::string& s, const std::string& regexp);

/**
 * Finds all matches of the given regular expression in the given string s
 * and fills 'linesOut' with a comma-separated string representing the line
 * numbers within the string at which the matches occur, such as "2,14,27,36".
 * This is mainly useful for grading programs.
 * Returns the number of times the given regular expression is found inside
 * the given string s.  Returns 0 if there are no matches for the regexp.
 */
int regexMatchCountWithLines(const std::string& s, const std::string& regexp,
                             std::string& linesOut);

/**
 * Finds all matches of the given regular expression in the given string s
 * and fills 'linesOut' with the line numbers within the string at which the
 * matches occur, such as [2, 14, 27, 36].
 * This is mainly useful for grading programs.
 * Returns the number of times the given regular expression is found inside
 * the given string s.  Returns 0 if there are no matches for the regexp.
 */
void regexMatchCountWithLines(const std::string& s, const std::string& regexp,
                              Vector<int>& linesOut);

/**
 * Replaces occurrences of the given regular expression in s with the given
 * replacement text, and returns the resulting string.
 * If limit >  0 is passed, replaces that many occurrences of the regex.
 * If limit <= 0 is passed (or omitted), all occurrences are replaced.
 */
std::string regexReplace(const std::string& s, const std::string& regexp,
                         const std::string& replacement, int limit = -1);

#endif // _regexpr_h

/////////////////////// END code extracted from StanfordCPPLib/util/regexpr.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/system/call_stack.h ///////////////////////
/*
 * Copyright (c) 2009, Fredrik Orderud
 * License: BSD licence (http://www.opensource.org/licenses/bsd-license.php)
 *
 * @author Marty Stepp (made changes to F.Orderud version)
 * @version 2018/10/22
 * - bug fix for STL vector vs Stanford Vector
 * @version 2018/10/18
 * - added addr2line_functionName to resolve some function names not in backtrace
 * @version 2016/12/01
 * - bug fixes for call stack line number retrieval
 * - slight refactor of entry class
 * @version 2015/07/05
 * - replaced pragma once with ifndef/define for greater compatibility
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _call_stack_h
#define _call_stack_h
#include <string>
#include <sstream>
#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

namespace stacktrace {

int execAndCapture(std::string cmd, std::string& output);
int addr2line(void* addr, std::string& line);
int addr2line_all(Vector<void*> addrsVector, std::string& output);
int addr2line_all(void** addrs, int length, std::string& output);
std::string addr2line_clean(std::string line);
std::string addr2line_functionName(std::string line);

/*
 * Function to get/set a fake call stack pointer for use in printing a stack trace.
 * Called on Windows only after a signal / SEH handler is invoked to get a stack pointer.
 */
void*& fakeCallStackPointer();

/** Call-stack entry datastructure. */
struct entry {
public:
    /** Default constructor that clears all fields. */
    entry() : line(0), address(nullptr) {
        // empty
    }

    std::string file;       // filename
    size_t      line;       // line number
    std::string lineStr;    // line number string (not always set)
    std::string function;   // name of function or method
    void* address;          // memory address of stack pointer (raw)
    void* address2;         // memory address of stack pointer (from dladdr; data segment offset subtracted)

    /** Serialize entry into a text string. */
    std::string toString() const {
        std::ostringstream os;
        os << "file=\"" << file << "\"";
        if (line > 0) {
            os << " (line=" << line << ")";
        } else if (!lineStr.empty()) {
            os << " (lineStr=\"" << lineStr << "\")";
        }
        os << " function=\"" << function << "\"";
        return os.str();
    }
};

std::ostream& operator <<(std::ostream& out, const entry& ent);

/** Stack-trace base class, for retrieving the current call-stack. */
class call_stack {
public:
    /** Stack-trace consructor.
     \param num_discard - number of stack entries to discard at the top. */
    call_stack(const size_t num_discard = 0);

    virtual ~call_stack() throw();

    /** Serializes the entire call-stack into a text string. */
    std::string to_string() const {
        std::ostringstream os;
        for (int i = 0; i < stack.size(); i++)
            os << stack[i].toString() << std::endl;
        return os.str();
    }

    /** Call stack. */
    Vector<entry> stack;
};

} // namespace stacktrace

#endif // _call_stack_h

/////////////////////// END code extracted from StanfordCPPLib/system/call_stack.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/timer.h ///////////////////////
/*
 * File: timer.h
 * -------------
 * This file exports a Timer class that is useful for measuring the elapsed
 * time of a program in milliseconds over a given interval.
 *
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _timer_h
#define _timer_h

/**
 * A Timer object is useful for measuring the elapsed
 * time of a program in milliseconds over a given interval.
 * Usage example:
 *
 *<pre>
 * Timer tim;
 * tim.start();
 * ... code that takes a while ...
 * tim.stop();
 * cout << "That took " << tim.elapsed() << "ms." << endl;
 *</pre>
 */
class Timer {
public:
    /**
     * Constructs a new timer.
     * If an optional bool parameter of true is passed, also starts the timer.
     */
    Timer(bool autostart = false);

    /**
     * Returns the number of milliseconds that have elapsed since this timer
     * was started.
     * Returns 0 if the timer was never started.
     */
    long elapsed() const;

    /**
     * Returns true if the timer has been started.
     */
    bool isStarted() const;

    /**
     * Starts the timer.
     * If the timer was already started, restarts it such that its 'elapsed'
     * time will be 0 at the moment of the call.
     */
    void start();

    /**
     * Stops the timer and returns the number of elapsed milliseconds.
     * If the timer was never started, 0 ms will be considered to have elapsed.
     */
    long stop();

    /**
     * A static utility function for getting the current time as a Unix
     * timestamp of milliseconds since the epoch.
     */
    static long currentTimeMS();

private:
    // instance variables
    long _startMS;
    long _stopMS;
    bool _isStarted;
};

#endif // _timer_h

/////////////////////// END code extracted from StanfordCPPLib/util/timer.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/note.h ///////////////////////
/*
 * File: note.h
 * ------------
 * This file defines a class named Note that can play musical notes.
 *
 * @author Marty Stepp
 * @version 2016/09/26
 * - initial version
 * @since 2016/09/26
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _note_h
#define _note_h

#include <iostream>
#include <string>

/**
 * Constant for the minimum legal value that an octave can have.
 */
#define OCTAVE_MIN 1

/**
 * Constant for the maximum legal value that an octave can have.
 */
#define OCTAVE_MAX 10

/**
 * Should Note objects print a message to the console as they play?
 */
#define NOTE_DEBUG false

/**
 * Each Note object represents a musical note or rest.
 * A Note encapsulates a pitch (A-G), a duration in seconds, an octave,
 * an accidental (sharp, flat, or natural), and a flag of whether it is the
 * start/end of a repeated section or not.
 * A song or melody can be thought of as a list or array of Note objects.
 */
class Note {
public:
    /**
     * Represents a musical pitch from A-G or rest.
     */
    enum Pitch {A, B, C, D, E, F, G, R};

    /**
     * Represents a musical accidental: sharp, natural, or flat.
     */
    enum Accidental {SHARP, NATURAL, FLAT};

    /**
     * Constructs a Note with the information contained in the given line.
     * @param line a line of input data such as "0.2 C 4 NATURAL false" or "0.4 R false" for a rest
     * @throws an error if line is empty.
     * @throws an error if duration is negative or octave is not
     *         between OCTAVE_MIN and OCTAVE_MAX inclusive.
     */
    Note(std::string line);

    /**
     * Constructs a Note with the given information.
     * @param duration Note's duration in seconds.
     * @param pitch Note's pitch from A through G, or R for a rest.
     * @param octave Note's octave from OCTAVE_MIN through OCTAVE_MAX inclusive.
     * @param accidental Note's accidental from SHARP, FLAT, or NATURAL.
     * @param repeat true if this note starts/ends a repeated section.
     * @throws an error if any value passed is illegal.
     */
    Note(double duration = 0.0, Pitch pitch = R, int octave = OCTAVE_MIN, Accidental accidental = NATURAL, bool repeat = false);

    /**
     * Returns true if note2 has the same state as this Note object; otherwise false.
     * @param o the object to compare against
     */
    bool equals(const Note& note2) const;

    /**
     * Returns this Note's accidental value of SHARP, FLAT, or NATURAL.
     * The accidental value is meaningless for a rest; this method will
     * return NATURAL by default if called on a rest.
     * @return this Note's accidental value of SHARP, FLAT, or NATURAL.
     */
    Accidental getAccidental() const;

    /**
     * Returns this Note's duration in seconds.
     * @return this Note's duration in seconds.
     */
    double getDuration() const;

    /**
     * Returns this Note's octave.
     * The octave value is meaningless for a rest; this method will return
     * OCTAVE_MIN + 1 by default if called on a rest.
     * @return this Note's octave from OCTAVE_MIN to OCTAVE_MAX.
     */
    int getOctave() const;

    /**
     * Returns this Note's pitch value of A-G or R for a rest.
     * @return this Note's pitch value of A-G or R for a rest.
     */
    Pitch getPitch() const;

    /**
     * Returns true if this Note is the start or end of a repeated section.
     * @return true if this Note is the start or end of a repeated section,
     *         otherwise false.
     */
    bool isRepeat() const;

    /**
     * Returns true if this Note is a rest.  Equivalent to checking whether
     * this note's pitch is Pitch.R.  Provided for convenience.
     * @return true if this Note is a rest, otherwise false.
     */
    bool isRest() const;

    /**
     * Plays this note through the underlying audio system.
     * Also may print a message to the system console for debugging.
     * If the audio system is muted or paused, the note may not play.
     */
    void play() const;

    /**
     * Sets this Note's accidental value to be the given value: SHARP, FLAT, or NATURAL.
     * The accidental value is meaningless for a rest, but the Note object still
     * maintains an accidental value internally (initially NATURAL)
     * which is ignored.
     * @param accidental Note's accidental from SHARP, FLAT, or NATURAL.
     * @throws an error if the accidental value passed is illegal.
     */
    void setAccidental(Accidental accidental);

    /**
     * Sets this Note's duration in seconds to be the given value.
     * @param duration Note's duration in seconds.
     * @throws an error if duration is negative.
     */
    void setDuration(double duration);

    /**
     * Sets this Note's octave to be the given value.
     * The octave value is meaningless for a rest, but the Note object still
     * maintains an octave value internally (initially OCTAVE_MIN + 1)
     * which is ignored.
     * @param octave Note's octave from OCTAVE_MIN through OCTAVE_MAX inclusive.
     * @throws an error if octave is not between OCTAVE_MIN and OCTAVE_MAX inclusive.
     */
    void setOctave(int octave);

    /**
     * Sets this Note's pitch to be the given value.
     * @param pitch Note's pitch from A through G, or R for a rest.
     * @throws an error if pitch is invalid.
     */
    void setPitch(Pitch pitch);

    /**
     * Sets this Note's repeat flag to be the given value.
     * @param repeat true to indicate that this note is the start/end of a
     *               repeated section, or false if not.
     */
    void setRepeat(bool repeat);

    /**
     * Returns a string representation of this note.
     * @return A string such as "0.4 C 5 NATURAL false".
     */
    std::string toString() const;

private:
    // member variables (a.k.a. instance variables; fields)
    double duration;
    Pitch pitch;
    int octave;
    Accidental accidental;
    bool repeat;
};

/**
 * Compares the given two Note objects for equality.
 */
bool operator ==(const Note& note1, const Note& note2);

/**
 * Compares the given two Note objects for inequality.
 */
bool operator !=(const Note& note1, const Note& note2);

std::ostream& operator <<(std::ostream& out, const Note& note);

/**
 * Returns a unique integer hash code for the given Note object.
 */
int hashCode(const Note& note);

#endif // _note_h

/////////////////////// END code extracted from StanfordCPPLib/util/note.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/ArrayIntList.h ///////////////////////
/*
 * CS 106B, Marty Stepp
 * ArrayIntList is our example of implementing a basic data structure.
 * The list can store only ints for now.
 * See ArrayIntList.cpp for documentation of each member.
 *
 * @version 2016/08/23
 * - added initializer_list support to match other lib collections
 * @version 2016/07/10
 * - added removeDuplicates() declaration
 */

#ifndef _arrayintlist_h
#define _arrayintlist_h

#include <fstream>
#include <initializer_list>
#include <iostream>
#include <string>

using namespace std;

class ArrayIntList {
public:
    // constructor
    ArrayIntList();
    ArrayIntList(int capacity);
    ArrayIntList(std::initializer_list<int> list);
    ~ArrayIntList();
    
    // member functions (methods)
    void add(int value);
    void clear();
    void ensureCapacity(int capacity);
    int get(int index) const;
    void insert(int index, int value);
    bool isEmpty() const;
    void remove(int index);
    void set(int index, int value);
    int size() const;
    void debug() const;
    
    // section problems
    int maxCount() const;
    
    // exam problems
    void stretch(int k);
    void mirror();
    int longestSortedSequence() const;
    bool filter(const Set<int>& set);
    void removeDuplicates();

    ArrayIntList& operator =(const ArrayIntList& src);

private:
    // member variables (fields)
    int* elements;   // array storing element data
    int mysize;      // number of elements in the array
    int capacity;    // array's length
    
    void checkIndex(int index, int min, int max) const;
};

// overloaded operators
ostream& operator <<(ostream& out, const ArrayIntList& list);
istream& operator >>(istream& in, ArrayIntList& list);

#endif








/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/ArrayIntList.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTreeNode.h ///////////////////////
/*
 * This file contains the declaration of the BinaryTreeNode structure.
 * A BinaryTreeNode stores one integer piece of data in a binary tree of integers.
 *
 * @version 2015/11/10
 * - added nodes for char, double, string
 * @version 2015/07/21
 * - initial version
 */

#ifndef _binarytreenode_h
#define _binarytreenode_h

#include <iostream>
#include <string>



template <typename T>
class BinaryTreeNodeGen {
public:
    static int s_allocated;
    static int s_freed;
    T data;
    BinaryTreeNodeGen<T>* left;
    BinaryTreeNodeGen<T>* right;

    /*
     * Constructs a new tree node with the given data and left/right links.
     */
    BinaryTreeNodeGen<T>(const T& data = T(), BinaryTreeNodeGen* left = nullptr, BinaryTreeNodeGen* right = nullptr);
    ~BinaryTreeNodeGen<T>();
    bool isLeaf() const;
};

// define various node types so that some students need not learn C++ templates
typedef BinaryTreeNodeGen<int> BinaryTreeNode;
typedef BinaryTreeNodeGen<char> BinaryTreeNodeChar;
typedef BinaryTreeNodeGen<double> BinaryTreeNodeDouble;
typedef BinaryTreeNodeGen<std::string> BinaryTreeNodeString;

template <typename T>
std::ostream& operator <<(std::ostream& out, BinaryTreeNodeGen<T>* node);

template <typename T>
std::istream& operator >>(std::istream& input, BinaryTreeNodeGen<T>*& node);


// begin ".cpp" section

template <typename T>
int BinaryTreeNodeGen<T>::s_allocated = 0;

template <typename T>
int BinaryTreeNodeGen<T>::s_freed = 0;

/*
 * Constructs a new tree node with the given data and left/right links.
 */
template <typename T>
BinaryTreeNodeGen<T>::BinaryTreeNodeGen(const T& data, BinaryTreeNodeGen* left, BinaryTreeNodeGen* right) {
    this->data = data;
    this->left = left;
    this->right = right;
    s_allocated++;
}

template <typename T>
BinaryTreeNodeGen<T>::~BinaryTreeNodeGen() {
    s_freed++;
    this->left = nullptr;
    this->right = nullptr;
}

template <typename T>
bool BinaryTreeNodeGen<T>::isLeaf() const {
    return left == nullptr && right == nullptr;
}

template <typename T>
void parseBinaryTreeNodeFromQueue(Queue<std::string>& tokenQueue, BinaryTreeNodeGen<T>*& node) {
    if (tokenQueue.isEmpty()) {
        node = nullptr;
    } else if (tokenQueue.peek() == "(") {
        // start of a new node
        tokenQueue.dequeue();   // the "(" token
        T data;
        std::istringstream isstr(tokenQueue.dequeue());
        readGenericValue(isstr, data);
        node = new BinaryTreeNodeGen<T>(data);
        parseBinaryTreeNodeFromQueue(tokenQueue, node->left);
        parseBinaryTreeNodeFromQueue(tokenQueue, node->right);
        tokenQueue.dequeue();   // the ")" token
    } else if (tokenQueue.peek() == "NULL" || tokenQueue.peek() == "null"
               || tokenQueue.peek() == "nullptr" || tokenQueue.peek() == "/") {
        tokenQueue.dequeue();
        node = nullptr;
    } else {
        node = nullptr;
    }
}

template <typename T>
void makeTreeFromString(std::string s, BinaryTreeNodeGen<T>*& node) {
    // make easier for tokenizing
    s = stringReplace(s, "(", "( ");
    s = stringReplace(s, "[", "( ");
    s = stringReplace(s, ")", " ) ");
    s = stringReplace(s, "]", " ) ");
    s = stringReplace(s, ", ", " , ");
    s = stringReplace(s, "  ", " ");
    s = stringReplace(s, "  ", " ");
    s = stringReplace(s, "  ", " ");
    s = stringReplace(s, "  ", " ");
    Vector<std::string> tokens = stringSplit(s, " ");
    Queue<std::string> tokenQueue;
    for (const std::string& token : tokens) {
        tokenQueue.enqueue(token);
    }

    parseBinaryTreeNodeFromQueue(tokenQueue, node);
}

template <typename T>
std::ostream& binaryTreeOpLtLtHelper(std::ostream& out, BinaryTreeNodeGen<T>* node) {
    if (!node) {
        out << "/";
    } else {
        out << "(";
        writeGenericValue(out, node->data, /* forceQuotes */ true);
        if (!node->isLeaf()) {
            out << " ";
            binaryTreeOpLtLtHelper(out, node->left);
            if (node->right) {
                out << " ";
                binaryTreeOpLtLtHelper(out, node->right);
            }
        }
        out << ")";
    }
    return out;
}

template <typename T>
std::ostream& operator <<(std::ostream& out, BinaryTreeNodeGen<T>* node) {
    binaryTreeOpLtLtHelper(out, node);
    return out;
}

template <typename T>
std::istream& operator >>(std::istream& input, BinaryTreeNodeGen<T>*& node) {
    std::string line;
    if (getline(input, line)) {
        makeTreeFromString(line, node);
    } else {
        node = nullptr;
    }
    return input;
}

#endif // _binarytreenode_h

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTreeNode.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTree.h ///////////////////////
/*
 * This file contains the declaration of the BinaryTree class,
 * which defines a binary tree of integers.
 * See BinaryTree.cpp for implementation of each member.
 *
 * @version 2017/10/20
 * - replaced nulls with nullptr
 * @version 2015/07/21
 */

#ifndef _binarytree_h
#define _binarytree_h

#include <iostream>
#include <string>


using namespace std;

class BinaryTree {
public:
    // public just for exam testing
    BinaryTreeNode* root;   // topmost node in the tree (null if empty)

    BinaryTree(BinaryTreeNode* root = nullptr);
    virtual ~BinaryTree();
    
    void clear();
    // int height();
    string toString();
    
    // lecture problems
    void print() const;
    int size() const;
    void printSideways() const;
    bool contains(int value) const;

    // section problems
    int height() const;
    int countLeftNodes() const;
    bool isBalanced() const;
    bool isBST() const;
    void removeLeaves();
    void completeToLevel(int k);
    void tighten();
    void limitPathSum(int max);
    
    // exam problems
    bool hasPath(int start, int end) const;
    bool isConsecutive() const;
    void limitLeaves(int n);
    int makeFull();
    int range(int min, int max);
    void removeMatchingLeaves(const BinaryTree& other);
    void swapChildrenAtLevel(int level);

    // operators for reading/writing trees based on a root pointer
    // (these are used by the CodeStepByStep tool)
    friend ostream& operator <<(ostream& out, BinaryTreeNode* node);
    friend istream& operator >>(istream& input, BinaryTreeNode*& node);

private:
    int size(BinaryTreeNode* node);
    string toString(BinaryTreeNode* node);
    void deleteTree(BinaryTreeNode* node);
};

ostream& operator <<(ostream& out, const BinaryTree& tree);
istream& operator >>(istream& input, BinaryTree& tree);

enum Order {PRE_ORDER, IN_ORDER, POST_ORDER};

template <typename T>
class TreeSet {
public:
    TreeSet(BinaryTreeNodeGen<T>* root = nullptr);
    virtual ~TreeSet();
    
    void add(T value);
    bool contains(T value);
    T getMin() const;
    int height() const;
    bool isBalanced() const;
    void print(int order = IN_ORDER);
    void printSideways();
    void remove(T value);
    
private:
    BinaryTreeNodeGen<T>* root;   // topmost node in the tree (nullptr if empty)

    void add(BinaryTreeNodeGen<T>*& node, T value);
    bool contains(BinaryTreeNodeGen<T>* node, T value);
    T getMin(BinaryTreeNodeGen<T>* node) const;
    int height(BinaryTreeNodeGen<T>* node) const;
    bool isBalanced(BinaryTreeNodeGen<T>* node) const;
    void print(BinaryTreeNodeGen<T>* node, int order = IN_ORDER);
    void printSideways(BinaryTreeNodeGen<T>* node, string indent);
    void remove(BinaryTreeNodeGen<T>*& node, T value);
};

// method bodies must be in .h file for template classes

template <typename T>
TreeSet<T>::TreeSet(BinaryTreeNodeGen<T>* root) {
    this->root = root;
}

template <typename T>
TreeSet<T>::~TreeSet() {
    // TODO
    root = nullptr;
}

template <typename T>
void TreeSet<T>::add(T value) {
    add(root, value);
}

template <typename T>
void TreeSet<T>::add(BinaryTreeNodeGen<T>*& node, T value) {
    if (!node) {
        node = new BinaryTreeNodeGen<T>(value);
    } else if (value < node->data) {
        add(node->left, value);
    } else if (value > node->data) {
        add(node->right, value);
    }
}

template <typename T>
bool TreeSet<T>::contains(T value) {
    return contains(root, value);
}

template <typename T>
bool TreeSet<T>::contains(BinaryTreeNodeGen<T>* node, T value) {
    if (!node) {
        return false;
    } else if (value == node->data) {
        return true;
    } else if (value < node->data) {
        return contains(node->left, value);
    } else {
        return contains(node->right, value);
    }
}

template <typename T>
T TreeSet<T>::getMin() const {
    return getMin(root);
}

template <typename T>
T TreeSet<T>::getMin(BinaryTreeNodeGen<T>* node) const {
    if (!node) {
        throw ":-(";
    } else if (!node->left) {
        return node->data;
    } else {
        return getMin(node->left);
    }
}

template <typename T>
int TreeSet<T>::height() const {
    return height(root);
}

template <typename T>
int TreeSet<T>::height(BinaryTreeNodeGen<T>* node) const {
    if (!node) {
        return 0;
    } else {
        int l = height(node->left);
        int r = height(node->right);
        return max(l, r) + 1;
    }
}

template <typename T>
bool TreeSet<T>::isBalanced() const {
    return isBalanced(root);
}

template <typename T>
bool TreeSet<T>::isBalanced(BinaryTreeNodeGen<T>* node) const {
    if (!node) {
        return true;
    } else {
        int l = height(node->left);
        int r = height(node->right);
        int bf = r - l;
        if (abs(bf) > 1) {
            cout << "imbalanced: " << node->data << " (balance factor: " << bf << ")" << endl;
        }
        // inefficient because we want to print ALL imbalanced nodes
        bool balL = isBalanced(node->left);
        bool balR = isBalanced(node->right);
        return abs(l - r) <= 1 && balL && balR;
    }
}

template <typename T>
void TreeSet<T>::print(int order) {
    print(root, order);
    cout << endl;
}

template <typename T>
void TreeSet<T>::print(BinaryTreeNodeGen<T>* node, int order) {
    if (node) {
        if (order == PRE_ORDER) {
            cout << node->data << " ";
            cout.flush();
        }
        print(node->left, order);
        if (order == IN_ORDER) {
            cout << node->data << " ";
            cout.flush();
        }
        print(node->right, order);
        if (order == POST_ORDER) {
            cout << node->data << " ";
            cout.flush();
        }
    }
}

template <typename T>
void TreeSet<T>::printSideways() {
    printSideways(root, "");
}

template <typename T>
void TreeSet<T>::printSideways(BinaryTreeNodeGen<T>* node, string indent) {
    if (node) {
        printSideways(node->right, indent + "  ");
        cout << indent << node->data << endl;
        printSideways(node->left, indent + "  ");
    }
}

template <typename T>
void TreeSet<T>::remove(T value) {
    remove(root, value);
}

template <typename T>
void TreeSet<T>::remove(BinaryTreeNodeGen<T>*& node, T value) {
    if (!node) {
        // do nothing
    } else if (value < node->data) {
        remove(node->left, value);
    } else if (value > node->data) {
        remove(node->right, value);
    } else {
        // remove this node
        if (!node->left && !node->right) {
            delete node;
            node = nullptr;
        } else if (!node->left) {
            BinaryTreeNodeGen<T>* trash = node;
            node = node->right;
            delete trash;
        } else if (!node->right) {
            BinaryTreeNodeGen<T>* trash = node;
            node = node->left;
            delete trash;
        } else {
            T min = getMin(node->right);
            remove(node->right, min);
            node->data = min;
        }
    }
}

#endif // _binarytree_h

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTree.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTreeMapNode.h ///////////////////////
/*
 * CS 106B, Marty Stepp
 * This file contains the declaration of the TreeMapNode structure.
 * A TreeMapNode stores one string/integer key/value pair in a tree map.
 *
 * @version 2015/07/21
 */

#ifndef _binarytreemapnode_h
#define _binarytreemapnode_h

#include <string>
using namespace std;

struct BinaryTreeMapNode {
    string key;
    int value;
    BinaryTreeMapNode* left;
    BinaryTreeMapNode* right;

    /*
     * Constructs a new tree node with the given key/value and left/right links.
     */
    BinaryTreeMapNode(string key, int value, BinaryTreeMapNode* left = nullptr, BinaryTreeMapNode* right = nullptr) {
        this->key = key;
        this->value = value;
        this->left = left;
        this->right = right;
    }
    
    /*
     * Returns true if this node has no children.
     */
    bool isLeaf() {
        return !left && !right;
    }
};

#endif

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTreeMapNode.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTreeMap.h ///////////////////////
/*
 * CS 106B, Marty Stepp
 * This file contains the declaration of the BinaryTreeMap class,
 * which defines a map from string->integer using a binary search tree.
 * See BinaryTreeMap.cpp for implementation of each member.
 *
 * @version 2015/07/21
 */

#ifndef _binarytreemap_h
#define _binarytreemap_h

#include <iostream>
#include <string>

using namespace std;

class BinaryTreeMap {
public:
    /*
     * Constructs a new tree map.
     */
    BinaryTreeMap();

    /*
     * Frees memory that was allocated by this tree map.
     */
    ~BinaryTreeMap();
    
    /*
     * Returns true if the given key is contained in this map.
     */
    bool containsKey(string key) const;

    /*
     * Returns the value associated with the given key in this map.
     * If the given key is not associated with any value, returns 0.
     */
    int get(string key) const;

    /*
     * Returns true if this map does not contain any key/value pairs.
     */
    bool isEmpty() const;

    /*
     * Adds the given key/value pair to this tree map, if not already present.
     */
    void put(string key, int value);

    /*
     * Removes the given key and its associated value from this tree map, if it was present.
     */
    void remove(string key);

    /*
     * Returns the number of key/value pairs in this map.
     */
    int size() const;
    
private:
    BinaryTreeMapNode* m_root;   // topmost node in the tree (null if empty)
    int m_size;            // # of k/v pairs in map (0 if empty)

    /*
     * Recursive helpers to implement the above public members.
     * Each helper accepts a pointer to the part of the tree to process.
     */
    bool containsKey(BinaryTreeMapNode* node, string key) const;
    int get(BinaryTreeMapNode* node, string key) const;
    BinaryTreeMapNode* getMin(BinaryTreeMapNode* node) const;
    void put(BinaryTreeMapNode*& node, string key, int value);
    void remove(BinaryTreeMapNode*& node, string key);
};

#endif

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTreeMap.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/HashTableMap.h ///////////////////////
/*
 * CS 106B, Marty Stepp
 * This file contains the declaration of the HashTableMap class, which implements
 * a map using a hash table.
 * The hash table uses separate chaining (a linked list of values in each
 * hash bucket) to resolve hash collisions.
 *
 * @version 2015/07/21
 */

#ifndef _hashtablemap_h
#define _hashtablemap_h

#include <iomanip>
#include <iostream>
#include <string>

/*
 * A HashNode stores a single integer of data and a link to another node.
 */
template <typename K, typename V>
struct HashTableMapNode {
    K key;
    V value;
    HashTableMapNode* next;
    HashTableMapNode(K key, V value, HashTableMapNode* next = nullptr) {
        this->key = key;
        this->value = value;
        this->next = next;
    }
};

template <typename K, typename V>
class HashTableMap {
public:
    HashTableMap(int capacity = 10, double rehashLoadFactor = 0.5);
    void put(K key, V value);
    bool containsKey(K key) const;
    V get(K key) const;
    double loadFactor() const;
    void printStructure() const;
    void remove(K key);
    void setRehashLoadFactor(double loadFactor);

private:
    HashTableMapNode<K, V>** elements;
    int mysize;
    int capacity;
    double rehashLoadFactor;
    int __hashCode(int n) const;
    int __hashCode(double d) const;
    int __hashCode(string s) const;
    int _hashCode(K key) const;

    void rehash();
};

template <typename K, typename V>
HashTableMap<K, V>::HashTableMap(int capacity, double rehashLoadFactor) {
    mysize = 0;
    this->capacity = capacity;
    elements = new HashTableMapNode<K, V>*[capacity]();
    this->rehashLoadFactor = rehashLoadFactor;
}

template <typename K, typename V>
void HashTableMap<K, V>::put(K key, V value) {
    int index = _hashCode(key);
    if (containsKey(key)) {
        // already has a pair for this key; replace the value
        HashTableMapNode<K, V>* current = elements[index];
        while (current) {
            if (current->key == key) {
                current->value = value;
                break;
            }
            current = current->next;
        }
    } else {
        // add a new pair to the front of the chain
        elements[index] = new HashTableMapNode<K, V>(key, value, elements[index]);
        mysize++;
        if (loadFactor() >= rehashLoadFactor) {
            rehash();
        }
    }
}

template <typename K, typename V>
bool HashTableMap<K, V>::containsKey(K key) const {
    int index = _hashCode(key);
    HashTableMapNode<K, V>* current = elements[index];
    while (current) {
        if (current->key == key) {
            return true;
        }
        current = current->next;
    }
    return false;
}

template <typename K, typename V>
V HashTableMap<K, V>::get(K key) const {
    int index = _hashCode(key);
    HashTableMapNode<K, V>* current = elements[index];
    while (current) {
        if (current->key == key) {
            return current->value;
        }
        current = current->next;
    }
    return V();
}

template <typename K, typename V>
int HashTableMap<K, V>::__hashCode(int n) const {
    return n;
}

template <typename K, typename V>
int HashTableMap<K, V>::__hashCode(double d) const {
    return hashCode(d);
}

template <typename K, typename V>
int HashTableMap<K, V>::__hashCode(string s) const {
    return hashCode(s);
}

template <typename K, typename V>
int HashTableMap<K, V>::_hashCode(K key) const {
    return abs(__hashCode(key)) % capacity;
}

template <typename K, typename V>
double HashTableMap<K, V>::loadFactor() const {
    return (double) mysize / capacity;
}

template <typename K, typename V>
void HashTableMap<K, V>::printStructure() const {
    for (int i = 0; i < capacity; i++) {
        cout << "[" << setw(2) << i << "]:";
        HashTableMapNode<K, V>* curr = elements[i];
        while (curr) {
            cout << " -> " << setw(2) << curr->key << ":" << curr->value;
            curr = curr->next;
        }
        cout << endl;
    }
    cout << "size        = " << mysize << endl;
    cout << "capacity    = " << capacity << endl;
    cout << "load factor = " << loadFactor() << endl;
}

template <typename K, typename V>
void HashTableMap<K, V>::rehash() {
    HashTableMapNode<K, V>** oldElements = elements;
    elements = new HashTableMapNode<K, V>*[capacity * 2]();
    capacity *= 2;
    mysize = 0;
    
    for (int i = 0; i < capacity/2; i++) {
        HashTableMapNode<K, V>* curr = oldElements[i];
        while (curr) {
            put(curr->key, curr->value);
            HashTableMapNode<K, V>* trash = curr;
            curr = curr->next;
            delete trash;
        }
    }
    
    delete oldElements;
}

template <typename K, typename V>
void HashTableMap<K, V>::remove(K key) {
    int index = _hashCode(key);
    if (!elements[index]) {
        return;
    } else if (elements[index]->key == key) {
        // remove from front
        HashTableMapNode<K, V>* trash = elements[index];
        elements[index] = elements[index]->next;
        delete trash;
        mysize--;
    } else {
        // remove from later in the chain
        HashTableMapNode<K, V>* current = elements[index];
        while (current->next) {
            if (current->next->key == key) {
                HashTableMapNode<K, V>* trash = current->next;
                current->next = current->next->next;
                delete trash;
                mysize--;
                break;
            }
            current = current->next;
        }
    }
}

template <typename K, typename V>
void HashTableMap<K, V>::setRehashLoadFactor(double loadFactor) {
    this->rehashLoadFactor = loadFactor;
}

#endif

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/HashTableMap.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/HashTableSet.h ///////////////////////
/*
 * CS 106B, Marty Stepp
 * This file contains the declaration of the HashTableSet class, which implements
 * a set of integers using a hash table.
 * The hash table uses separate chaining (a linked list of values in each
 * hash bucket) to resolve hash collisions.
 * See HashTableSet.cpp for the implementation of each member.
 *
 * @version 2015/07/21
 */

#ifndef _hashtableset_h
#define _hashtableset_h

#include <iostream>
#include <string>

/*
 * A HashNode stores a single integer of data and a link to another node.
 */
struct HashTableNode {
    int data;
    HashTableNode* next;
    HashTableNode(int data = 0, HashTableNode* next = nullptr) {
        this->data = data;
        this->next = next;
    }
};

class HashTableSet {
public:
    HashTableSet();
    void add(int value);
    bool contains(int value) const;
    void remove(int value);
    void printStructure() const;

    void trimChains(int k);

private:
    HashTableNode** m_elements;
    int m_size;
    int m_capacity;
    int hashCode(int value) const;
};

#endif






/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/HashTableSet.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/HeapPriorityQueue.h ///////////////////////
/*
 * CS 106B, Marty Stepp
 * This file declares the HeapPriorityQueue class.
 *
 * @version 2015/07/29
 */

#ifndef _heappriorityqueue_h
#define _heappriorityqueue_h

#include <fstream>
#include <iostream>
#include <string>


using namespace std;

struct PQEntry {
    string data;
    double priority;
};

class HeapPriorityQueue {
public:
    HeapPriorityQueue(PQEntry* elements = nullptr, int capacity = 10, int mysize = 0);
    ~HeapPriorityQueue();
    void changePriority(string value, double newPriority);
    void clear();
    string dequeue();
    void enqueue(string value, double priority);
    bool isEmpty() const;
    string peek() const;
    double peekPriority() const;
    void printSideways(int index = 1, string indent = "") const;
    int size() const;
    string toString() const;
    
    friend ostream& operator <<(ostream& out, const HeapPriorityQueue& pq);
    friend istream& operator >>(istream& input, HeapPriorityQueue& pq);
    
    // exam problems
    int atLevel(int level) const;

private:
    PQEntry* elements;   // array of element data
    int capacity;        // length of elements array
    int mysize;          // number of elements that have been added
    
    PriorityQueue<string>* hackPQ;
};

// "a:4, b:16, c:7" => PQ
void stringToPQ(HeapPriorityQueue& pq, string elements);

#endif

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/HeapPriorityQueue.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/LinkedIntList.h ///////////////////////
/*
 * LinkedIntList is an example of a second implementation of a basic data structure.
 * A LinkedIntList is a sequential collection of integers stored with 0-based integer
 * indexes and internally represented as a list of linked node structures.
 *
 * @version 2018/03/19
 * - changed nullptr output to {}
 * @version 2016/11/11
 * - made into template class
 * @version 2016/08/23
 * - added initializer_list support to match other lib collections
 */

#ifndef _linkedintlist_h
#define _linkedintlist_h

#include <initializer_list>
#include <iostream>
#include <string>






/*
 * The internal structure representing a single node.
 */
template <typename T>
class ListNodeGen {
public:
    // global count of how many nodes have been created/destroyed
    static int s_allocated;
    static int s_freed;

    T data;           // element stored in each node
    ListNodeGen<T>* next;   // pointer to the next node (null if none)

    ListNodeGen(T d = T(), ListNodeGen<T>* n = nullptr);
    ~ListNodeGen();

    static void printChain(ListNodeGen<T>* list, std::string name = "list", int maxLength = 10);
};

template <typename T>
std::ostream& operator <<(std::ostream& out, ListNodeGen<T>* front);

template <typename T>
std::istream& operator >>(std::istream& input, ListNodeGen<T>*& front);


// begin "cpp" section of ListNode

template <typename T>
int ListNodeGen<T>::s_allocated = 0;

template <typename T>
int ListNodeGen<T>::s_freed = 0;

template <typename T>
ListNodeGen<T>::ListNodeGen(T d, ListNodeGen<T>* n) {
    data = d;
    next = n;
    s_allocated++;
}

template <typename T>
ListNodeGen<T>::~ListNodeGen() {
    s_freed++;
    next = nullptr;
}

template <typename T>
void ListNodeGen<T>::printChain(ListNodeGen<T>* list, std::string name, int maxLength) {
    std::cout << name << ": ";
    if (!list) {
        std::cout << "nullptr" << std::endl;
    } else {
        ListNodeGen<T>* curr = list;
        bool hasCycle = false;
        for (int i = 0; curr && (maxLength <= 0 || i < maxLength); i++, curr = curr->next) {
            std::cout << curr->data;
            if (curr->next) {
                std::cout << " -> ";
            }
            if (i == maxLength - 1) {
                std::cout << " ... (cycle)";
                hasCycle = true;
            }
        }
        if (!hasCycle) {
            std::cout << " /";
        }
        std::cout << std::endl;
    }
}

template <typename T>
std::ostream& operator <<(std::ostream& out, ListNodeGen<T>* front) {
    if (!front) {
        // out << "nullptr";
        out << "{}";
    } else {
        out << "{";
        if (front) {
            HashSet<ListNodeGen<T>*> visited;
            writeGenericValue(out, front->data, /* forceQuotes */ true);
            visited.add(front);

            ListNodeGen<T>* curr = front->next;
            while (curr) {
                out << ", ";
                writeGenericValue(out, curr->data, /* forceQuotes */ true);
                if (visited.contains(curr)) {
                    out << " (cycle!)";
                    break;
                }

                visited.add(curr);
                curr = curr->next;
            }
        }
        out << "}";
    }
    return out;
}

template <typename T>
std::istream& operator >>(std::istream& input, ListNodeGen<T>*& front) {
    // read into a vector first (yeah yeah, wastes some space, oh well)
    Vector<T> vec;
    T element;
    stanfordcpplib::collections::readCollection(input, vec, element, /* descriptor */ "ListNode::operator >>");

    // now convert into a linked list
    if (vec.isEmpty()) {
        front = nullptr;
    } else {
        front = new ListNodeGen<T>(vec[0]);
        ListNodeGen<T>* curr = front;
        for (int i = 1; i < vec.size(); i++) {
            curr->next = new ListNodeGen<T>(vec[i]);
            curr = curr->next;
        }
    }

    return input;
}

typedef ListNodeGen<int> ListNode;
typedef ListNodeGen<int> ListNodeInt;
typedef ListNodeGen<double> ListNodeDouble;
typedef ListNodeGen<std::string> ListNodeString;

// end "cpp" section of ListNode


class LinkedIntList {
public:
    LinkedIntList();
    LinkedIntList(std::initializer_list<int> list);
    ~LinkedIntList();

    void add(int value);
    void clear();
    int get(int index) const;
    void insert(int index, int value);
    bool isEmpty() const;
    void remove(int index);
    void set(int index, int value);
    int size() const;
    std::string toString() const;

    // section problems
    void setLocked(bool locked);
    int min() const;
    bool isSorted() const;
    int countDuplicates() const;
    void stutter();
    int deleteBack();
    void split();
    void removeAll(int value);
    void doubleList();
    void rotate();
    void reverse();
    void consume(LinkedIntList& list2);
    void transferEvens(LinkedIntList& list2);

    // exam questions
    void chopBothSides(int k);
    void combineDuplicates();
    void expand(int k);
    bool isSortedBy(int k) const;
    void mergeUpTo(int max);
    void partitionSort();
    bool removeRange(int min, int max);

    LinkedIntList& operator =(const LinkedIntList& src);

    // declared here so they can access front
    friend std::ostream& operator <<(std::ostream& out, const LinkedIntList& list);
    friend std::istream& operator >>(std::istream& input, LinkedIntList& list);

private:
    ListNode* front;   // pointer to front node in list;  null if empty

    bool m_locked;     // whether to forbid method calls (for problems)

    void checkIndex(int index, int min, int max) const;
    void checkLocked(std::string memberName = "") const;
};

#endif // _linkedintlist_h

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/LinkedIntList.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/graphsupport.h ///////////////////////
#ifndef _graphsupport_h
#define _graphsupport_h

#include <iostream>
#include <sstream>


using namespace std;

// colors for graph problems
typedef int Color;
extern const Color UNCOLORED, WHITE, GRAY, YELLOW, GREEN, RED, BLUE;
extern const int NUM_COLORS;
extern const Color COLORS[7];
extern const std::string COLOR_NAMES[7];

bool graph_canReach(BasicGraph& graph, Vertex* start, Vertex* end, Set<Vertex*>& visited, Vector<Vertex*>* path = nullptr);
bool graph_isConnected(BasicGraph& graph, bool checkWeak = false);
bool graph_isCyclic(BasicGraph& graph);
void graph_printEdgeList(BasicGraph& graph);
void graph_printAdjacencyList(BasicGraph& graph);
void graph_printAdjacencyMatrix(BasicGraph& graph);
void graph_printVertexDegrees(BasicGraph& graph);
string graph_pathToString(const Vector<Vertex*>& path);
void graph_printPath(const Vector<Vertex*>& path);
void BasicGraph_fromString(BasicGraph& obj, string str);
ostream& operator <<(ostream& out, const Vector<Vertex*>& path);
ostream& operator <<(ostream& out, const Set<Vertex*>& set);

#endif //_graphsupport_h

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/graphsupport.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/types.h ///////////////////////
/*
 * Various support classes and types used in practice problems.
 *
 * @version 2015/08/10
 */

#ifndef _types_h
#define _types_h

#include <iostream>
using namespace std;

struct Domino {
    int first;
    int second;
    
    Domino(int f = 0, int s = 0);
};

ostream& operator <<(ostream& out, const Domino& d);
istream& operator >>(istream& input, Domino& d);

#endif // _types_h

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/types.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/codestepbystep.h ///////////////////////
/*
 * @version 2017/10/06
 * - hid POSIX signal handler behind preprocessor macro
 * @version 2016/12/07
 * - added assert* methods
 */

#ifndef _codestepbystep_h
#define _codestepbystep_h

// basic standard library stuff
#include <cctype>
#include <climits>
#include <cmath>
#include <csignal>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

// STL
#include <algorithm>
#include <deque>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <vector>

// Stanford lib stuff









namespace CodeStepByStep {

std::string testToRun();
bool runAllTests();

std::string htmlDecode(const std::string& s);
std::string htmlEncode(const std::string& s);

template <typename T>
std::string htmlEncode(const T& obj) {
    std::ostringstream out;
    out << obj;
    std::string s = out.str();
    return ::htmlEncode(s);
}

std::ofstream& __getXmlOut();

void printXml(const std::string& s);

void printlnXml(const std::string& s);

void printXml(bool b);

void printlnXml(bool b);

void printXml(double d);

void printlnXml(double d);

void printXml(float f);

void printlnXml(float f);

template <typename T>
void printXml(const T& value) {
    __getXmlOut() << value;
}

template <typename T>
void printlnXml(const T& value) {
    __getXmlOut() << value << std::endl;
}

std::string __stackTraceToString();

void __printException(const std::string& type, const std::string& message = "",
                      const std::string& stacktrace = "", int lineNumber = -1);

void __openXmlOldWay(const std::string& filename);

void __closeXml();

void __printXml(const char* s);

void __printXml(const std::string& s);

void __printlnXml(const char* s);

void __printlnXml(const std::string& s);

// CODE FOR HANDLING SIGNALS (VARIOUS PROGRAM CRASHES)
// #define SIGSTACK ((int) 0xdeadbeef)
// #define SIGUNKNOWN ((int) 0xcafebabe)
// #define SIGTIMEOUT ((int) 0xf00df00d)

void __codeStepByStepSignalHandler(int sig);
#if !defined(_WIN32)
void __posixSignalHandler(int sig, siginfo_t* /*siginfo*/, void* /*context*/);
#endif // !defined(_WIN32)

// functions to parse various collections from strings
void ArrayIntList_fromString(ArrayIntList& list, const std::string& str);
void BasicGraph_fromString(BasicGraph& graph, const std::string& str);
void BinaryTree_fromString(BinaryTree& tree, const std::string& str);
void BinaryTreeNode_fromString(BinaryTreeNode*& root, const std::string& str);
void BinaryTreeNodeptr_fromString(BinaryTreeNode*& root, const std::string& str);
void BinaryTreeNodeChar_fromString(BinaryTreeNodeChar*& root, const std::string& str);
void BinaryTreeNodeCharptr_fromString(BinaryTreeNodeChar*& root, const std::string& str);
void BinaryTreeNodeDouble_fromString(BinaryTreeNodeDouble*& root, const std::string& str);
void BinaryTreeNodeString_fromString(BinaryTreeNodeString*& root, const std::string& str);
void HeapPriorityQueue_fromString(HeapPriorityQueue& pqueue, const std::string& str);
void LinkedIntList_fromString(LinkedIntList& list, const std::string& str);
void ListNode_fromString(ListNode*& ptr, const std::string& str);
void ListNodeptr_fromString(ListNode*& ptr, const std::string& str);
void ListNodeDouble_fromString(ListNodeDouble*& ptr, const std::string& str);
void ListNodeDoubleptr_fromString(ListNodeDouble*& ptr, const std::string& str);
void ListNodeString_fromString(ListNodeString*& ptr, const std::string& str);
void ListNodeStringptr_fromString(ListNodeString*& ptr, const std::string& str);

// this one's body must be here in .h file because it's a template
template <typename T>
void Vector_fromString(Vector<T>& v, const std::string& str) {
    std::istringstream input(str);
    input >> v;
}

// helpers for parts of main() function
void main_begin(int argc, char** argv);
void main_end();

// code for assertions (used in classes+objects problems)
#ifndef _codestepbystep_assertions
#define _codestepbystep_assertions
namespace Assertions {
void assertionPrint(const std::string& msg,
                    const std::string& assertType,
                    const std::string& valueType,
                    const std::string& expected,
                    const std::string& actual,
                    Map<std::string, std::string> attrs = {});

template <typename T>
void assertEquals(const std::string& msg, const std::string& type, T expected, T actual,
                  Map<std::string, std::string> attrs = {}) {
    std::string expStr = genericValueToString(expected);
    std::string actStr = genericValueToString(actual);
    assertionPrint(msg, "assertEquals", type, expStr, actStr, attrs);
}

template <typename T>
void assertEquals(const std::string& msg, T expected, T actual,
                  Map<std::string, std::string> attrs = {}) {
    assertEquals(msg, "T", expected, actual, attrs);
}

void assertEqualsBool(const std::string& msg, bool expected, bool actual);
void assertEqualsChar(const std::string& msg, char expected, char actual);
void assertEqualsDouble(const std::string& msg, double expected, double actual, double tolerance = 0.0001);
void assertEqualsInt(const std::string& msg, int expected, int actual);
void assertEqualsString(const std::string& msg, std::string expected, std::string actual);
void assertTrue(const std::string& msg, bool test);
void assertFalse(const std::string& msg, bool test);
void assertFail(const std::string& msg);
void setTestName(const std::string& name);
} // namespace CodeStepByStep::Assertions
#endif // _codestepbystep_assertions

} // namespace CodeStepByStep


#endif // _codestepbystep_h

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/codestepbystep.h ///////////////////////

